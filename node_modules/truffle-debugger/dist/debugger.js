(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("Debugger", [], factory);
	else if(typeof exports === 'object')
		exports["Debugger"] = factory();
	else
		root["Debugger"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 29);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("debug");

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/object/entries");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.prefixName = prefixName;
exports.keccak256 = keccak256;

var _utils = __webpack_require__(10);

function prefixName(prefix, fn) {
  Object.defineProperty(fn, 'name', {
    value: `${prefix}.${fn.name}`,
    configurable: true
  });

  return fn;
}

/**
 * @return 0x-prefix string of keccak256 hash
 */
function keccak256(...args) {
  return (0, _utils.toHexString)((0, _utils.keccak256)(...args));
}

/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/object/assign");

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = require("reselect-tree");

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/helpers/extends");

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = require("redux-saga/effects");

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__(5);

var _extends3 = _interopRequireDefault(_extends2);

var _entries = __webpack_require__(1);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(3);

var _assign2 = _interopRequireDefault(_assign);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(4);

var _selectors = __webpack_require__(13);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:evm:selectors");

const WORD_SIZE = 0x20;

/**
 * create EVM-level selectors for a given trace step selector
 * may specify additional selectors to include
 */
function createStepSelectors(step, state = null) {
  let base = {
    /**
     * .trace
     *
     * trace step info related to operation
     */
    trace: (0, _reselectTree.createLeaf)([step], ({ gasCost, op, pc }) => ({ gasCost, op, pc })),

    /**
     * .programCounter
     */
    programCounter: (0, _reselectTree.createLeaf)(["./trace"], step => step.pc),

    /**
     * .isJump
     */
    isJump: (0, _reselectTree.createLeaf)(["./trace"], step => step.op != "JUMPDEST" && step.op.indexOf("JUMP") == 0),

    /**
     * .isCall
     *
     * whether the opcode will switch to another calling context
     */
    isCall: (0, _reselectTree.createLeaf)(["./trace"], step => step.op == "CALL" || step.op == "DELEGATECALL"),

    /**
     * .isCreate
     */
    isCreate: (0, _reselectTree.createLeaf)(["./trace"], step => step.op == "CREATE"),

    /**
     * .isHalting
     *
     * whether the instruction halts or returns from a calling context
     */
    isHalting: (0, _reselectTree.createLeaf)(["./trace"], step => step.op == "STOP" || step.op == "RETURN")
  };

  if (state) {
    const isRelative = path => typeof path == "string" && (path.startsWith("./") || path.startsWith("../"));

    if (isRelative(state)) {
      state = `../${state}`;
    }

    (0, _assign2.default)(base, {
      /**
       * .callAddress
       *
       * address transferred to by call operation
       */
      callAddress: (0, _reselectTree.createLeaf)(["./isCall", "./trace", state], (matches, step, { stack }) => {
        if (!matches) return null;

        let address = stack[stack.length - 2];
        address = "0x" + address.substring(24);
        return address;
      }),

      /**
       * .createBinary
       *
       * binary code to execute via create operation
       */
      createBinary: (0, _reselectTree.createLeaf)(["./isCreate", "./trace", state], (matches, step, { stack, memory }) => {
        if (!matches) return null;

        // Get the code that's going to be created from memory.
        // Note we multiply by 2 because these offsets are in bytes.
        const offset = parseInt(stack[stack.length - 2], 16) * 2;
        const length = parseInt(stack[stack.length - 3], 16) * 2;

        return "0x" + memory.join("").substring(offset, offset + length);
      })
    });
  }

  return base;
}

const evm = (0, _reselectTree.createSelectorTree)({
  /**
   * evm.state
   */
  state: state => state.evm,

  /**
   * evm.info
   */
  info: {
    /**
     * evm.info.contexts
     */
    contexts: (0, _reselectTree.createLeaf)(['/state'], state => state.info.contexts.byContext),

    /**
     * evm.info.instances
     */
    instances: (0, _reselectTree.createLeaf)(['/state'], state => state.info.instances.byAddress),

    /**
     * evm.info.binaries
     */
    binaries: {
      _: (0, _reselectTree.createLeaf)(['/state'], state => state.info.contexts.byBinary),

      /**
       * evm.info.binaries.search
       *
       * returns function (binary) => context
       */
      search: (0, _reselectTree.createLeaf)(['./_'], binaries => {
        // HACK ignore link references for search
        // link references come in two forms: with underscores or all zeroes
        // the underscore format is used by Truffle to reference links by name
        // zeroes are used by solc directly, as libraries inject their own
        // address at CREATE-time
        const toRegExp = binary => new RegExp(`^${binary.replace(/__.{38}|0{40}/g, ".{40}")}`);

        let matchers = (0, _entries2.default)(binaries).map(([binary, { context }]) => ({
          context,
          regex: toRegExp(binary)
        }));

        return binary => matchers.filter(({ context, regex }) => binary.match(regex)).map(({ context }) => ({ context }))[0] || null;
      })
    }
  },

  /**
   * evm.current
   */
  current: {

    /**
     * evm.current.callstack
     */
    callstack: state => state.evm.proc.callstack,

    /**
     * evm.current.call
     */
    call: (0, _reselectTree.createLeaf)(["./callstack"], stack => stack.length ? stack[stack.length - 1] : {}),

    /**
     * evm.current.context
     */
    context: (0, _reselectTree.createLeaf)(["./call", "/info/instances", "/info/binaries/search", "/info/contexts"], ({ address, binary }, instances, search, contexts) => {
      let record;
      if (address) {
        record = instances[address];
        if (!record) {
          return { address };
        }
        binary = record.binary;
      } else {
        record = search(binary);
      }

      let context = contexts[(record || {}).context];

      return (0, _extends3.default)({}, context, {
        binary
      });
    }),

    /**
     * evm.current.state
     *
     * evm state info: as of last operation, before op defined in step
     */
    state: (0, _assign2.default)({}, ...["depth", "error", "gas", "memory", "stack", "storage"].map(param => ({
      [param]: (0, _reselectTree.createLeaf)([_selectors2.default.step], step => step[param])
    }))),

    /**
     * evm.current.step
     */
    step: createStepSelectors(_selectors2.default.step, "./state")
  },

  /**
   * evm.next
   */
  next: {

    /**
     * evm.next.state
     *
     * evm state as a result of next step operation
     */
    state: (0, _assign2.default)({}, ...["depth", "error", "gas", "memory", "stack", "storage"].map(param => ({
      [param]: (0, _reselectTree.createLeaf)([_selectors2.default.next], step => step[param])
    }))),

    step: createStepSelectors(_selectors2.default.next, "./state")
  }
});

exports.default = evm;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__(5);

var _extends3 = _interopRequireDefault(_extends2);

var _entries = __webpack_require__(1);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(3);

var _assign2 = _interopRequireDefault(_assign);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(4);

var _truffleSolidityUtils = __webpack_require__(34);

var _truffleSolidityUtils2 = _interopRequireDefault(_truffleSolidityUtils);

var _truffleCodeUtils = __webpack_require__(35);

var _truffleCodeUtils2 = _interopRequireDefault(_truffleCodeUtils);

var _selectors = __webpack_require__(7);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:solidity:selectors");

function getSourceRange(instruction = {}) {
  return {
    start: instruction.start || 0,
    length: instruction.length || 0,
    lines: instruction.range || {
      start: {
        line: 0, column: 0
      },
      end: {
        line: 0, column: 0
      }
    }
  };
}

let solidity = (0, _reselectTree.createSelectorTree)({
  /**
   * solidity.state
   */
  state: state => state.solidity,

  /**
   * solidity.info
   */
  info: {
    /**
     * solidity.info.sources
     */
    sources: (0, _reselectTree.createLeaf)(['/state'], state => state.info.sources.byId),

    /**
     * solidity.info.sourceMaps
     */
    sourceMaps: (0, _reselectTree.createLeaf)(['/state'], state => state.info.sourceMaps.byContext)
  },

  /**
   * solidity.current
   */
  current: {

    /**
     * solidity.current.sourceMap
     */
    sourceMap: (0, _reselectTree.createLeaf)([_selectors2.default.current.context, "/info/sourceMaps"], ({ context }, sourceMaps) => sourceMaps[context] || {}),

    /**
     * solidity.current.functionDepth
     */
    functionDepth: state => state.solidity.proc.functionDepth,

    /**
     * solidity.current.instructions
     */
    instructions: (0, _reselectTree.createLeaf)(["/info/sources", _selectors2.default.current.context, "./sourceMap"], (sources, { binary }, { sourceMap }) => {
      if (!binary) {
        return [];
      }

      let instructions = _truffleCodeUtils2.default.parseCode(binary);

      if (!sourceMap) {
        // Let's create a source map to use since none exists. This source map
        // maps just as many ranges as there are instructions, and ensures every
        // instruction is marked as "jumping out". This will ensure all
        // available debugger commands step one instruction at a time.
        //
        // This is kindof a hack; perhaps this should be broken out into separate
        // context types. TODO
        sourceMap = "";
        for (var i = 0; i < instructions.length; i++) {
          sourceMap += i + ":" + i + ":1:-1;";
        }
      }

      var lineAndColumnMappings = (0, _assign2.default)({}, ...(0, _entries2.default)(sources).map(([id, { source }]) => ({
        [id]: _truffleSolidityUtils2.default.getCharacterOffsetToLineAndColumnMapping(source || "")
      })));
      var humanReadableSourceMap = _truffleSolidityUtils2.default.getHumanReadableSourceMap(sourceMap);

      let primaryFile = humanReadableSourceMap[0].file;
      debug("primaryFile %o", primaryFile);

      return instructions.map((instruction, index) => {
        // lookup source map by index and add `index` property to
        // instruction
        //

        const sourceMap = humanReadableSourceMap[index] || {};

        return {
          instruction: (0, _extends3.default)({}, instruction, { index }),
          sourceMap
        };
      }).map(({ instruction, sourceMap }) => {
        // add source map information to instruction, or defaults
        //

        const { jump, start = 0, length = 0, file = primaryFile } = sourceMap;
        const lineAndColumnMapping = lineAndColumnMappings[file] || {};
        const range = {
          start: lineAndColumnMapping[start] || { line: null, column: null },
          end: lineAndColumnMapping[start + length] || { line: null, column: null }
        };

        if (range.start.line === null) {
          debug("sourceMap %o", sourceMap);
        }

        return (0, _extends3.default)({}, instruction, {

          jump,
          start,
          length,
          file,
          range
        });
      });
    }),

    /**
     * solidity.current.instructionAtProgramCounter
     */
    instructionAtProgramCounter: (0, _reselectTree.createLeaf)(["./instructions"], instructions => {
      let map = [];
      instructions.forEach(function (instruction) {
        map[instruction.pc] = instruction;
      });

      // fill in gaps in map by defaulting to the last known instruction
      let lastSeen = null;
      for (let [pc, instruction] of map.entries()) {
        if (instruction) {
          lastSeen = instruction;
        } else {
          map[pc] = lastSeen;
        }
      }
      return map;
    }),

    /**
     * solidity.current.instruction
     */
    instruction: (0, _reselectTree.createLeaf)(["./instructionAtProgramCounter", _selectors2.default.current.step.programCounter], (map, pc) => map[pc] || {}),

    /**
     * solidity.current.source
     */
    source: (0, _reselectTree.createLeaf)(["/info/sources", "./instruction"], (sources, { file: id }) => sources[id] || {}),

    /**
     * solidity.current.sourceRange
     */
    sourceRange: (0, _reselectTree.createLeaf)(["./instruction"], getSourceRange),

    /**
     * solidity.current.isSourceRangeFinal
     */
    isSourceRangeFinal: (0, _reselectTree.createLeaf)(["./instructionAtProgramCounter", _selectors2.default.current.step.programCounter, _selectors2.default.next.step.programCounter], (map, current, next) => {
      if (!map[next]) {
        return true;
      }

      current = map[current];
      next = map[next];

      return current.start != next.start || current.length != next.length || current.file != next.file;
    }),

    /**
     * solidity.current.isMultiline
     */
    isMultiline: (0, _reselectTree.createLeaf)(["./sourceRange"], ({ lines }) => lines.start.line != lines.end.line),

    /**
     * solidity.current.willJump
     */
    willJump: (0, _reselectTree.createLeaf)([_selectors2.default.current.step.isJump], isJump => isJump),

    /**
     * solidity.current.jumpDirection
     */
    jumpDirection: (0, _reselectTree.createLeaf)(["./instruction"], (i = {}) => i.jump || "-")
  }
});

exports.default = solidity;

/***/ }),
/* 9 */
/***/ (function(module, exports) {

module.exports = require("redux");

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MAX_WORD = exports.WORD_SIZE = undefined;

var _entries = __webpack_require__(1);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(3);

var _assign2 = _interopRequireDefault(_assign);

exports.cleanBigNumbers = cleanBigNumbers;
exports.typeIdentifier = typeIdentifier;
exports.typeClass = typeClass;
exports.allocateDeclarations = allocateDeclarations;
exports.specifiedSize = specifiedSize;
exports.storageSize = storageSize;
exports.isReference = isReference;
exports.referenceType = referenceType;
exports.baseDefinition = baseDefinition;
exports.toBigNumber = toBigNumber;
exports.toSignedBigNumber = toSignedBigNumber;
exports.toHexString = toHexString;
exports.toBytes = toBytes;
exports.keccak256 = keccak256;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _bignumber = __webpack_require__(14);

var _web = __webpack_require__(22);

var _web2 = _interopRequireDefault(_web);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:data:decode:utils");

const WORD_SIZE = exports.WORD_SIZE = 0x20;
const MAX_WORD = exports.MAX_WORD = new _bignumber.BigNumber(2).pow(256).minus(1);

/**
 * recursively converts big numbers into something nicer to look at
 */
function cleanBigNumbers(value) {
  if (_bignumber.BigNumber.isBigNumber(value)) {
    return value.toNumber();
  } else if (value && value.map != undefined) {
    return value.map(inner => cleanBigNumbers(inner));
  } else if (value && typeof value == "object") {
    return (0, _assign2.default)({}, ...(0, _entries2.default)(value).map(([key, inner]) => ({ [key]: cleanBigNumbers(inner) })));
  } else {
    return value;
  }
}

function typeIdentifier(definition) {
  return definition.typeDescriptions.typeIdentifier;
}

/**
 * returns basic type class for a variable definition node
 * e.g.:
 *  `t_uint256` becomes `uint`
 *  `t_struct$_Thing_$20_memory_ptr` becomes `struct`
 */
function typeClass(definition) {
  return typeIdentifier(definition).match(/t_([^$_0-9]+)/)[1];
}

/**
 * Allocate storage for given variable declarations
 *
 * Postcondition: starts a new slot and occupies whole slots
 */
function allocateDeclarations(declarations, refs, slot = 0, index = WORD_SIZE - 1, path = []) {
  if (index < WORD_SIZE - 1) {
    // starts a new slot
    slot++;
    index = WORD_SIZE - 1;
  }

  let parentFrom = { slot, index: 0 };
  var parentTo = { slot, index: WORD_SIZE - 1 };
  let mapping = {};

  for (let declaration of declarations) {
    let { from, to, next, children } = allocateDeclaration(declaration, refs, slot, index);

    mapping[declaration.id] = { from, to, name: declaration.name };
    if (children !== undefined) {
      mapping[declaration.id].children = children;
    }

    slot = next.slot;
    index = next.index;

    parentTo = { slot: to.slot, index: WORD_SIZE - 1 };
  }

  if (index < WORD_SIZE - 1) {
    slot++;
    index = WORD_SIZE - 1;
  }

  return {
    from: parentFrom,
    to: parentTo,
    next: { slot, index },
    children: mapping
  };
}

function allocateValue(slot, index, bytes) {
  let from = index - bytes + 1 >= 0 ? { slot, index: index - bytes + 1 } : { slot: slot + 1, index: WORD_SIZE - bytes };

  let to = { slot: from.slot, index: from.index + bytes - 1 };

  let next = from.index == 0 ? { slot: from.slot + 1, index: WORD_SIZE - 1 } : { slot: from.slot, index: from.index - 1 };

  return { from, to, next };
}

function allocateDeclaration(declaration, refs, slot, index) {
  let definition = refs[declaration.id].definition;
  var byteSize = storageSize(definition); // yum

  if (typeClass(definition) != "struct") {
    return allocateValue(slot, index, byteSize);
  }

  let struct = refs[definition.typeName.referencedDeclaration];
  debug("struct: %O", struct);

  let result = allocateDeclarations(struct.variables || [], refs, slot, index);
  debug("struct result %o", result);
  return result;
}

/**
 * e.g. uint48 -> 6
 * @return size in bytes for explicit type size, or `null` if not stated
 */
function specifiedSize(definition) {
  let specified = typeIdentifier(definition).match(/t_[a-z]+([0-9]+)/);

  if (!specified) {
    return null;
  }

  let num = specified[1];

  switch (typeClass(definition)) {
    case "int":
    case "uint":
      return num / 8;

    case "bytes":
      return num;

    default:
      debug("Unknown type for size specification: %s", typeIdentifier(definition));
  }
}

function storageSize(definition) {
  switch (typeClass(definition)) {
    case "bool":
      return 1;

    case "address":
      return 20;

    case "int":
    case "uint":
      // is this a HACK? ("256" / 8)
      return typeIdentifier(definition).match(/t_[a-z]+([0-9]+)/)[1] / 8;

    case "string":
    case "bytes":
    case "array":
      return WORD_SIZE;
  }
}

function isReference(definition) {
  return typeIdentifier(definition).match(/_(memory|storage)(_ptr)?$/) != null;
}

function referenceType(definition) {
  return typeIdentifier(definition).match(/_([^_]+)(_ptr)?$/)[1];
}

function baseDefinition(definition) {
  let baseIdentifier = typeIdentifier(definition)
  // first dollar sign     last dollar sign
  //   `---------.       ,---'
  .match(/^[^$]+\$_(.+)_\$[^$]+$/)[1];
  //              `----' greedy match

  // HACK - internal types for memory or storage also seem to be pointers
  if (baseIdentifier.match(/_(memory|storage)$/) != null) {
    baseIdentifier = `${baseIdentifier}_ptr`;
  }

  // another HACK - we get away with it becausewe're only using that one property
  return {
    typeDescriptions: {
      typeIdentifier: baseIdentifier
    }
  };
}

function toBigNumber(bytes) {
  if (bytes == undefined) {
    return undefined;
  } else if (typeof bytes == "string") {
    return new _bignumber.BigNumber(bytes, 16);
  } else if (typeof bytes == "number" || _bignumber.BigNumber.isBigNumber(bytes)) {
    return new _bignumber.BigNumber(bytes);
  } else if (bytes.reduce) {
    return bytes.reduce((num, byte) => num.times(0x100).plus(byte), new _bignumber.BigNumber(0));
  }
}

function toSignedBigNumber(bytes) {
  if (bytes[0] < 0b10000000) {
    // first bit is 0
    return toBigNumber(bytes);
  } else {
    return toBigNumber(bytes.map(b => 0xff - b)).plus(1).negated();
  }
}

/**
 * @param bytes - Uint8Array
 * @param length - desired byte length (pad with zeroes)
 * @param trim - omit leading zeroes
 */
function toHexString(bytes, length = 0, trim = false) {
  if (typeof length == "boolean") {
    trim = length;
    length = 0;
  }

  if (_bignumber.BigNumber.isBigNumber(bytes)) {
    bytes = toBytes(bytes);
  }

  const pad = s => `${"00".slice(0, 2 - s.length)}${s}`;

  //                                          0  1  2  3  4
  //                                 0  1  2  3  4  5  6  7
  // bytes.length:        5  -  0x(          e5 c2 aa 09 11 )
  // length (preferred):  8  -  0x( 00 00 00 e5 c2 aa 09 11 )
  //                                `--.---'
  //                                     offset 3
  if (bytes.length < length) {
    let prior = bytes;
    bytes = new Uint8Array(length);

    bytes.set(prior, length - prior.length);
  }

  debug("bytes: %o", bytes);

  let string = bytes.reduce((str, byte) => `${str}${pad(byte.toString(16))}`, "");

  if (trim) {
    string = string.replace(/^(00)+/, "");
  }

  if (string.length == 0) {
    string = "00";
  }

  return `0x${string}`;
}

function toBytes(number, length = 0) {
  if (number < 0) {
    return [];
  }

  let hex = number.toString(16);
  if (hex.length % 2 == 1) {
    hex = `0${hex}`;
  }

  let bytes = new Uint8Array(hex.match(/.{2}/g).map(byte => parseInt(byte, 16)));

  if (bytes.length < length) {
    let prior = bytes;
    bytes = new Uint8Array(length);
    bytes.set(prior, length - prior.length);
  }

  return bytes;
}

function keccak256(...args) {
  let web3 = new _web2.default();

  args = args.map(arg => {
    if (typeof arg == "number" || _bignumber.BigNumber.isBigNumber(arg)) {
      return toHexString(toBytes(arg, WORD_SIZE)).slice(2);
    } else if (typeof arg == "string") {
      return web3.toHex(arg).slice(2);
    } else {
      return "";
    }
  });

  let sha = web3.sha3(args.join(''), { encoding: 'hex' });
  debug("sha %o", sha);
  return toBigNumber(sha);
}

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(4);

var _jsonPointer = __webpack_require__(15);

var _jsonPointer2 = _interopRequireDefault(_jsonPointer);

var _selectors = __webpack_require__(8);

var _selectors2 = _interopRequireDefault(_selectors);

var _map = __webpack_require__(36);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:ast:selectors");

/**
 * ast
 */
const ast = (0, _reselectTree.createSelectorTree)({
  /**
   * ast.views
   */
  views: {
    /**
     * ast.views.sources
     */
    sources: (0, _reselectTree.createLeaf)([_selectors2.default.info.sources], sources => sources)
  },

  /**
   * ast.current
   */
  current: {

    /**
     * ast.current.tree
     *
     * ast for current source
     */
    tree: (0, _reselectTree.createLeaf)([_selectors2.default.current.source], ({ ast }) => ast),

    /**
     * ast.current.index
     *
     * source ID
     */
    index: (0, _reselectTree.createLeaf)([_selectors2.default.current.source], ({ id }) => id),

    /**
     * ast.current.pointer
     *
     * jsonpointer for current ast node
     */
    pointer: (0, _reselectTree.createLeaf)(["./tree", _selectors2.default.current.sourceRange], (ast, range) => (0, _map.findRange)(ast, range.start, range.length)),

    /**
     * ast.current.node
     *
     * current ast node to execute
     */
    node: (0, _reselectTree.createLeaf)(["./tree", "./pointer"], (ast, pointer) => pointer ? _jsonPointer2.default.get(ast, pointer) : _jsonPointer2.default.get(ast, ""))

  }
});

exports.default = ast;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.saveSteps = saveSteps;
exports.receiveAddresses = receiveAddresses;
exports.next = next;
exports.tick = tick;
exports.tock = tock;
exports.endTrace = endTrace;
const SAVE_STEPS = exports.SAVE_STEPS = "SAVE_STEPS";
function saveSteps(steps) {
  return {
    type: SAVE_STEPS,
    steps
  };
}

const RECEIVE_ADDRESSES = exports.RECEIVE_ADDRESSES = "RECEIVE_ADDRESSES";
function receiveAddresses(addresses) {
  return {
    type: RECEIVE_ADDRESSES,
    addresses
  };
}

const NEXT = exports.NEXT = "NEXT";
function next() {
  return { type: NEXT };
}

const TICK = exports.TICK = "TICK";
function tick() {
  return { type: TICK };
}

const TOCK = exports.TOCK = "TOCK";
function tock() {
  return { type: TOCK };
}

const END_OF_TRACE = exports.END_OF_TRACE = "EOT";
function endTrace() {
  return { type: END_OF_TRACE };
}

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _reselectTree = __webpack_require__(4);

let trace = (0, _reselectTree.createSelectorTree)({
  /**
   * trace.index
   *
   * current step index
   */
  index: state => state.trace.proc.index,

  /**
   * trace.steps
   *
   * all trace steps
   */
  steps: state => state.trace.info.steps,

  /**
   * trace.stepsRemaining
   *
   * number of steps remaining in trace
   */
  stepsRemaining: (0, _reselectTree.createLeaf)(["./steps", "./index"], (steps, index) => steps.length - index),

  /**
   * trace.step
   *
   * current trace step
   */
  step: (0, _reselectTree.createLeaf)(["./steps", "./index"], (steps, index) => steps[index]),

  /**
   * trace.next
   *
   * next trace step or {}
   */
  next: (0, _reselectTree.createLeaf)(["./steps", "./index"], (steps, index) => index < steps.length - 1 ? steps[index + 1] : {})
});

exports.default = trace;

/***/ }),
/* 14 */
/***/ (function(module, exports) {

module.exports = require("bignumber.js");

/***/ }),
/* 15 */
/***/ (function(module, exports) {

module.exports = require("json-pointer");

/***/ }),
/* 16 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/object/keys");

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.start = start;
exports.ready = ready;
exports.error = error;
exports.finish = finish;
exports.recordContracts = recordContracts;
const START = exports.START = "SESSION_START";
function start(txHash, provider) {
  return {
    type: START,
    txHash, provider
  };
}

const READY = exports.READY = "SESSION_READY";
function ready() {
  return {
    type: READY
  };
}

const ERROR = exports.ERROR = "SESSION_ERROR";
function error(error) {
  return {
    type: ERROR,
    error
  };
}

const FINISH = exports.FINISH = "SESSION_FINISH";
function finish() {
  return {
    type: FINISH
  };
}

const RECORD_CONTRACTS = exports.RECORD_CONTRACTS = "RECORD_CONTRACTS";
function recordContracts(contexts, sources) {
  return {
    type: RECORD_CONTRACTS,
    contexts, sources
  };
}

/***/ }),
/* 18 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/set");

/***/ }),
/* 19 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/helpers/asyncToGenerator");

/***/ }),
/* 20 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/promise");

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.beginStep = beginStep;
exports.advance = advance;
exports.stepNext = stepNext;
exports.stepOver = stepOver;
exports.stepInto = stepInto;
exports.stepOut = stepOut;
exports.interrupt = interrupt;
exports.continueUntil = continueUntil;
const BEGIN_STEP = exports.BEGIN_STEP = "BEGIN_STEP";
function beginStep(type) {
  return {
    type: BEGIN_STEP,
    stepType: type
  };
}

const ADVANCE = exports.ADVANCE = "ADVANCE";
function advance() {
  return { type: ADVANCE };
}

const STEP_NEXT = exports.STEP_NEXT = "STEP_NEXT";
function stepNext() {
  return { type: STEP_NEXT };
}

const STEP_OVER = exports.STEP_OVER = "STEP_OVER";
function stepOver() {
  return { type: STEP_OVER };
}

const STEP_INTO = exports.STEP_INTO = "STEP_INTO";
function stepInto() {
  return { type: STEP_INTO };
}

const STEP_OUT = exports.STEP_OUT = "STEP_OUT";
function stepOut() {
  return { type: STEP_OUT };
}

const INTERRUPT = exports.INTERRUPT = "INTERRUPT";
function interrupt() {
  return { type: INTERRUPT };
}

const CONTINUE_UNTIL = exports.CONTINUE_UNTIL = "CONTINUE_UNTIL";
function continueUntil(...breakpoints) {
  return {
    type: CONTINUE_UNTIL,
    breakpoints
  };
}

/***/ }),
/* 22 */
/***/ (function(module, exports) {

module.exports = require("web3");

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _entries = __webpack_require__(1);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(3);

var _assign2 = _interopRequireDefault(_assign);

exports.scope = scope;
exports.declare = declare;
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(6);

var _jsonPointer = __webpack_require__(15);

var _jsonPointer2 = _interopRequireDefault(_jsonPointer);

var _helpers = __webpack_require__(2);

var _actions = __webpack_require__(12);

var _actions2 = __webpack_require__(24);

var actions = _interopRequireWildcard(_actions2);

var _selectors = __webpack_require__(25);

var _selectors2 = _interopRequireDefault(_selectors);

var _utils = __webpack_require__(10);

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:data:sagas");

function* scope(nodeId, pointer, parentId, sourceId) {
  yield (0, _effects.put)(actions.scope(nodeId, pointer, parentId, sourceId));
}

function* declare(node) {
  yield (0, _effects.put)(actions.declare(node));
}

function* tickSaga() {
  let {
    tree,
    id: treeId,
    node,
    pointer
  } = yield (0, _effects.select)(_selectors2.default.views.ast);

  let scopes = yield (0, _effects.select)(_selectors2.default.info.scopes);
  let definitions = yield (0, _effects.select)(_selectors2.default.views.scopes.inlined);

  let stack = yield (0, _effects.select)(_selectors2.default.next.state.stack);
  if (!stack) {
    return;
  }

  let top = stack.length - 1;
  var parameters, returnParameters, assignments, storageVars;

  if (!node) {
    return;
  }

  switch (node.nodeType) {

    case "FunctionDefinition":
      // stack is only ready for interpretation after the last step of each
      // source range
      //
      // the data module always looks at the result of a particular opcode
      // (i.e., the following trace step's stack/memory/storage), so this
      // asserts that the _current_ operation is the final one before
      // proceeding
      if (!(yield (0, _effects.select)(_selectors2.default.views.atLastInstructionForSourceRange))) {
        break;
      }

      parameters = node.parameters.parameters.map((p, i) => `${pointer}/parameters/parameters/${i}`);

      returnParameters = node.returnParameters.parameters.map((p, i) => `${pointer}/returnParameters/parameters/${i}`);

      assignments = returnParameters.concat(parameters).reverse().map(pointer => _jsonPointer2.default.get(tree, pointer).id).map((id, i) => ({ [id]: { "stack": top - i } })).reduce((acc, assignment) => (0, _assign2.default)(acc, assignment), {});

      yield (0, _effects.put)(actions.assign(treeId, assignments));
      break;

    case "ContractDefinition":
      let storageVars = scopes[node.id].variables || [];
      let slot = 0;
      let index = _utils.WORD_SIZE - 1; // cause lower-order
      debug("storage vars %o", storageVars);

      let allocation = utils.allocateDeclarations(storageVars, definitions);
      assignments = (0, _assign2.default)({}, ...(0, _entries2.default)(allocation.children).map(([id, storage]) => ({ [id]: { storage } })));
      debug("assignments %O", assignments);

      yield (0, _effects.put)(actions.assign(treeId, assignments));
      break;

    case "VariableDeclaration":
      yield (0, _effects.put)(actions.assign(treeId, {
        [_jsonPointer2.default.get(tree, pointer).id]: { "stack": top }
      }));

    default:
      break;
  }
}

function* saga() {
  yield (0, _effects.takeEvery)(_actions.TICK, function* () {
    try {
      yield* tickSaga();
    } catch (e) {
      debug(e);
    }
  });
}

exports.default = (0, _helpers.prefixName)("data", saga);

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.scope = scope;
exports.declare = declare;
exports.assign = assign;
const SCOPE = exports.SCOPE = "SCOPE";
function scope(id, pointer, parentId, sourceId) {
  return {
    type: SCOPE,
    id, pointer, parentId, sourceId
  };
}

const DECLARE = exports.DECLARE = "DECLARE_VARIABLE";
function declare(node) {
  return {
    type: DECLARE,
    node
  };
}

const ASSIGN = exports.ASSIGN = "ASSIGN";
function assign(context, assignments) {
  return {
    type: ASSIGN,
    context, assignments
  };
}

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__(5);

var _extends3 = _interopRequireDefault(_extends2);

var _entries = __webpack_require__(1);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(3);

var _assign2 = _interopRequireDefault(_assign);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(4);

var _jsonPointer = __webpack_require__(15);

var _jsonPointer2 = _interopRequireDefault(_jsonPointer);

var _selectors = __webpack_require__(11);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(7);

var _selectors4 = _interopRequireDefault(_selectors3);

var _selectors5 = __webpack_require__(8);

var _selectors6 = _interopRequireDefault(_selectors5);

var _decode = __webpack_require__(46);

var _decode2 = _interopRequireDefault(_decode);

var _utils = __webpack_require__(10);

var decodeUtils = _interopRequireWildcard(_utils);

var _bignumber = __webpack_require__(14);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:data:selectors");

function createStateSelectors({ stack, memory, storage }) {
  return {
    /**
     * .stack
     */
    stack: (0, _reselectTree.createLeaf)([stack], words => (words || []).map(word => decodeUtils.toBytes(decodeUtils.toBigNumber(word, decodeUtils.WORD_SIZE)))),

    /**
     * .memory
     */
    memory: (0, _reselectTree.createLeaf)([memory], words => new Uint8Array((words.join("").match(/.{1,2}/g) || []).map(byte => parseInt(byte, 16)))),

    /**
     * .storage
     */
    storage: (0, _reselectTree.createLeaf)([storage], mapping => (0, _assign2.default)({}, ...(0, _entries2.default)(mapping).map(([address, word]) => ({
      [`0x${address}`]: new Uint8Array((word.match(/.{1,2}/g) || []).map(byte => parseInt(byte, 16)))
    }))))
  };
}

const data = (0, _reselectTree.createSelectorTree)({
  state: state => state.data,

  /**
   * data.views
   */
  views: {
    ast: (0, _reselectTree.createLeaf)([_selectors2.default.current], tree => tree),

    atLastInstructionForSourceRange: (0, _reselectTree.createLeaf)([_selectors6.default.current.isSourceRangeFinal], final => final),

    /**
     * data.views.scopes
     */
    scopes: {

      /**
       * data.views.scopes.inlined
       */
      inlined: (0, _reselectTree.createLeaf)(["/info/scopes", _selectors6.default.info.sources], (scopes, sources) => (0, _assign2.default)({}, ...(0, _entries2.default)(scopes).map(([id, entry]) => ({
        [id]: (0, _extends3.default)({}, entry, {

          definition: _jsonPointer2.default.get(sources[entry.sourceId].ast, entry.pointer)
        })
      }))))
    },

    /**
     * data.views.decoder
     *
     * selector returns (ast node definition, data reference) => value
     */
    decoder: (0, _reselectTree.createLeaf)(["/views/scopes/inlined", "/current/state"], (scopes, state) => {
      return (definition, ref) => (0, _decode2.default)(definition, ref, state, scopes);
    })
  },

  /**
   * data.info
   */
  info: {

    /**
     * data.info.scopes
     */
    scopes: (0, _reselectTree.createLeaf)(["/state"], state => state.info.scopes.byId)
  },

  /**
   * data.proc
   */
  proc: {

    /**
     * data.proc.assignments
     */
    assignments: (0, _reselectTree.createLeaf)(["/state"], state => state.proc.assignments.byId)
  },

  /**
   * data.current
   */
  current: {
    /**
     *
     * data.current.scope
     */
    scope: {

      /**
       * data.current.scope.id
       */
      id: (0, _reselectTree.createLeaf)([_selectors2.default.current.node], node => node.id)
    },

    /**
     * data.current.state
     */
    state: createStateSelectors(_selectors4.default.current.state),

    /**
     * data.current.identifiers (namespace)
     */
    identifiers: {

      /**
       * data.current.identifiers (selector)
       *
       * returns identifers and corresponding definition node ID
       */
      _: (0, _reselectTree.createLeaf)(["/views/scopes/inlined", "/current/scope"], (scopes, scope) => {
        let cur = scope.id;
        let variables = {};

        do {
          variables = (0, _assign2.default)(variables, ...(scopes[cur].variables || []).filter(v => variables[v.name] == undefined).map(v => ({ [v.name]: v.id })));

          cur = scopes[cur].parentId;
        } while (cur != null);

        return variables;
      }),

      /**
       * data.current.identifiers.definitions
       *
       * current variable definitions
       */
      definitions: (0, _reselectTree.createLeaf)(["/views/scopes/inlined", "./_"], (scopes, identifiers) => (0, _assign2.default)({}, ...(0, _entries2.default)(identifiers).map(([identifier, id]) => {
        let { definition } = scopes[id];

        return { [identifier]: definition };
      }))),

      /**
       * data.current.identifiers.refs
       *
       * current variables' value refs
       */
      refs: (0, _reselectTree.createLeaf)(["/proc/assignments", "./_"], (assignments, identifiers) => (0, _assign2.default)({}, ...(0, _entries2.default)(identifiers).map(([identifier, id]) => {
        let { ref } = assignments[id] || {};
        if (!ref) {
          return undefined;
        };

        return {
          [identifier]: ref
        };
      }))),

      decoded: (0, _reselectTree.createLeaf)(["/views/decoder", "./definitions", "./refs"], (decode, definitions, refs) => (0, _assign2.default)({}, ...(0, _entries2.default)(refs).map(([identifier, ref]) => ({
        [identifier]: decode(definitions[identifier], ref)
      })))),

      native: (0, _reselectTree.createLeaf)(['./decoded'], decodeUtils.cleanBigNumbers)
    }
  },

  /**
   * data.next
   */
  next: {

    /**
     * data.next.state
     */
    state: createStateSelectors(_selectors4.default.next.state)
  }
});

exports.default = data;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _set = __webpack_require__(18);

var _set2 = _interopRequireDefault(_set);

exports.advance = advance;
exports.wait = wait;
exports.processTrace = processTrace;
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(6);

var _helpers = __webpack_require__(2);

var _actions = __webpack_require__(12);

var actions = _interopRequireWildcard(_actions);

var _selectors = __webpack_require__(13);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:trace:sagas");

function* waitForTrace() {
  let { steps } = yield (0, _effects.take)(actions.SAVE_STEPS);

  let addresses = [...new _set2.default(steps.filter(({ op }) => op == "CALL" || op == "DELEGATECALL").map(({ stack }) => "0x" + stack[stack.length - 2].substring(24)))];

  yield (0, _effects.put)(actions.receiveAddresses(addresses));
}

function* advance() {
  yield (0, _effects.put)(actions.next());

  yield (0, _effects.take)(actions.TOCK);
}

function* next() {
  let remaining = yield (0, _effects.select)(_selectors2.default.stepsRemaining);
  debug("remaining: %o", remaining);
  let steps = yield (0, _effects.select)(_selectors2.default.steps);
  debug("total steps: %o", steps.length);

  if (remaining > 0) {
    debug("putting TICK");
    // updates state for current step
    yield (0, _effects.put)(actions.tick());
    debug("put TICK");

    remaining--; // local update, just for convenience
  }

  if (remaining) {
    debug("putting TOCK");
    // updates step to next step in trace
    yield (0, _effects.put)(actions.tock());
    debug("put TOCK");
  } else {

    yield (0, _effects.put)(actions.endTrace());
  }
}

function* wait() {
  yield (0, _effects.take)(actions.END_OF_TRACE);
}

function* processTrace(trace) {
  yield (0, _effects.put)(actions.saveSteps(trace));

  let { addresses } = yield (0, _effects.take)(actions.RECEIVE_ADDRESSES);
  debug("received addresses");

  return addresses;
}

function* saga() {
  // wait for trace to be defined
  yield* waitForTrace();

  yield (0, _effects.takeEvery)(actions.NEXT, next);
}

exports.default = (0, _helpers.prefixName)("trace", saga);

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addSource = addSource;
exports.addSourceMap = addSourceMap;
exports.jump = jump;
const ADD_SOURCE = exports.ADD_SOURCE = "SOLIDITY_ADD_SOURCE";
function addSource(source, sourcePath, ast) {
  return {
    type: ADD_SOURCE,
    source, sourcePath, ast
  };
}

const ADD_SOURCEMAP = exports.ADD_SOURCEMAP = "SOLIDITY_ADD_SOURCEMAP";
function addSourceMap(binary, sourceMap) {
  return {
    type: ADD_SOURCEMAP,
    binary, sourceMap
  };
}

const JUMP = exports.JUMP = "JUMP";
function jump(jumpDirection) {
  return {
    type: JUMP,
    jumpDirection
  };
}

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addContext = addContext;
exports.addInstance = addInstance;
exports.call = call;
exports.create = create;
exports.returnCall = returnCall;
const ADD_CONTEXT = exports.ADD_CONTEXT = "EVM_ADD_CONTEXT";
function addContext(contractName, binary) {
  return {
    type: ADD_CONTEXT,
    contractName, binary
  };
}

const ADD_INSTANCE = exports.ADD_INSTANCE = "EVM_ADD_INSTANCE";
function addInstance(address, context, binary) {
  return {
    type: ADD_INSTANCE,
    address, context, binary
  };
}

const CALL = exports.CALL = "CALL";
function call(address) {
  return {
    type: CALL,
    address
  };
}

const CREATE = exports.CREATE = "CREATE";
function create(binary) {
  return {
    type: CREATE,
    binary
  };
}

const RETURN = exports.RETURN = "RETURN";
function returnCall() {
  return {
    type: RETURN
  };
}

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

var Debugger = __webpack_require__(30).default;

module.exports = Debugger;



/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _asyncToGenerator2 = __webpack_require__(19);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _truffleExpect = __webpack_require__(31);

var _truffleExpect2 = _interopRequireDefault(_truffleExpect);

var _session = __webpack_require__(32);

var _session2 = _interopRequireDefault(_session);

var _reselectTree = __webpack_require__(4);

var _selectors = __webpack_require__(25);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(11);

var _selectors4 = _interopRequireDefault(_selectors3);

var _selectors5 = __webpack_require__(13);

var _selectors6 = _interopRequireDefault(_selectors5);

var _selectors7 = __webpack_require__(7);

var _selectors8 = _interopRequireDefault(_selectors7);

var _selectors9 = __webpack_require__(8);

var _selectors10 = _interopRequireDefault(_selectors9);

var _selectors11 = __webpack_require__(63);

var _selectors12 = _interopRequireDefault(_selectors11);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger");

/**
 * @example
 * let session = Debugger
 *   .forTx(<txHash>, {
 *     contracts: [<contract obj>, ...],
 *     provider: <provider instance>
 *   })
 *   .connect();
 */
class Debugger {
  /**
   * @param {Session} session - debugger session
   * @private
   */
  constructor(session) {
    /**
     * @private
     */
    this._session = session;
  }

  /**
   * Instantiates a Debugger for a given transaction hash.
   *
   * @param {String} txHash - transaction hash with leading "0x"
   * @param {{contracts: Array<Contract>, files: Array<String>, provider: Web3Provider}} options -
   * @return {Debugger} instance
   */
  static forTx(txHash, options = {}) {
    var _this = this;

    return (0, _asyncToGenerator3.default)(function* () {
      _truffleExpect2.default.options(options, ["contracts", "provider"]);

      let session = new _session2.default(options.contracts, options.files, txHash, options.provider);

      try {
        yield session.ready();
      } catch (e) {
        throw e;
      }

      return new _this(session);
    })();
  }

  /**
   * Connects to the instantiated Debugger.
   *
   * @return {Session} session instance
   */
  connect() {
    return this._session;
  }

  /**
   * Exported selectors
   *
   * See individual selector docs for full listing
   *
   * @example
   * Debugger.selectors.ast.current.tree
   *
   * @example
   * Debugger.selectors.solidity.current.instruction
   *
   * @example
   * Debugger.selectors.trace.steps
   */
  static get selectors() {
    return (0, _reselectTree.createNestedSelector)({
      ast: _selectors4.default,
      data: _selectors2.default,
      trace: _selectors6.default,
      evm: _selectors8.default,
      solidity: _selectors10.default,
      session: _selectors12.default
    });
  }
}

exports.default = Debugger; /**
                             * @typedef {Object} Contract
                             * @property {string} contractName contract name
                             * @property {string} source solidity source code
                             * @property {string} sourcePath path to source file
                             * @property {string} binary 0x-prefixed hex string with create bytecode
                             * @property {string} sourceMap solidity source map for create bytecode
                             * @property {Object} ast Abstract Syntax Tree from Solidity
                             * @property {string} deployedBinary 0x-prefixed compiled binary (on chain)
                             * @property {string} deployedSourceMap solidity source map for on-chain bytecode
                             */

/***/ }),
/* 31 */
/***/ (function(module, exports) {

module.exports = require("truffle-expect");

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _values = __webpack_require__(33);

var _values2 = _interopRequireDefault(_values);

var _promise = __webpack_require__(20);

var _promise2 = _interopRequireDefault(_promise);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _selectors = __webpack_require__(13);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(7);

var _selectors4 = _interopRequireDefault(_selectors3);

var _selectors5 = __webpack_require__(11);

var _selectors6 = _interopRequireDefault(_selectors5);

var _selectors7 = __webpack_require__(8);

var _selectors8 = _interopRequireDefault(_selectors7);

var _store = __webpack_require__(39);

var _store2 = _interopRequireDefault(_store);

var _actions = __webpack_require__(21);

var controller = _interopRequireWildcard(_actions);

var _actions2 = __webpack_require__(17);

var actions = _interopRequireWildcard(_actions2);

var _sagas = __webpack_require__(44);

var _sagas2 = _interopRequireDefault(_sagas);

var _reducers = __webpack_require__(57);

var _reducers2 = _interopRequireDefault(_reducers);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:session");

/**
 * Debugger Session
 */
class Session {
  /**
   * @param {Array<Contract>} contracts - contract definitions
   * @param {Array<String>} files - array of filenames for sourceMap indexes
   * @param {string} txHash - transaction hash
   * @param {Web3Provider} provider - web3 provider
   * @private
   */
  constructor(contracts, files, txHash, provider) {
    /**
     * @private
     */
    this._store = (0, _store2.default)(_reducers2.default, _sagas2.default);

    let { contexts, sources } = Session.normalize(contracts, files);

    // record contracts
    this._store.dispatch(actions.recordContracts(contexts, sources));

    this._store.dispatch(actions.start(txHash, provider));
  }

  ready() {
    return new _promise2.default((accept, reject) => {
      this._store.subscribe(() => {
        if (this.state.session == "ACTIVE") {
          accept();
        } else if (typeof this.state.session == "object") {
          reject(this.state.session.error);
        }
      });
    });
  }

  /**
   * Split up artifacts into "contexts" and "sources", dividing artifact
   * data into appropriate buckets.
   *
   * Multiple contracts can be defined in the same source file, but have
   * different bytecodes.
   *
   * This iterates over the contracts and collects binaries separately
   * from sources, using the optional `files` argument to force
   * source ordering.
   * @private
   */
  static normalize(contracts, files = null) {
    let sourcesByPath = {};
    let contexts = [];
    let sources;

    for (let contract of contracts) {
      let {
        contractName,
        binary,
        sourceMap,
        deployedBinary,
        deployedSourceMap,
        sourcePath,
        source,
        ast
      } = contract;

      sourcesByPath[sourcePath] = { sourcePath, source, ast };

      if (binary && binary != "0x") {
        contexts.push({
          contractName,
          binary,
          sourceMap
        });
      }

      if (deployedBinary && deployedBinary != "0x") {
        contexts.push({
          contractName,
          binary: deployedBinary,
          sourceMap: deployedSourceMap
        });
      }
    }

    if (!files) {
      sources = (0, _values2.default)(sourcesByPath);
    } else {
      sources = files.map(file => sourcesByPath[file]);
    }

    return { contexts, sources };
  }

  get state() {
    return this._store.getState();
  }

  view(selector) {
    return selector(this.state);
  }

  get finished() {
    return this.state.session == "FINISHED";
  }

  get failed() {
    return this.finished && this.view(_selectors4.default.current.callstack).length;
  }

  dispatch(action) {
    if (this.finished) {
      debug("finished: intercepting action %o", action);

      return false;
    }

    this._store.dispatch(action);

    return true;
  }

  interrupt() {
    return this.dispatch(controller.interrupt());
  }

  advance() {
    return this.dispatch(controller.advance());
  }

  stepNext() {
    return this.dispatch(controller.stepNext());
  }

  stepOver() {
    return this.dispatch(controller.stepOver());
  }

  stepInto() {
    return this.dispatch(controller.stepInto());
  }

  stepOut() {
    return this.dispatch(controller.stepOut());
  }

  continueUntil(...breakpoints) {
    return this.dispatch(controller.continueUntil(...breakpoints));
  }
}
exports.default = Session;

/***/ }),
/* 33 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/object/values");

/***/ }),
/* 34 */
/***/ (function(module, exports) {

module.exports = require("truffle-solidity-utils");

/***/ }),
/* 35 */
/***/ (function(module, exports) {

module.exports = require("truffle-code-utils");

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = __webpack_require__(16);

var _keys2 = _interopRequireDefault(_keys);

exports.getRange = getRange;
exports.rangeNodes = rangeNodes;
exports.findRange = findRange;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _nodeIntervalTree = __webpack_require__(37);

var _nodeIntervalTree2 = _interopRequireDefault(_nodeIntervalTree);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:ast:map");

/**
 * @private
 */
function getRange(node) {
  // src: "<start>:<length>:<_>"
  // returns [start, end]
  let [start, length] = node.src.split(":").slice(0, 2).map(i => parseInt(i));

  return [start, start + length];
}

/**
 * @private
 */
function rangeNodes(node, pointer = "") {
  if (node instanceof Array) {
    return [].concat(...node.map((sub, i) => rangeNodes(sub, `${pointer}/${i}`)));
  } else if (node instanceof Object) {
    let results = [];

    if (node.src) {
      results.push({ pointer, range: getRange(node) });
    }

    return results.concat(...(0, _keys2.default)(node).map(key => rangeNodes(node[key], `${pointer}/${key}`)));
  } else {
    return [];
  }
}

/**
 * @private
 */
function findRange(node, sourceStart, sourceLength) {
  let ranges = rangeNodes(node);
  let tree = new _nodeIntervalTree2.default();

  ranges.forEach(({ range, pointer }) => {
    let [start, end] = range;

    tree.insert(start, end, { range, pointer });
  });

  let sourceEnd = sourceStart + sourceLength;

  let overlapping = tree.search(sourceStart, sourceEnd);

  // find nodes that fully contain requested range,
  // return longest pointer
  return overlapping.filter(({ range }) => sourceStart >= range[0] && sourceEnd <= range[1]).map(({ pointer }) => pointer).reduce((a, b) => a.length > b.length ? a : b, "");
}

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// An augmented AVL Tree where each node maintains a list of records and their search intervals.
// Record is composed of an interval and its underlying data, sent by a client. This allows the
// interval tree to have the same interval inserted multiple times, as long its data is different.
// Both insertion and deletion require O(log n) time. Searching requires O(k*logn) time, where `k`
// is the number of intervals in the output list.
Object.defineProperty(exports, "__esModule", { value: true });
var isSame = __webpack_require__(38);
function height(node) {
    if (node === undefined) {
        return -1;
    }
    else {
        return node.height;
    }
}
var Node = /** @class */ (function () {
    function Node(intervalTree, record) {
        this.intervalTree = intervalTree;
        this.records = [];
        this.height = 0;
        this.key = record.low;
        this.max = record.high;
        // Save the array of all records with the same key for this node
        this.records.push(record);
    }
    // Gets the highest record.high value for this node
    Node.prototype.getNodeHigh = function () {
        var high = this.records[0].high;
        for (var i = 1; i < this.records.length; i++) {
            if (this.records[i].high > high) {
                high = this.records[i].high;
            }
        }
        return high;
    };
    // Updates height value of the node. Called during insertion, rebalance, removal
    Node.prototype.updateHeight = function () {
        this.height = Math.max(height(this.left), height(this.right)) + 1;
    };
    // Updates the max value of all the parents after inserting into already existing node, as well as
    // removing the node completely or removing the record of an already existing node. Starts with
    // the parent of an affected node and bubbles up to root
    Node.prototype.updateMaxOfParents = function () {
        if (this === undefined) {
            return;
        }
        var thisHigh = this.getNodeHigh();
        if (this.left !== undefined && this.right !== undefined) {
            this.max = Math.max(Math.max(this.left.max, this.right.max), thisHigh);
        }
        else if (this.left !== undefined && this.right === undefined) {
            this.max = Math.max(this.left.max, thisHigh);
        }
        else if (this.left === undefined && this.right !== undefined) {
            this.max = Math.max(this.right.max, thisHigh);
        }
        else {
            this.max = thisHigh;
        }
        if (this.parent) {
            this.parent.updateMaxOfParents();
        }
    };
    /*
    Left-Left case:
  
           z                                      y
          / \                                   /   \
         y   T4      Right Rotate (z)          x     z
        / \          - - - - - - - - ->       / \   / \
       x   T3                                T1 T2 T3 T4
      / \
    T1   T2
  
    Left-Right case:
  
         z                               z                           x
        / \                             / \                        /   \
       y   T4  Left Rotate (y)         x  T4  Right Rotate(z)     y     z
      / \      - - - - - - - - ->     / \      - - - - - - - ->  / \   / \
    T1   x                           y  T3                      T1 T2 T3 T4
        / \                         / \
      T2   T3                      T1 T2
    */
    // Handles Left-Left case and Left-Right case after rebalancing AVL tree
    Node.prototype._updateMaxAfterRightRotate = function () {
        var parent = this.parent;
        var left = parent.left;
        // Update max of left sibling (x in first case, y in second)
        var thisParentLeftHigh = left.getNodeHigh();
        if (left.left === undefined && left.right !== undefined) {
            left.max = Math.max(thisParentLeftHigh, left.right.max);
        }
        else if (left.left !== undefined && left.right === undefined) {
            left.max = Math.max(thisParentLeftHigh, left.left.max);
        }
        else if (left.left === undefined && left.right === undefined) {
            left.max = thisParentLeftHigh;
        }
        else {
            left.max = Math.max(Math.max(left.left.max, left.right.max), thisParentLeftHigh);
        }
        // Update max of itself (z)
        var thisHigh = this.getNodeHigh();
        if (this.left === undefined && this.right !== undefined) {
            this.max = Math.max(thisHigh, this.right.max);
        }
        else if (this.left !== undefined && this.right === undefined) {
            this.max = Math.max(thisHigh, this.left.max);
        }
        else if (this.left === undefined && this.right === undefined) {
            this.max = thisHigh;
        }
        else {
            this.max = Math.max(Math.max(this.left.max, this.right.max), thisHigh);
        }
        // Update max of parent (y in first case, x in second)
        parent.max = Math.max(Math.max(parent.left.max, parent.right.max), parent.getNodeHigh());
    };
    /*
    Right-Right case:
  
      z                               y
     / \                            /   \
    T1  y     Left Rotate(z)       z     x
       / \   - - - - - - - ->     / \   / \
      T2  x                      T1 T2 T3 T4
         / \
        T3 T4
  
    Right-Left case:
  
       z                            z                            x
      / \                          / \                         /   \
     T1  y   Right Rotate (y)     T1  x      Left Rotate(z)   z     y
        / \  - - - - - - - - ->      / \   - - - - - - - ->  / \   / \
       x  T4                        T2  y                   T1 T2 T3 T4
      / \                              / \
    T2   T3                           T3 T4
    */
    // Handles Right-Right case and Right-Left case in rebalancing AVL tree
    Node.prototype._updateMaxAfterLeftRotate = function () {
        var parent = this.parent;
        var right = parent.right;
        // Update max of right sibling (x in first case, y in second)
        var thisParentRightHigh = right.getNodeHigh();
        if (right.left === undefined && right.right !== undefined) {
            right.max = Math.max(thisParentRightHigh, right.right.max);
        }
        else if (right.left !== undefined && right.right === undefined) {
            right.max = Math.max(thisParentRightHigh, right.left.max);
        }
        else if (right.left === undefined && right.right === undefined) {
            right.max = thisParentRightHigh;
        }
        else {
            right.max = Math.max(Math.max(right.left.max, right.right.max), thisParentRightHigh);
        }
        // Update max of itself (z)
        var thisHigh = this.getNodeHigh();
        if (this.left === undefined && this.right !== undefined) {
            this.max = Math.max(thisHigh, this.right.max);
        }
        else if (this.left !== undefined && this.right === undefined) {
            this.max = Math.max(thisHigh, this.left.max);
        }
        else if (this.left === undefined && this.right === undefined) {
            this.max = thisHigh;
        }
        else {
            this.max = Math.max(Math.max(this.left.max, this.right.max), thisHigh);
        }
        // Update max of parent (y in first case, x in second)
        parent.max = Math.max(Math.max(parent.left.max, right.max), parent.getNodeHigh());
    };
    Node.prototype._leftRotate = function () {
        var rightChild = this.right;
        rightChild.parent = this.parent;
        if (rightChild.parent === undefined) {
            this.intervalTree.root = rightChild;
        }
        else {
            if (rightChild.parent.left === this) {
                rightChild.parent.left = rightChild;
            }
            else if (rightChild.parent.right === this) {
                rightChild.parent.right = rightChild;
            }
        }
        this.right = rightChild.left;
        if (this.right !== undefined) {
            this.right.parent = this;
        }
        rightChild.left = this;
        this.parent = rightChild;
        this.updateHeight();
        rightChild.updateHeight();
    };
    Node.prototype._rightRotate = function () {
        var leftChild = this.left;
        leftChild.parent = this.parent;
        if (leftChild.parent === undefined) {
            this.intervalTree.root = leftChild;
        }
        else {
            if (leftChild.parent.left === this) {
                leftChild.parent.left = leftChild;
            }
            else if (leftChild.parent.right === this) {
                leftChild.parent.right = leftChild;
            }
        }
        this.left = leftChild.right;
        if (this.left !== undefined) {
            this.left.parent = this;
        }
        leftChild.right = this;
        this.parent = leftChild;
        this.updateHeight();
        leftChild.updateHeight();
    };
    // Rebalances the tree if the height value between two nodes of the same parent is greater than
    // two. There are 4 cases that can happen which are outlined in the graphics above
    Node.prototype._rebalance = function () {
        if (height(this.left) >= 2 + height(this.right)) {
            var left = this.left;
            if (height(left.left) >= height(left.right)) {
                // Left-Left case
                this._rightRotate();
                this._updateMaxAfterRightRotate();
            }
            else {
                // Left-Right case
                left._leftRotate();
                this._rightRotate();
                this._updateMaxAfterRightRotate();
            }
        }
        else if (height(this.right) >= 2 + height(this.left)) {
            var right = this.right;
            if (height(right.right) >= height(right.left)) {
                // Right-Right case
                this._leftRotate();
                this._updateMaxAfterLeftRotate();
            }
            else {
                // Right-Left case
                right._rightRotate();
                this._leftRotate();
                this._updateMaxAfterLeftRotate();
            }
        }
    };
    Node.prototype.insert = function (record) {
        if (record.low < this.key) {
            // Insert into left subtree
            if (this.left === undefined) {
                this.left = new Node(this.intervalTree, record);
                this.left.parent = this;
            }
            else {
                this.left.insert(record);
            }
        }
        else {
            // Insert into right subtree
            if (this.right === undefined) {
                this.right = new Node(this.intervalTree, record);
                this.right.parent = this;
            }
            else {
                this.right.insert(record);
            }
        }
        // Update the max value of this ancestor if needed
        if (this.max < record.high) {
            this.max = record.high;
        }
        // Update height of each node
        this.updateHeight();
        // Rebalance the tree to ensure all operations are executed in O(logn) time. This is especially
        // important in searching, as the tree has a high chance of degenerating without the rebalancing
        this._rebalance();
    };
    Node.prototype._getOverlappingRecords = function (currentNode, low, high) {
        if (currentNode.key <= high && low <= currentNode.getNodeHigh()) {
            // Nodes are overlapping, check if individual records in the node are overlapping
            var tempResults = [];
            for (var i = 0; i < currentNode.records.length; i++) {
                if (currentNode.records[i].high >= low) {
                    tempResults.push(currentNode.records[i]);
                }
            }
            return tempResults;
        }
        return [];
    };
    Node.prototype.search = function (low, high) {
        // Don't search nodes that don't exist
        if (this === undefined) {
            return [];
        }
        var leftSearch = [];
        var ownSearch = [];
        var rightSearch = [];
        // If interval is to the right of the rightmost point of any interval in this node and all its
        // children, there won't be any matches
        if (low > this.max) {
            return [];
        }
        // Search left children
        if (this.left !== undefined && this.left.max >= low) {
            leftSearch = this.left.search(low, high);
        }
        // Check this node
        ownSearch = this._getOverlappingRecords(this, low, high);
        // If interval is to the left of the start of this interval, then it can't be in any child to
        // the right
        if (high < this.key) {
            return leftSearch.concat(ownSearch);
        }
        // Otherwise, search right children
        if (this.right !== undefined) {
            rightSearch = this.right.search(low, high);
        }
        // Return accumulated results, if any
        return leftSearch.concat(ownSearch, rightSearch);
    };
    // Searches for a node by a `key` value
    Node.prototype.searchExisting = function (low) {
        if (this === undefined) {
            return undefined;
        }
        if (this.key === low) {
            return this;
        }
        else if (low < this.key) {
            if (this.left !== undefined) {
                return this.left.searchExisting(low);
            }
        }
        else {
            if (this.right !== undefined) {
                return this.right.searchExisting(low);
            }
        }
        return undefined;
    };
    // Returns the smallest node of the subtree
    Node.prototype._minValue = function () {
        if (this.left === undefined) {
            return this;
        }
        else {
            return this.left._minValue();
        }
    };
    Node.prototype.remove = function (node) {
        var parent = this.parent;
        if (node.key < this.key) {
            // Node to be removed is on the left side
            if (this.left !== undefined) {
                return this.left.remove(node);
            }
            else {
                return undefined;
            }
        }
        else if (node.key > this.key) {
            // Node to be removed is on the right side
            if (this.right !== undefined) {
                return this.right.remove(node);
            }
            else {
                return undefined;
            }
        }
        else {
            if (this.left !== undefined && this.right !== undefined) {
                // Node has two children
                var minValue = this.right._minValue();
                this.key = minValue.key;
                this.records = minValue.records;
                return this.right.remove(this);
            }
            else if (parent.left === this) {
                // One child or no child case on left side
                if (this.right !== undefined) {
                    parent.left = this.right;
                    this.right.parent = parent;
                }
                else {
                    parent.left = this.left;
                    if (this.left !== undefined) {
                        this.left.parent = parent;
                    }
                }
                parent.updateMaxOfParents();
                parent.updateHeight();
                parent._rebalance();
                return this;
            }
            else if (parent.right === this) {
                // One child or no child case on right side
                if (this.right !== undefined) {
                    parent.right = this.right;
                    this.right.parent = parent;
                }
                else {
                    parent.right = this.left;
                    if (this.left !== undefined) {
                        this.left.parent = parent;
                    }
                }
                parent.updateMaxOfParents();
                parent.updateHeight();
                parent._rebalance();
                return this;
            }
        }
    };
    return Node;
}());
exports.Node = Node;
var IntervalTree = /** @class */ (function () {
    function IntervalTree() {
        this.count = 0;
    }
    IntervalTree.prototype.insert = function (record) {
        if (record.low > record.high) {
            throw new Error('`low` value must be lower or equal to `high` value');
        }
        if (this.root === undefined) {
            // Base case: Tree is empty, new node becomes root
            this.root = new Node(this, record);
            this.count++;
            return true;
        }
        else {
            // Otherwise, check if node already exists with the same key
            var node = this.root.searchExisting(record.low);
            if (node !== undefined) {
                // Check the records in this node if there already is the one with same low, high, data
                for (var i = 0; i < node.records.length; i++) {
                    if (isSame(node.records[i], record)) {
                        // This record is same as the one we're trying to insert; return false to indicate
                        // nothing has been inserted
                        return false;
                    }
                }
                // Add the record to the node
                node.records.push(record);
                // Update max of the node and its parents if necessary
                if (record.high > node.max) {
                    node.max = record.high;
                    if (node.parent) {
                        node.parent.updateMaxOfParents();
                    }
                }
                this.count++;
                return true;
            }
            else {
                // Node with this key doesn't already exist. Call insert function on root's node
                this.root.insert(record);
                this.count++;
                return true;
            }
        }
    };
    IntervalTree.prototype.search = function (low, high) {
        if (this.root === undefined) {
            // Tree is empty; return empty array
            return [];
        }
        else {
            return this.root.search(low, high);
        }
    };
    IntervalTree.prototype.remove = function (record) {
        if (this.root === undefined) {
            // Tree is empty; nothing to remove
            return false;
        }
        else {
            var node = this.root.searchExisting(record.low);
            if (node === undefined) {
                return false;
            }
            else if (node.records.length > 1) {
                var removedRecord = void 0;
                // Node with this key has 2 or more records. Find the one we need and remove it
                for (var i = 0; i < node.records.length; i++) {
                    if (isSame(node.records[i], record)) {
                        removedRecord = node.records[i];
                        node.records.splice(i, 1);
                        break;
                    }
                }
                if (removedRecord) {
                    removedRecord = undefined;
                    // Update max of that node and its parents if necessary
                    if (record.high === node.max) {
                        var nodeHigh = node.getNodeHigh();
                        if (node.left !== undefined && node.right !== undefined) {
                            node.max = Math.max(Math.max(node.left.max, node.right.max), nodeHigh);
                        }
                        else if (node.left !== undefined && node.right === undefined) {
                            node.max = Math.max(node.left.max, nodeHigh);
                        }
                        else if (node.left === undefined && node.right !== undefined) {
                            node.max = Math.max(node.right.max, nodeHigh);
                        }
                        else {
                            node.max = nodeHigh;
                        }
                        if (node.parent) {
                            node.parent.updateMaxOfParents();
                        }
                    }
                    this.count--;
                    return true;
                }
                else {
                    return false;
                }
            }
            else if (node.records.length === 1) {
                // Node with this key has only 1 record. Check if the remaining record in this node is
                // actually the one we want to remove
                if (isSame(node.records[0], record)) {
                    // The remaining record is the one we want to remove. Remove the whole node from the tree
                    if (this.root.key === node.key) {
                        // We're removing the root element. Create a dummy node that will temporarily take
                        // root's parent role
                        var rootParent = new Node(this, { low: record.low, high: record.low });
                        rootParent.left = this.root;
                        this.root.parent = rootParent;
                        var removedNode = this.root.remove(node);
                        this.root = rootParent.left;
                        if (this.root !== undefined) {
                            this.root.parent = undefined;
                        }
                        if (removedNode) {
                            removedNode = undefined;
                            this.count--;
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                    else {
                        var removedNode = this.root.remove(node);
                        if (removedNode) {
                            removedNode = undefined;
                            this.count--;
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                }
                else {
                    // The remaining record is not the one we want to remove
                    return false;
                }
            }
            else {
                // No records at all in this node?! Shouldn't happen
                return false;
            }
        }
    };
    IntervalTree.prototype.inOrder = function () {
        return new InOrder(this.root);
    };
    IntervalTree.prototype.preOrder = function () {
        return new PreOrder(this.root);
    };
    return IntervalTree;
}());
exports.IntervalTree = IntervalTree;
var DataIntervalTree = /** @class */ (function () {
    function DataIntervalTree() {
        this.tree = new IntervalTree();
    }
    DataIntervalTree.prototype.insert = function (low, high, data) {
        return this.tree.insert({ low: low, high: high, data: data });
    };
    DataIntervalTree.prototype.remove = function (low, high, data) {
        return this.tree.remove({ low: low, high: high, data: data });
    };
    DataIntervalTree.prototype.search = function (low, high) {
        return this.tree.search(low, high).map(function (v) { return v.data; });
    };
    DataIntervalTree.prototype.inOrder = function () {
        return this.tree.inOrder();
    };
    DataIntervalTree.prototype.preOrder = function () {
        return this.tree.preOrder();
    };
    Object.defineProperty(DataIntervalTree.prototype, "count", {
        get: function () {
            return this.tree.count;
        },
        enumerable: true,
        configurable: true
    });
    return DataIntervalTree;
}());
exports.default = DataIntervalTree;
var InOrder = /** @class */ (function () {
    function InOrder(startNode) {
        this.stack = [];
        if (startNode !== undefined) {
            this.push(startNode);
        }
    }
    InOrder.prototype.next = function () {
        // Will only happen if stack is empty and pop is called
        if (this.currentNode === undefined) {
            return {
                done: true,
                value: undefined,
            };
        }
        // Process this node
        if (this.i < this.currentNode.records.length) {
            return {
                done: false,
                value: this.currentNode.records[this.i++],
            };
        }
        if (this.currentNode.right !== undefined) {
            this.push(this.currentNode.right);
        }
        else {
            // Might pop the last and set this.currentNode = undefined
            this.pop();
        }
        return this.next();
    };
    InOrder.prototype.push = function (node) {
        this.currentNode = node;
        this.i = 0;
        while (this.currentNode.left !== undefined) {
            this.stack.push(this.currentNode);
            this.currentNode = this.currentNode.left;
        }
    };
    InOrder.prototype.pop = function () {
        this.currentNode = this.stack.pop();
        this.i = 0;
    };
    return InOrder;
}());
exports.InOrder = InOrder;
if (typeof Symbol === 'function') {
    InOrder.prototype[Symbol.iterator] = function () { return this; };
}
var PreOrder = /** @class */ (function () {
    function PreOrder(startNode) {
        this.stack = [];
        this.i = 0;
        this.currentNode = startNode;
    }
    PreOrder.prototype.next = function () {
        // Will only happen if stack is empty and pop is called,
        // which only happens if there is no right node (i.e we are done)
        if (this.currentNode === undefined) {
            return {
                done: true,
                value: undefined,
            };
        }
        // Process this node
        if (this.i < this.currentNode.records.length) {
            return {
                done: false,
                value: this.currentNode.records[this.i++],
            };
        }
        if (this.currentNode.right !== undefined) {
            this.push(this.currentNode.right);
        }
        if (this.currentNode.left !== undefined) {
            this.push(this.currentNode.left);
        }
        this.pop();
        return this.next();
    };
    PreOrder.prototype.push = function (node) {
        this.stack.push(node);
    };
    PreOrder.prototype.pop = function () {
        this.currentNode = this.stack.pop();
        this.i = 0;
    };
    return PreOrder;
}());
exports.PreOrder = PreOrder;
if (typeof Symbol === 'function') {
    PreOrder.prototype[Symbol.iterator] = function () { return this; };
}
//# sourceMappingURL=index.js.map

/***/ }),
/* 38 */
/***/ (function(module, exports) {

//

module.exports = function shallowEqual(objA, objB, compare, compareContext) {
  var ret = compare ? compare.call(compareContext, objA, objB) : void 0;

  if (ret !== void 0) {
    return !!ret;
  }

  if (objA === objB) {
    return true;
  }

  if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);

  // Test for A's keys different from B.
  for (var idx = 0; idx < keysA.length; idx++) {
    var key = keysA[idx];

    if (!bHasOwnProperty(key)) {
      return false;
    }

    var valueA = objA[key];
    var valueB = objB[key];

    ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;

    if (ret === false || (ret === void 0 && valueA !== valueB)) {
      return false;
    }
  }

  return true;
};


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (true) {
  module.exports = __webpack_require__(40);
} else if (process.env.NODE_ENV == "test") {
  module.exports = require("./test");
} else {
  module.exports = require("./development");
}

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _common = __webpack_require__(41);

var _common2 = _interopRequireDefault(_common);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _common2.default;

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _entries = __webpack_require__(1);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(3);

var _assign2 = _interopRequireDefault(_assign);

exports.abbreviateValues = abbreviateValues;
exports.default = configureStore;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _redux = __webpack_require__(9);

var _reduxSaga = __webpack_require__(42);

var _reduxSaga2 = _interopRequireDefault(_reduxSaga);

var _reduxCliLogger = __webpack_require__(43);

var _reduxCliLogger2 = _interopRequireDefault(_reduxCliLogger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:store:common");
const reduxDebug = (0, _debug2.default)("debugger:redux");

function abbreviateValues(value, options = {}, depth = 0) {
  options.stringLimit = options.stringLimit || 66;
  options.arrayLimit = options.arrayLimit || 8;
  options.recurseLimit = options.recurseLimit || 4;

  if (depth > options.recurseLimit) {
    return "...";
  }

  const recurse = child => abbreviateValues(child, options, depth + 1);

  if (value instanceof Array) {
    if (value.length > options.arrayLimit) {
      value = [...value.slice(0, options.arrayLimit / 2), "...", ...value.slice(value.length - options.arrayLimit / 2 + 1)];
    }

    return value.map(recurse);
  } else if (value instanceof Object) {
    return (0, _assign2.default)({}, ...(0, _entries2.default)(value).map(([k, v]) => ({ [recurse(k)]: recurse(v) })));
  } else if (typeof value === "string" && value.length > options.stringLimit) {
    let inner = "...";
    let extractAmount = (options.stringLimit - inner.length) / 2;
    let leading = value.slice(0, Math.ceil(extractAmount));
    let trailing = value.slice(value.length - Math.floor(extractAmount));
    return `${leading}${inner}${trailing}`;
  } else {
    return value;
  }
}

function configureStore(reducer, saga, initialState, composeEnhancers) {
  const sagaMiddleware = (0, _reduxSaga2.default)();

  if (!composeEnhancers) {
    composeEnhancers = _redux.compose;
  }

  const loggerMiddleware = (0, _reduxCliLogger2.default)({
    log: reduxDebug,
    stateTransformer: state => abbreviateValues(state, {
      arrayLimit: 4,
      recurseLimit: 3
    }),
    actionTransformer: abbreviateValues
  });

  let store = (0, _redux.createStore)(reducer, initialState, composeEnhancers((0, _redux.applyMiddleware)(sagaMiddleware, loggerMiddleware)));

  sagaMiddleware.run(saga);

  return store;
}

/***/ }),
/* 42 */
/***/ (function(module, exports) {

module.exports = require("redux-saga");

/***/ }),
/* 43 */
/***/ (function(module, exports) {

module.exports = require("redux-cli-logger");

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(6);

var _helpers = __webpack_require__(2);

var _sagas = __webpack_require__(45);

var ast = _interopRequireWildcard(_sagas);

var _sagas2 = __webpack_require__(50);

var controller = _interopRequireWildcard(_sagas2);

var _sagas3 = __webpack_require__(52);

var solidity = _interopRequireWildcard(_sagas3);

var _sagas4 = __webpack_require__(53);

var evm = _interopRequireWildcard(_sagas4);

var _sagas5 = __webpack_require__(26);

var trace = _interopRequireWildcard(_sagas5);

var _sagas6 = __webpack_require__(23);

var data = _interopRequireWildcard(_sagas6);

var _sagas7 = __webpack_require__(54);

var web3 = _interopRequireWildcard(_sagas7);

var _actions = __webpack_require__(17);

var actions = _interopRequireWildcard(_actions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:session:sagas");

function* saga() {
  debug("starting listeners");
  let listeners = yield* forkListeners();

  // receiving & saving contracts into state
  debug("waiting for contract information");
  let { contexts, sources } = yield (0, _effects.take)(actions.RECORD_CONTRACTS);

  debug("recording contract binaries");
  yield* recordContexts(...contexts);

  debug("recording contract sources");
  yield* recordSources(...sources);

  debug("waiting for start");
  // wait for start signal
  let { txHash, provider } = yield (0, _effects.take)(actions.START);
  debug("starting");

  // process transaction
  debug("fetching transaction info");
  let err = yield* fetchTx(txHash, provider);
  if (err) {
    debug("error %o", err);
    yield* error(err);
  } else {
    debug("visiting ASTs");
    // visit asts
    yield* ast.visitAll();

    debug("readying");
    // signal that stepping can begin
    yield* ready();

    debug("waiting for trace EOT");
    // wait until trace hits EOT
    yield* trace.wait();

    debug("finishing");
    // finish
    yield (0, _effects.put)(actions.finish());
  }

  debug("stopping listeners");
  yield (0, _effects.all)(listeners.map(task => (0, _effects.cancel)(task)));
}

exports.default = (0, _helpers.prefixName)("session", saga);


function* forkListeners() {
  return yield (0, _effects.all)([ast, controller, data, evm, solidity, trace, web3].map(app => (0, _effects.fork)(app.saga)));
}

function* fetchTx(txHash, provider) {
  let result = yield* web3.inspectTransaction(txHash, provider);

  if (result.error) {
    return result.error;
  }

  yield* evm.begin(result);

  let addresses = yield* trace.processTrace(result.trace);
  if (result.address && addresses.indexOf(result.address) == -1) {
    addresses.push(result.address);
  }

  let binaries = yield* web3.obtainBinaries(addresses);

  yield (0, _effects.all)(addresses.map((address, i) => (0, _effects.call)(recordInstance, address, binaries[i])));
}

function* recordContexts(...contexts) {
  for (let _ref of contexts) {
    let { contractName, binary, sourceMap } = _ref;

    yield* evm.addContext(contractName, binary);

    if (sourceMap) {
      yield* solidity.addSourceMap(binary, sourceMap);
    }
  }
}

function* recordSources(...sources) {
  for (let _ref2 of sources) {
    let { sourcePath, source, ast } = _ref2;

    yield* solidity.addSource(source, sourcePath, ast);
  }
}

function* recordInstance(address, binary) {
  yield* evm.addInstance(address, binary);
}

function* ready() {
  yield (0, _effects.put)(actions.ready());
}

function* error(err) {
  yield (0, _effects.put)(actions.error(err));
}

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _entries = __webpack_require__(1);

var _entries2 = _interopRequireDefault(_entries);

exports.visitAll = visitAll;
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(6);

var _helpers = __webpack_require__(2);

var _sagas = __webpack_require__(23);

var data = _interopRequireWildcard(_sagas);

var _actions = __webpack_require__(49);

var actions = _interopRequireWildcard(_actions);

var _selectors = __webpack_require__(11);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:ast:sagas");

function* walk(sourceId, node, pointer = "", parentId = null) {
  debug("walking %o %o", pointer, node);

  yield* handleEnter(sourceId, node, pointer, parentId);

  if (node instanceof Array) {
    for (let [i, child] of node.entries()) {
      yield (0, _effects.call)(walk, sourceId, child, `${pointer}/${i}`, parentId);
    }
  } else if (node instanceof Object) {
    for (let [key, child] of (0, _entries2.default)(node)) {
      yield (0, _effects.call)(walk, sourceId, child, `${pointer}/${key}`, node.id);
    }
  }

  yield* handleExit(sourceId, node, pointer);
}

function* handleEnter(sourceId, node, pointer, parentId) {
  if (!(node instanceof Object)) {
    return;
  }

  debug("entering %s", pointer);

  if (node.id !== undefined) {
    debug("%s recording scope %s", pointer, node.id);
    yield* data.scope(node.id, pointer, parentId, sourceId);
  }

  switch (node.nodeType) {
    case "VariableDeclaration":
      debug("%s recording variable %o", pointer, node);
      yield* data.declare(node);
      break;
  }
}

function* handleExit(sourceId, node, pointer) {
  debug("exiting %s", pointer);

  // no-op right now
}

function* walkSaga({ sourceId, ast }) {
  yield walk(sourceId, ast);
}

function* visitAll(idx) {
  let sources = yield (0, _effects.select)(_selectors2.default.views.sources);

  let tasks = yield (0, _effects.all)((0, _entries2.default)(sources).filter(([id, { ast }]) => !!ast).map(([id, { ast }]) => (0, _effects.fork)(() => (0, _effects.put)(actions.visit(id, ast)))));

  if (tasks.length > 0) {
    yield (0, _effects.join)(...tasks);
  }

  yield (0, _effects.put)(actions.doneVisiting());
}

function* saga() {
  yield (0, _effects.race)({
    visitor: (0, _effects.takeEvery)(actions.VISIT, walkSaga),
    done: (0, _effects.take)(actions.DONE_VISITING)
  });
}

exports.default = (0, _helpers.prefixName)("ast", saga);

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _entries = __webpack_require__(1);

var _entries2 = _interopRequireDefault(_entries);

var _extends2 = __webpack_require__(5);

var _extends3 = _interopRequireDefault(_extends2);

var _assign = __webpack_require__(3);

var _assign2 = _interopRequireDefault(_assign);

exports.read = read;
exports.decodeValue = decodeValue;
exports.decodeMemoryReference = decodeMemoryReference;
exports.decodeStorageReference = decodeStorageReference;
exports.default = decode;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _bignumber = __webpack_require__(14);

var _memory = __webpack_require__(47);

var memory = _interopRequireWildcard(_memory);

var _storage = __webpack_require__(48);

var storage = _interopRequireWildcard(_storage);

var _utils = __webpack_require__(10);

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:data:decode");

function read(pointer, state) {
  if (pointer.stack != undefined && state.stack && pointer.stack < state.stack.length) {
    return state.stack[pointer.stack];
  } else if (pointer.storage != undefined && state.storage) {
    return storage.readRange(state.storage, pointer.storage);
  } else if (pointer.memory != undefined && state.memory) {
    return memory.readBytes(state.memory, pointer.memory.start, pointer.memory.length);
  } else if (pointer.literal) {
    return pointer.literal;
  }
}

function decodeValue(definition, pointer, state, ...args) {
  let bytes = read(pointer, state);
  if (!bytes) {
    return undefined;
  }

  switch (utils.typeClass(definition)) {
    case "bool":
      return !utils.toBigNumber(bytes).isZero();

    case "uint":
      return utils.toBigNumber(bytes);

    case "int":
      return utils.toSignedBigNumber(bytes);

    case "address":
      return utils.toHexString(bytes, true);

    case "bytes":
      debug("typeIdentifier %s %o", utils.typeIdentifier(definition), bytes);
      let length = utils.specifiedSize(definition);
      return utils.toHexString(bytes, length);

    case "string":
      debug("typeIdentifier %s %o", utils.typeIdentifier(definition), bytes);
      return String.fromCharCode.apply(null, bytes);

    default:
      debug("Unknown value type: %s", utils.typeIdentifier(definition));
      return null;
  }
}

function decodeMemoryReference(definition, pointer, state, ...args) {
  let rawValue = utils.toBigNumber(read(pointer, state)).toNumber();

  var bytes;
  switch (utils.typeClass(definition)) {

    case "bytes":
    case "string":
      bytes = read({
        memory: { start: rawValue, length: _utils.WORD_SIZE }
      }, state); // bytes contain length

      return decodeValue(definition, {
        memory: { start: rawValue + _utils.WORD_SIZE, length: bytes }
      }, state, ...args);

    case "array":
      bytes = utils.toBigNumber(read({
        memory: { start: rawValue, length: _utils.WORD_SIZE }
      }, state)).toNumber(); // bytes contain array length

      bytes = read({ memory: {
          start: rawValue + _utils.WORD_SIZE, length: bytes * _utils.WORD_SIZE
        } }, state); // now bytes contain items

      return memory.chunk(bytes, _utils.WORD_SIZE).map(chunk => decode(utils.baseDefinition(definition), {
        literal: chunk
      }, state, ...args));

    case "struct":
      let [refs] = args;
      let structDefinition = refs[definition.typeName.referencedDeclaration];
      let structVariables = structDefinition.variables || [];

      return (0, _assign2.default)({}, ...structVariables.map(({ name, id }, i) => {
        let memberDefinition = refs[id].definition;
        let memberPointer = {
          memory: { start: rawValue + i * _utils.WORD_SIZE, length: _utils.WORD_SIZE }
        };
        // let memberPointer = memory.read(state.memory, pointer + i * WORD_SIZE);

        // HACK
        memberDefinition = (0, _extends3.default)({}, memberDefinition, {

          typeDescriptions: (0, _extends3.default)({}, memberDefinition.typeDescriptions, {

            typeIdentifier: memberDefinition.typeDescriptions.typeIdentifier.replace(/_storage_/g, "_memory_")
          })
        });

        return {
          [name]: decode(memberDefinition, memberPointer, state, ...args)
        };
      }));

    default:
      debug("Unknown memory reference type: %s", utils.typeIdentifier(definition));
      return null;

  }
}

function decodeStorageReference(definition, pointer, state, ...args) {
  var data;
  var bytes;
  var length;
  var slot;

  switch (utils.typeClass(definition)) {
    case "array":
      debug("storage array! %o", pointer);
      data = read(pointer, state);
      if (!data) {
        return null;
      }

      length = utils.toBigNumber(data).toNumber();
      debug("length %o", length);

      const baseSize = utils.storageSize(utils.baseDefinition(definition));
      const perWord = Math.floor(_utils.WORD_SIZE / baseSize);
      debug("baseSize %o", baseSize);
      debug("perWord %d", perWord);

      const offset = i => {
        if (perWord == 1) {
          return i;
        }

        return Math.floor(i * baseSize / _utils.WORD_SIZE);
      };

      const index = i => {
        if (perWord == 1) {
          return _utils.WORD_SIZE - baseSize;
        }

        const position = perWord - i % perWord - 1;
        return position * baseSize;
      };

      debug("pointer: %o", pointer);
      return [...Array(length).keys()].map(i => {
        let childFrom = pointer.storage.from.offset != undefined ? {
          slot: ["0x" + utils.toBigNumber(utils.keccak256(...pointer.storage.from.slot)).plus(pointer.storage.from.offset).toString(16)],
          offset: offset(i),
          index: index(i)
        } : {
          slot: [pointer.storage.from.slot],
          offset: offset(i),
          index: index(i)
        };
        return childFrom;
      }).map((childFrom, idx) => {
        debug("childFrom %d, %o", idx, childFrom);
        return decode(utils.baseDefinition(definition), { storage: {
            from: childFrom,
            length: baseSize
          } }, state, ...args);
      });

    case "bytes":
    case "string":
      data = read(pointer, state);
      if (!data) {
        return null;
      }

      if (data[_utils.WORD_SIZE - 1] % 2 == 0) {
        // string lives in word, length is last byte / 2
        length = data[_utils.WORD_SIZE - 1] / 2;
        debug("in-word; length %o", length);
        if (length == 0) {
          return "";
        }

        return decodeValue(definition, { storage: {
            from: { slot: pointer.storage.from.slot, index: 0 },
            to: { slot: pointer.storage.from.slot, index: length - 1 }
          } }, state, ...args);
      } else {
        length = utils.toBigNumber(data).minus(1).div(2).toNumber();
        debug("new-word, length %o", length);

        return decodeValue(definition, { storage: {
            from: { slot: [pointer.storage.from.slot], index: 0 },
            length
          } }, state, ...args);
      }

    case "struct":
      let [refs] = args;

      return (0, _assign2.default)({}, ...(0, _entries2.default)(pointer.storage.children).map(([id, childPointer]) => ({
        [childPointer.name]: decode(refs[id].definition, { storage: childPointer }, state, ...args)
      })));

    default:
      debug("Unknown storage reference type: %s", utils.typeIdentifier(definition));
      return undefined;
  }
}

function decode(definition, ...args) {
  if (!utils.isReference(definition)) {
    return decodeValue(definition, ...args);
  }

  switch (utils.referenceType(definition)) {
    case "memory":
      return decodeMemoryReference(definition, ...args);
    case "storage":
      return decodeStorageReference(definition, ...args);
    default:
      debug("Unknown reference category: %s", utils.typeIdentifier(definition));
      return undefined;
  }
}

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.read = read;
exports.readBytes = readBytes;
exports.chunk = chunk;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _bignumber = __webpack_require__(14);

var _utils = __webpack_require__(10);

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:data:decode:memory");

/**
 * read word from memory
 *
 * requires `byte` to be a multiple of WORD_SIZE (32)
 *
 * @param memory - Uint8Array
 * @return {BigNumber}
 */
function read(memory, byte) {
  return readBytes(memory, byte, _utils.WORD_SIZE);
}

/**
 * read <bytes> amount of bytes from memory, starting at byte <start>
 *
 * @param memory - Uint8Array
 */
function readBytes(memory, byte, length) {
  byte = utils.toBigNumber(byte);
  length = utils.toBigNumber(length);

  if (byte.toNumber() >= memory.length) {
    return new Uint8Array(length ? length.toNumber() : 0);
  }

  if (length == undefined) {
    return new Uint8Array(memory.buffer, byte.toNumber());
  }

  // grab `length` bytes no matter what, here fill this array
  var bytes = new Uint8Array(length.toNumber());

  // if we're reading past the end of memory, truncate the length to read
  let excess = byte.plus(length).minus(memory.length).toNumber();
  if (excess > 0) {
    length = new _bignumber.BigNumber(memory.length).minus(byte);
  }

  let existing = new Uint8Array(memory.buffer, byte.toNumber(), length.toNumber());

  bytes.set(existing);

  return bytes;
}

/**
 * Split memory into chunks
 */
function chunk(memory, size = _utils.WORD_SIZE) {
  let chunks = [];

  for (let i = 0; i < memory.length; i += size) {
    let chunk = readBytes(memory, i, size);
    chunks.push(chunk);
  }

  return chunks;
}

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__(5);

var _extends3 = _interopRequireDefault(_extends2);

exports.read = read;
exports.readRange = readRange;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _utils = __webpack_require__(10);

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:data:decode:storage");

/**
 * read slot from storage
 *
 * @param slot - big number or array of regular numbers
 * @param offset - for array, offset from the keccak determined location
 */
function read(storage, slot, offset = 0) {
  if (slot instanceof Array) {
    slot = utils.keccak256(...slot.map(utils.toBigNumber));
  }

  slot = utils.toBigNumber(slot).plus(offset);

  debug("reading slot: %o", utils.toHexString(slot));

  let word = storage[utils.toHexString(slot, _utils.WORD_SIZE)] || new Uint8Array(_utils.WORD_SIZE);

  debug("word %o", word);
  return word;
}

/**
 * read all bytes in some range.
 *
 * parameters `from` and `to` are objects with the following properties:
 *
 *   slot - (required) either a bignumber or a "path" array of integer offsets
 *
 *     path array values get converted into keccak256 hash as per solidity
 *     storage allocation method
 *
 *     ref: https://solidity.readthedocs.io/en/v0.4.23/miscellaneous.html#layout-of-state-variables-in-storage
 *     (search "concatenation")
 *
 *  offset - (default: 0) slot offset
 *
 *  index - (default: 0) byte index in word
 *
 * @param from - location (see ^)
 * @param to - location (see ^). inclusive.
 * @param length - instead of `to`, number of bytes after `from`
 */
function readRange(storage, { from, to, length }) {
  if (!length && !to || length && to) {
    throw new Error("must specify exactly one `to`|`length`");
  }

  from = (0, _extends3.default)({}, from, {
    offset: from.offset || 0
  });

  if (length) {
    to = {
      slot: from.slot,
      offset: from.offset + Math.floor((from.index + length - 1) / _utils.WORD_SIZE),
      index: (from.index + length - 1) % _utils.WORD_SIZE
    };
  } else {
    to = (0, _extends3.default)({}, to, {
      offset: to.offset || 0
    });
  }

  debug("readRange %o", { from, to });

  const totalWords = to.offset - from.offset + 1;
  debug("totalWords %o", totalWords);

  let data = new Uint8Array(totalWords * _utils.WORD_SIZE);

  for (let i = 0; i < totalWords; i++) {
    let offset = i + from.offset;
    data.set(read(storage, from.slot, offset), i * _utils.WORD_SIZE);
  }
  debug("words %o", data);

  data = data.slice(from.index, (totalWords - 1) * _utils.WORD_SIZE + to.index + 1);

  debug("data: %o", data);

  return data;
}

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.visit = visit;
exports.doneVisiting = doneVisiting;
const VISIT = exports.VISIT = "VISIT";
function visit(sourceId, ast) {
  return {
    type: VISIT,
    sourceId, ast
  };
}

const DONE_VISITING = exports.DONE_VISITING = "DONE_VISITING";
function doneVisiting() {
  return {
    type: DONE_VISITING
  };
}

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = __webpack_require__(16);

var _keys2 = _interopRequireDefault(_keys);

var _set = __webpack_require__(18);

var _set2 = _interopRequireDefault(_set);

exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(6);

var _helpers = __webpack_require__(2);

var _sagas = __webpack_require__(26);

var trace = _interopRequireWildcard(_sagas);

var _actions = __webpack_require__(21);

var actions = _interopRequireWildcard(_actions);

var _selectors = __webpack_require__(51);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:controller:sagas");

const CONTROL_SAGAS = {
  [actions.ADVANCE]: advance,
  [actions.STEP_NEXT]: stepNext,
  [actions.STEP_OVER]: stepOver,
  [actions.STEP_INTO]: stepInto,
  [actions.STEP_OUT]: stepOut,
  [actions.CONTINUE_UNTIL]: continueUntil
};

/** AST node types that are skipped to filter out some noise */
const SKIPPED_TYPES = new _set2.default(["ContractDefinition", "VariableDeclaration"]);

function* saga() {
  while (true) {
    debug("waiting for control action");
    let action = yield (0, _effects.take)((0, _keys2.default)(CONTROL_SAGAS));
    debug("got control action");
    let saga = CONTROL_SAGAS[action.type];

    yield (0, _effects.put)(actions.beginStep(action.type));

    yield (0, _effects.race)({
      exec: (0, _effects.call)(saga, action),
      interrupt: (0, _effects.take)(actions.INTERRUPT)
    });
  }
}

exports.default = (0, _helpers.prefixName)("controller", saga);

/**
 * Advance the state by one instruction
 */

function* advance() {
  // send action to advance trace
  yield* trace.advance();
}

/**
 * stepNext - step to the next logical code segment
 *
 * Note: It might take multiple instructions to express the same section of code.
 * "Stepping", then, is stepping to the next logical item, not stepping to the next
 * instruction. See advance() if you'd like to advance by one instruction.
 */
function* stepNext() {
  const startingRange = yield (0, _effects.select)(_selectors2.default.current.location.sourceRange);

  var upcoming;

  do {
    // advance at least once step
    yield* advance();

    // and check the next source range
    try {
      upcoming = yield (0, _effects.select)(_selectors2.default.current.location);
    } catch (e) {
      upcoming = null;
    }

    // if the next step's source range is still the same, keep going
  } while (!upcoming || !upcoming.node || SKIPPED_TYPES.has(upcoming.node.nodeType) || upcoming.sourceRange.start == startingRange.start && upcoming.sourceRange.length == startingRange.length);
}

/**
 * stepInto - step into the current function
 *
 * Conceptually this is easy, but from a programming standpoint it's hard.
 * Code like `getBalance(msg.sender)` might be highlighted, but there could
 * be a number of different intermediate steps (like evaluating `msg.sender`)
 * before `getBalance` is stepped into. This function will step into the first
 * function available (where instruction.jump == "i"), ignoring any intermediate
 * steps that fall within the same code range. If there's a step encountered
 * that exists outside of the range, then stepInto will only execute until that
 * step.
 */
function* stepInto() {
  if (yield (0, _effects.select)(_selectors2.default.current.willJump)) {
    yield* stepNext();

    return;
  }

  if (yield (0, _effects.select)(_selectors2.default.current.location.isMultiline)) {
    yield* stepOver();

    return;
  }

  const startingDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
  const startingRange = yield (0, _effects.select)(_selectors2.default.current.location.sourceRange);
  var currentDepth;
  var currentRange;

  do {
    yield* stepNext();

    currentDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
    currentRange = yield (0, _effects.select)(_selectors2.default.current.location.sourceRange);
  } while (
  // the function stack has not increased,
  currentDepth <= startingDepth &&

  // the current source range begins on or after the starting range
  currentRange.start >= startingRange.start &&

  // and the current range ends on or before the starting range ends
  currentRange.start + currentRange.length <= startingRange.start + startingRange.length);
}

/**
 * Step out of the current function
 *
 * This will run until the debugger encounters a decrease in function depth.
 */
function* stepOut() {
  if (yield (0, _effects.select)(_selectors2.default.current.location.isMultiline)) {
    yield* stepOver();

    return;
  }

  const startingDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
  var currentDepth;

  do {
    yield* stepNext();

    currentDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
  } while (currentDepth >= startingDepth);
}

/**
 * stepOver - step over the current line
 *
 * Step over the current line. This will step to the next instruction that
 * exists on a different line of code within the same function depth.
 */
function* stepOver() {
  const startingDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
  const startingRange = yield (0, _effects.select)(_selectors2.default.current.location.sourceRange);
  var currentDepth;
  var currentRange;

  do {
    yield* stepNext();

    currentDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
    currentRange = yield (0, _effects.select)(_selectors2.default.current.location.sourceRange);
  } while (
  // keep stepping provided:
  //
  // we haven't jumped out
  !(currentDepth < startingDepth) && (

  // either: function depth is greater than starting (ignore function calls)
  // or, if we're at the same depth, keep stepping until we're on a new
  // line.
  currentDepth > startingDepth || currentRange.lines.start.line == startingRange.lines.start.line));
}

/**
 * continueUntil - step through execution until a breakpoint
 *
 * @param breakpoints - array of breakpoints ({ ...call, line })
 */
function* continueUntil({ breakpoints }) {
  var currentCall;
  var currentLocation;

  let breakpointHit = false;

  do {
    yield* stepNext();

    currentCall = yield (0, _effects.select)(_selectors2.default.current.executionContext);
    currentLocation = yield (0, _effects.select)(_selectors2.default.current.location);

    breakpointHit = breakpoints.filter(({ address, binary, line, node }) => (address == currentCall.address || binary == currentCall.binary) && (line == currentLocation.sourceRange.lines.start.line || node == currentLocation.node.id)).length > 0;
  } while (!breakpointHit);
}

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(4);

var _selectors = __webpack_require__(7);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(8);

var _selectors4 = _interopRequireDefault(_selectors3);

var _selectors5 = __webpack_require__(11);

var _selectors6 = _interopRequireDefault(_selectors5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:controller:sagas");

/**
 * @private
 */
const identity = x => x;

/**
 * controller
 */
const controller = (0, _reselectTree.createSelectorTree)({

  /**
   * controller.current
   */
  current: {
    /**
     * controller.current.functionDepth
     */
    functionDepth: (0, _reselectTree.createLeaf)([_selectors4.default.current.functionDepth], identity),

    /**
     * controller.current.executionContext
     */
    executionContext: (0, _reselectTree.createLeaf)([_selectors2.default.current.call], identity),

    /**
     * controller.current.willJump
     */
    willJump: (0, _reselectTree.createLeaf)([_selectors2.default.current.step.isJump], identity),

    /**
     * controller.current.location
     */
    location: {
      /**
       * controller.current.location.sourceRange
       */
      sourceRange: (0, _reselectTree.createLeaf)([_selectors4.default.current.sourceRange], identity),

      /**
       * controller.current.location.node
       */
      node: (0, _reselectTree.createLeaf)([_selectors6.default.current.node], identity),

      /**
       * controller.current.location.isMultiline
       */
      isMultiline: (0, _reselectTree.createLeaf)([_selectors4.default.current.isMultiline], identity)
    }
  }
});

exports.default = controller;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addSource = addSource;
exports.addSourceMap = addSourceMap;
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(6);

var _helpers = __webpack_require__(2);

var _actions = __webpack_require__(27);

var actions = _interopRequireWildcard(_actions);

var _actions2 = __webpack_require__(12);

var _selectors = __webpack_require__(8);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:solidity:sagas");

function* addSource(source, sourcePath, ast) {
  yield (0, _effects.put)(actions.addSource(source, sourcePath, ast));
}

function* addSourceMap(binary, sourceMap) {
  yield (0, _effects.put)(actions.addSourceMap(binary, sourceMap));
}

function* tickSaga() {
  while (true) {
    yield (0, _effects.take)(_actions2.TICK);
    debug("got TICK");

    yield* functionDepthSaga();
  }
}

function* functionDepthSaga() {
  if (yield (0, _effects.select)(_selectors2.default.current.willJump)) {
    let jumpDirection = yield (0, _effects.select)(_selectors2.default.current.jumpDirection);

    yield (0, _effects.put)(actions.jump(jumpDirection));
  }
}

function* saga() {
  yield (0, _effects.call)(tickSaga);
}

exports.default = (0, _helpers.prefixName)("solidity", saga);

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addContext = addContext;
exports.addInstance = addInstance;
exports.begin = begin;
exports.callstackSaga = callstackSaga;
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(6);

var _helpers = __webpack_require__(2);

var _actions = __webpack_require__(12);

var _actions2 = __webpack_require__(28);

var actions = _interopRequireWildcard(_actions2);

var _selectors = __webpack_require__(7);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:evm:sagas");

/**
 * Adds EVM bytecode context
 *
 * @return {string} ID (0x-prefixed keccak of binary)
 */
function* addContext(contractName, binary) {
  yield (0, _effects.put)(actions.addContext(contractName, binary));

  return (0, _helpers.keccak256)(binary);
}

/**
 * Adds known deployed instance of binary at address
 *
 * @return {string} ID (0x-prefixed keccak of binary)
 */
function* addInstance(address, binary) {
  let search = yield (0, _effects.select)(_selectors2.default.info.binaries.search);
  if (binary != "0x0") {
    let { context } = search(binary);

    yield (0, _effects.put)(actions.addInstance(address, context, binary));

    return context;
  }
}

function* begin({ address, binary }) {
  if (address) {
    yield (0, _effects.put)(actions.call(address));
  } else {
    yield (0, _effects.put)(actions.create(binary));
  }
}

function* callstackSaga() {
  while (true) {
    yield (0, _effects.take)(_actions.TICK);
    debug("got TICK");

    if (yield (0, _effects.select)(_selectors2.default.current.step.isCall)) {
      debug("got call");
      let address = yield (0, _effects.select)(_selectors2.default.current.step.callAddress);

      yield (0, _effects.put)(actions.call(address));
    } else if (yield (0, _effects.select)(_selectors2.default.current.step.isCreate)) {
      debug("got create");
      let binary = yield (0, _effects.select)(_selectors2.default.current.step.createBinary);

      yield (0, _effects.put)(actions.create(binary));
    } else if (yield (0, _effects.select)(_selectors2.default.current.step.isHalting)) {
      debug("got return");
      yield (0, _effects.put)(actions.returnCall());
    }
  }
}

function* saga() {
  yield (0, _effects.call)(callstackSaga);
}

exports.default = (0, _helpers.prefixName)("evm", saga);

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.inspectTransaction = inspectTransaction;
exports.obtainBinaries = obtainBinaries;
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(6);

var _helpers = __webpack_require__(2);

var _actions = __webpack_require__(55);

var actions = _interopRequireWildcard(_actions);

var _adapter = __webpack_require__(56);

var _adapter2 = _interopRequireDefault(_adapter);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:web3:sagas");

function* fetchTransactionInfo(adapter, { txHash }) {
  debug("inspecting transaction");
  var trace;
  try {
    trace = yield (0, _effects.apply)(adapter, adapter.getTrace, [txHash]);
  } catch (e) {
    debug("putting error");
    yield (0, _effects.put)(actions.error(e));
    return;
  }

  debug("got trace");
  yield (0, _effects.put)(actions.receiveTrace(trace));

  let tx = yield (0, _effects.apply)(adapter, adapter.getTransaction, [txHash]);
  if (tx.to && tx.to != "0x0") {
    yield (0, _effects.put)(actions.receiveCall({ address: tx.to }));
    return;
  }

  let receipt = yield (0, _effects.apply)(adapter, adapter.getReceipt, [txHash]);
  if (receipt.contractAddress) {
    yield (0, _effects.put)(actions.receiveCall({ binary: tx.input }));
    return;
  }

  throw new Error("Could not find contract associated with transaction. " + "Please make sure you're debugging a transaction that executes a " + "contract function or creates a new contract.");
}

function* fetchBinary(adapter, { address }) {
  debug("fetching binary for %s", address);
  let binary = yield (0, _effects.apply)(adapter, adapter.getDeployedCode, [address]);

  debug("received binary for %s", address);
  yield (0, _effects.put)(actions.receiveBinary(address, binary));
}

function* inspectTransaction(txHash, provider) {
  yield (0, _effects.put)(actions.init(provider));
  yield (0, _effects.put)(actions.inspect(txHash));

  let action = yield (0, _effects.take)(({ type }) => type == actions.RECEIVE_TRACE || type == actions.ERROR_WEB3);
  debug("action %o", action);

  var trace;
  if (action.type == actions.RECEIVE_TRACE) {
    trace = action.trace;
    debug("received trace");
  } else {
    return { error: action.error };
  }

  let { address, binary } = yield (0, _effects.take)(actions.RECEIVE_CALL);
  debug("received call");

  return { trace, address, binary };
}

function* obtainBinaries(addresses) {
  let tasks = yield (0, _effects.all)(addresses.map(address => (0, _effects.fork)(receiveBinary, address)));

  debug("requesting binaries");
  yield (0, _effects.all)(addresses.map(address => (0, _effects.put)(actions.fetchBinary(address))));

  let binaries = [];
  binaries = yield (0, _effects.all)(tasks.map(task => (0, _effects.join)(task)));

  debug("binaries %o", binaries);

  return binaries;
}

function* receiveBinary(address) {
  let { binary } = yield (0, _effects.take)(action => action.type == actions.RECEIVE_BINARY && action.address == address);
  debug("got binary for %s", address);

  return binary;
}

function* saga() {
  // wait for web3 init signal
  let { provider } = yield (0, _effects.take)(actions.INIT_WEB3);
  let adapter = new _adapter2.default(provider);

  yield (0, _effects.takeEvery)(actions.INSPECT, fetchTransactionInfo, adapter);
  yield (0, _effects.takeEvery)(actions.FETCH_BINARY, fetchBinary, adapter);
}

exports.default = (0, _helpers.prefixName)("web3", saga);

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.init = init;
exports.inspect = inspect;
exports.fetchBinary = fetchBinary;
exports.receiveBinary = receiveBinary;
exports.receiveTrace = receiveTrace;
exports.receiveCall = receiveCall;
exports.error = error;
const INIT_WEB3 = exports.INIT_WEB3 = "INIT_WEB3";
function init(provider) {
  return {
    type: INIT_WEB3,
    provider
  };
}

const INSPECT = exports.INSPECT = "INSPECT_TRANSACTION";
function inspect(txHash) {
  return {
    type: INSPECT,
    txHash
  };
}

const FETCH_BINARY = exports.FETCH_BINARY = "FETCH_BINARY";
function fetchBinary(address) {
  return {
    type: FETCH_BINARY,
    address
  };
}

const RECEIVE_BINARY = exports.RECEIVE_BINARY = "RECEIVE_BINARY";
function receiveBinary(address, binary) {
  return {
    type: RECEIVE_BINARY,
    address, binary
  };
}

const RECEIVE_TRACE = exports.RECEIVE_TRACE = "RECEIVE_TRACE";
function receiveTrace(trace) {
  return {
    type: RECEIVE_TRACE,
    trace
  };
}

const RECEIVE_CALL = exports.RECEIVE_CALL = "RECEIVE_CALL";
function receiveCall({ address, binary }) {
  return {
    type: RECEIVE_CALL,
    address, binary
  };
}

const ERROR_WEB3 = exports.ERROR_WEB3 = "ERROR_WEB3";
function error(error) {
  return {
    type: ERROR_WEB3,
    error
  };
}

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = __webpack_require__(20);

var _promise2 = _interopRequireDefault(_promise);

var _asyncToGenerator2 = __webpack_require__(19);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _web = __webpack_require__(22);

var _web2 = _interopRequireDefault(_web);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:web3:adapter");

class Web3Adapter {
  constructor(provider) {
    this.web3 = new _web2.default(provider);
  }

  getTrace(txHash) {
    var _this = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return new _promise2.default(function (accept, reject) {
        _this.web3.currentProvider.sendAsync({
          jsonrpc: "2.0",
          method: "debug_traceTransaction",
          params: [txHash, {}],
          id: new Date().getTime()
        }, function (err, result) {
          if (err) return reject(err);
          if (result.error) return reject(new Error(result.error.message));
          debug("result: %o", result);
          accept(result.result.structLogs);
        });
      });
    })();
  }

  getTransaction(txHash) {
    var _this2 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return new _promise2.default(function (accept, reject) {
        _this2.web3.eth.getTransaction(txHash, function (err, tx) {
          if (err) return reject(err);

          return accept(tx);
        });
      });
    })();
  }

  getReceipt(txHash) {
    var _this3 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return new _promise2.default(function (accept, reject) {
        _this3.web3.eth.getTransactionReceipt(txHash, function (err, receipt) {
          if (err) return reject(err);

          return accept(receipt);
        });
      });
    })();
  }

  /**
   * getDeployedCode - get the deployed code for an address from the client
   * @param  {String} address
   * @return {String}         deployedBinary
   */
  getDeployedCode(address) {
    var _this4 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      debug("getting deployed code for %s", address);
      return new _promise2.default(function (accept, reject) {
        _this4.web3.eth.getCode(address, function (err, deployedBinary) {
          if (err) debug("error: %o", err);
          if (err) return reject(err);
          debug("got deployed code for %s", address);
          accept(deployedBinary);
        });
      });
    })();
  }
}
exports.default = Web3Adapter;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FINISHED = exports.ERROR = exports.ACTIVE = exports.WAITING = undefined;
exports.session = session;

var _redux = __webpack_require__(9);

var _reducers = __webpack_require__(58);

var _reducers2 = _interopRequireDefault(_reducers);

var _reducers3 = __webpack_require__(59);

var _reducers4 = _interopRequireDefault(_reducers3);

var _reducers5 = __webpack_require__(61);

var _reducers6 = _interopRequireDefault(_reducers5);

var _reducers7 = __webpack_require__(62);

var _reducers8 = _interopRequireDefault(_reducers7);

var _actions = __webpack_require__(17);

var actions = _interopRequireWildcard(_actions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const WAITING = exports.WAITING = "WAITING";
const ACTIVE = exports.ACTIVE = "ACTIVE";
const ERROR = exports.ERROR = "ERROR";
const FINISHED = exports.FINISHED = "FINISHED";

function session(state = WAITING, action) {
  switch (action.type) {
    case actions.READY:
      return ACTIVE;

    case actions.ERROR:
      return { error: action.error };

    case actions.FINISH:
      return FINISHED;

    default:
      return state;
  }
}

const reduceState = (0, _redux.combineReducers)({
  session,
  data: _reducers2.default,
  evm: _reducers4.default,
  solidity: _reducers6.default,
  trace: _reducers8.default
});

exports.default = reduceState;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _entries = __webpack_require__(1);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(3);

var _assign2 = _interopRequireDefault(_assign);

var _extends2 = __webpack_require__(5);

var _extends3 = _interopRequireDefault(_extends2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _redux = __webpack_require__(9);

var _actions = __webpack_require__(24);

var actions = _interopRequireWildcard(_actions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:data:reducers");

const DEFAULT_SCOPES = {
  byId: {}
};

function scopes(state = DEFAULT_SCOPES, action) {
  var context;
  var scope;
  var variables;

  switch (action.type) {
    case actions.SCOPE:
      scope = state.byId[action.id] || {};

      return {
        byId: (0, _extends3.default)({}, state.byId, {

          [action.id]: (0, _extends3.default)({}, scope, {

            id: action.id,
            sourceId: action.sourceId,
            parentId: action.parentId,
            pointer: action.pointer
          })
        })
      };

    case actions.DECLARE:
      scope = state.byId[action.node.scope] || {};
      variables = scope.variables || [];

      return {
        byId: (0, _extends3.default)({}, state.byId, {

          [action.node.scope]: (0, _extends3.default)({}, scope, {

            variables: [...variables, { name: action.node.name, id: action.node.id }]
          })
        })
      };

    default:
      return state;
  }
}

const info = (0, _redux.combineReducers)({
  scopes
});

const DEFAULT_ASSIGNMENTS = {
  byId: {}
};

function assignments(state = DEFAULT_ASSIGNMENTS, action) {
  switch (action.type) {
    case actions.ASSIGN:
      return {
        byId: (0, _extends3.default)({}, state.byId, (0, _assign2.default)({}, ...(0, _entries2.default)(action.assignments).map(([id, ref]) => ({
          [id]: (0, _extends3.default)({}, state.byId[id], {
            ref
          })
        }))))
      };

    default:
      return state;
  }
};

const proc = (0, _redux.combineReducers)({
  assignments
});

const reducer = (0, _redux.combineReducers)({
  info,
  proc
});

exports.default = reducer;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _set = __webpack_require__(18);

var _set2 = _interopRequireDefault(_set);

var _from = __webpack_require__(60);

var _from2 = _interopRequireDefault(_from);

var _extends2 = __webpack_require__(5);

var _extends3 = _interopRequireDefault(_extends2);

exports.callstack = callstack;

var _redux = __webpack_require__(9);

var _actions = __webpack_require__(28);

var actions = _interopRequireWildcard(_actions);

var _helpers = __webpack_require__(2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const DEFAULT_CONTEXTS = {
  byContext: {},
  byBinary: {}
};

function contexts(state = DEFAULT_CONTEXTS, action) {
  switch (action.type) {
    /*
     * Adding a new context
     */
    case actions.ADD_CONTEXT:
      let { contractName, binary } = action;

      if (state.byBinary[binary]) {
        return state;
      }

      let context = (0, _helpers.keccak256)(binary);

      return {
        byContext: (0, _extends3.default)({}, state.byContext, {

          [context]: { context, binary, contractName }
        }),

        byBinary: (0, _extends3.default)({}, state.byBinary, {

          [binary]: { context: context }
        })
      };

    /*
     * Default case
     */
    default:
      return state;
  }
}

const DEFAULT_INSTANCES = {
  byAddress: {},
  byContext: {}
};

function instances(state = DEFAULT_INSTANCES, action) {
  switch (action.type) {
    /*
     * Adding a new address for context
     */
    case actions.ADD_INSTANCE:
      let { address, context, binary } = action;

      // get known addresses for this context
      let otherInstances = state.byContext[context] || [];
      let otherAddresses = otherInstances.map(({ address }) => address);

      return {
        byAddress: (0, _extends3.default)({}, state.byAddress, {

          [address]: { context, binary }
        }),

        byContext: (0, _extends3.default)({}, state.byContext, {

          // reconstruct context instances to include new address
          [context]: (0, _from2.default)(new _set2.default(otherAddresses).add(address)).map(address => ({ address }))
        })
      };

    /*
     * Default case
     */
    default:
      return state;
  }
}

const info = (0, _redux.combineReducers)({
  contexts,
  instances
});

function callstack(state = [], action) {
  switch (action.type) {
    case actions.CALL:
      let address = action.address;
      return state.concat([{ address }]);

    case actions.CREATE:
      const binary = action.binary;
      return state.concat([{ binary }]);

    case actions.RETURN:
      return state.slice(0, -1); // pop

    default:
      return state;
  };
}

const proc = (0, _redux.combineReducers)({
  callstack
});

const reducer = (0, _redux.combineReducers)({
  info,
  proc
});

exports.default = reducer;

/***/ }),
/* 60 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/array/from");

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__(5);

var _extends3 = _interopRequireDefault(_extends2);

var _keys = __webpack_require__(16);

var _keys2 = _interopRequireDefault(_keys);

exports.functionDepth = functionDepth;

var _redux = __webpack_require__(9);

var _helpers = __webpack_require__(2);

var _actions = __webpack_require__(27);

var actions = _interopRequireWildcard(_actions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const DEFAULT_SOURCES = {
  byId: {}
};

function sources(state = DEFAULT_SOURCES, action) {
  switch (action.type) {
    /*
     * Adding a new source
     */
    case actions.ADD_SOURCE:
      let { ast, source, sourcePath } = action;

      let id = (0, _keys2.default)(state.byId).length;

      return {
        byId: (0, _extends3.default)({}, state.byId, {

          [id]: {
            id,
            ast,
            source,
            sourcePath
          }
        })

        /*
         * Default case
         */
      };default:
      return state;
  }
}

const DEFAULT_SOURCEMAPS = {
  byContext: {}
};

function sourceMaps(state = DEFAULT_SOURCEMAPS, action) {
  switch (action.type) {
    /*
     * Adding a new sourceMap
     */
    case actions.ADD_SOURCEMAP:
      let { binary, sourceMap } = action;
      let context = (0, _helpers.keccak256)(binary);

      return {
        byContext: (0, _extends3.default)({}, state.byContext, {

          [context]: {
            context,
            sourceMap
          }
        })
      };

    /*
     * Default Case
     */
    default:
      return state;
  }
}

const info = (0, _redux.combineReducers)({
  sources,
  sourceMaps
});

function functionDepth(state = 1, action) {
  if (action.type === actions.JUMP) {
    const delta = spelunk(action.jumpDirection);
    return state + delta;
  } else {
    return state;
  }
}

function spelunk(jump) {
  if (jump == "i") {
    return 1;
  } else if (jump == "o") {
    return -1;
  } else {
    return 0;
  }
}

const proc = (0, _redux.combineReducers)({
  functionDepth
});

const reducer = (0, _redux.combineReducers)({
  info,
  proc
});

exports.default = reducer;

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.index = index;
exports.steps = steps;

var _redux = __webpack_require__(9);

var _actions = __webpack_require__(12);

var actions = _interopRequireWildcard(_actions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function index(state = 0, action) {
  if (action.type == actions.TOCK || action.type == actions.END_OF_TRACE) {
    return state + 1;
  } else {
    return state;
  }
}

function steps(state = null, action) {
  if (action.type == actions.SAVE_STEPS) {
    return action.steps;
  } else {
    return state;
  }
}

const info = (0, _redux.combineReducers)({
  steps
});

const proc = (0, _redux.combineReducers)({
  index
});

const reducer = (0, _redux.combineReducers)({
  info,
  proc
});

exports.default = reducer;

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _entries = __webpack_require__(1);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(3);

var _assign2 = _interopRequireDefault(_assign);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(4);

var _selectors = __webpack_require__(7);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(8);

var _selectors4 = _interopRequireDefault(_selectors3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:session:selectors");

const session = (0, _reselectTree.createSelectorTree)({
  /**
   * session.info
   */
  info: {

    /**
     * session.info.affectedInstances
     */
    affectedInstances: (0, _reselectTree.createLeaf)([_selectors2.default.info.instances, _selectors2.default.info.contexts, _selectors4.default.info.sources, _selectors4.default.info.sourceMaps], (instances, contexts, sources, sourceMaps) => (0, _assign2.default)({}, ...(0, _entries2.default)(instances).map(([address, { context }]) => {
      let { contractName, binary } = contexts[context];
      let { sourceMap } = sourceMaps[context];

      let { source } = sourceMap ?
      // look for source ID between second and third colons (HACK)
      sources[sourceMap.match(/^[^:]+:[^:]+:([^:]+):/)[1]] : {};

      return {
        [address]: {
          contractName, source, binary
        }
      };
    })))
  }
});

exports.default = session;

/***/ })
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVidWdnZXIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2svYm9vdHN0cmFwIDgxNzJmNGY5NDlmNjVjZmIyYWNmIiwiZXh0ZXJuYWwgXCJkZWJ1Z1wiIiwiZXh0ZXJuYWwgXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2VudHJpZXNcIiIsImxpYi9oZWxwZXJzL2luZGV4LmpzIiwiZXh0ZXJuYWwgXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2Fzc2lnblwiIiwiZXh0ZXJuYWwgXCJyZXNlbGVjdC10cmVlXCIiLCJleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9leHRlbmRzXCIiLCJleHRlcm5hbCBcInJlZHV4LXNhZ2EvZWZmZWN0c1wiIiwibGliL2V2bS9zZWxlY3RvcnMvaW5kZXguanMiLCJsaWIvc29saWRpdHkvc2VsZWN0b3JzL2luZGV4LmpzIiwiZXh0ZXJuYWwgXCJyZWR1eFwiIiwibGliL2RhdGEvZGVjb2RlL3V0aWxzLmpzIiwibGliL2FzdC9zZWxlY3RvcnMvaW5kZXguanMiLCJsaWIvdHJhY2UvYWN0aW9ucy9pbmRleC5qcyIsImxpYi90cmFjZS9zZWxlY3RvcnMvaW5kZXguanMiLCJleHRlcm5hbCBcImJpZ251bWJlci5qc1wiIiwiZXh0ZXJuYWwgXCJqc29uLXBvaW50ZXJcIiIsImV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9rZXlzXCIiLCJsaWIvc2Vzc2lvbi9hY3Rpb25zL2luZGV4LmpzIiwiZXh0ZXJuYWwgXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvc2V0XCIiLCJleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIiLCJleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9wcm9taXNlXCIiLCJsaWIvY29udHJvbGxlci9hY3Rpb25zL2luZGV4LmpzIiwiZXh0ZXJuYWwgXCJ3ZWIzXCIiLCJsaWIvZGF0YS9zYWdhcy9pbmRleC5qcyIsImxpYi9kYXRhL2FjdGlvbnMvaW5kZXguanMiLCJsaWIvZGF0YS9zZWxlY3RvcnMvaW5kZXguanMiLCJsaWIvdHJhY2Uvc2FnYXMvaW5kZXguanMiLCJsaWIvc29saWRpdHkvYWN0aW9ucy9pbmRleC5qcyIsImxpYi9ldm0vYWN0aW9ucy9pbmRleC5qcyIsIi9Vc2Vycy9jcnV6bW9saW5hL0NvZGUvdHJ1ZmZsZS1wcm9qZWN0cy90cnVmZmxlL3BhY2thZ2VzL3RydWZmbGUtZGVidWdnZXIvZGVidWdnZXIuanMiLCJsaWIvZGVidWdnZXIuanMiLCJleHRlcm5hbCBcInRydWZmbGUtZXhwZWN0XCIiLCJsaWIvc2Vzc2lvbi9pbmRleC5qcyIsImV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC92YWx1ZXNcIiIsImV4dGVybmFsIFwidHJ1ZmZsZS1zb2xpZGl0eS11dGlsc1wiIiwiZXh0ZXJuYWwgXCJ0cnVmZmxlLWNvZGUtdXRpbHNcIiIsImxpYi9hc3QvbWFwLmpzIiwiL1VzZXJzL2NydXptb2xpbmEvQ29kZS90cnVmZmxlLXByb2plY3RzL3RydWZmbGUvbm9kZV9tb2R1bGVzL25vZGUtaW50ZXJ2YWwtdHJlZS9saWIvaW5kZXguanMiLCIvVXNlcnMvY3J1em1vbGluYS9Db2RlL3RydWZmbGUtcHJvamVjdHMvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvc2hhbGxvd2VxdWFsL2luZGV4LmpzIiwibGliL3N0b3JlL2luZGV4LmpzIiwibGliL3N0b3JlL3Byb2R1Y3Rpb24uanMiLCJsaWIvc3RvcmUvY29tbW9uLmpzIiwiZXh0ZXJuYWwgXCJyZWR1eC1zYWdhXCIiLCJleHRlcm5hbCBcInJlZHV4LWNsaS1sb2dnZXJcIiIsImxpYi9zZXNzaW9uL3NhZ2FzL2luZGV4LmpzIiwibGliL2FzdC9zYWdhcy9pbmRleC5qcyIsImxpYi9kYXRhL2RlY29kZS9pbmRleC5qcyIsImxpYi9kYXRhL2RlY29kZS9tZW1vcnkuanMiLCJsaWIvZGF0YS9kZWNvZGUvc3RvcmFnZS5qcyIsImxpYi9hc3QvYWN0aW9ucy9pbmRleC5qcyIsImxpYi9jb250cm9sbGVyL3NhZ2FzL2luZGV4LmpzIiwibGliL2NvbnRyb2xsZXIvc2VsZWN0b3JzL2luZGV4LmpzIiwibGliL3NvbGlkaXR5L3NhZ2FzL2luZGV4LmpzIiwibGliL2V2bS9zYWdhcy9pbmRleC5qcyIsImxpYi93ZWIzL3NhZ2FzL2luZGV4LmpzIiwibGliL3dlYjMvYWN0aW9ucy9pbmRleC5qcyIsImxpYi93ZWIzL2FkYXB0ZXIuanMiLCJsaWIvc2Vzc2lvbi9yZWR1Y2Vycy5qcyIsImxpYi9kYXRhL3JlZHVjZXJzLmpzIiwibGliL2V2bS9yZWR1Y2Vycy5qcyIsImV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL2FycmF5L2Zyb21cIiIsImxpYi9zb2xpZGl0eS9yZWR1Y2Vycy5qcyIsImxpYi90cmFjZS9yZWR1Y2Vycy5qcyIsImxpYi9zZXNzaW9uL3NlbGVjdG9ycy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShcIkRlYnVnZ2VyXCIsIFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIkRlYnVnZ2VyXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIkRlYnVnZ2VyXCJdID0gZmFjdG9yeSgpO1xufSkodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAyOSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgODE3MmY0Zjk0OWY2NWNmYjJhY2YiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImRlYnVnXCJcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9lbnRyaWVzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9lbnRyaWVzXCJcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsga2VjY2FrMjU2IGFzIF9rZWNjYWsyNTYsIHRvSGV4U3RyaW5nIH0gZnJvbSBcImxpYi9kYXRhL2RlY29kZS91dGlsc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gcHJlZml4TmFtZShwcmVmaXgsIGZuKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwgJ25hbWUnLCB7XG4gICAgdmFsdWU6IGAke3ByZWZpeH0uJHtmbi5uYW1lfWAsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuXG4gIHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBAcmV0dXJuIDB4LXByZWZpeCBzdHJpbmcgb2Yga2VjY2FrMjU2IGhhc2hcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGtlY2NhazI1NiguLi5hcmdzKSB7XG4gIHJldHVybiB0b0hleFN0cmluZyhfa2VjY2FrMjU2KC4uLmFyZ3MpKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvaGVscGVycy9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9hc3NpZ25cIlxuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZXNlbGVjdC10cmVlXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwicmVzZWxlY3QtdHJlZVwiXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9leHRlbmRzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2V4dGVuZHNcIlxuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWR1eC1zYWdhL2VmZmVjdHNcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJyZWR1eC1zYWdhL2VmZmVjdHNcIlxuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6ZXZtOnNlbGVjdG9yc1wiKTtcblxuaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3JUcmVlLCBjcmVhdGVMZWFmIH0gZnJvbSBcInJlc2VsZWN0LXRyZWVcIjtcblxuaW1wb3J0IHRyYWNlIGZyb20gXCJsaWIvdHJhY2Uvc2VsZWN0b3JzXCI7XG5cbmNvbnN0IFdPUkRfU0laRSA9IDB4MjA7XG5cbi8qKlxuICogY3JlYXRlIEVWTS1sZXZlbCBzZWxlY3RvcnMgZm9yIGEgZ2l2ZW4gdHJhY2Ugc3RlcCBzZWxlY3RvclxuICogbWF5IHNwZWNpZnkgYWRkaXRpb25hbCBzZWxlY3RvcnMgdG8gaW5jbHVkZVxuICovXG5mdW5jdGlvbiBjcmVhdGVTdGVwU2VsZWN0b3JzKHN0ZXAsIHN0YXRlID0gbnVsbCkge1xuICBsZXQgYmFzZSA9IHtcbiAgICAvKipcbiAgICAgKiAudHJhY2VcbiAgICAgKlxuICAgICAqIHRyYWNlIHN0ZXAgaW5mbyByZWxhdGVkIHRvIG9wZXJhdGlvblxuICAgICAqL1xuICAgIHRyYWNlOiBjcmVhdGVMZWFmKFxuICAgICAgW3N0ZXBdLCAoe2dhc0Nvc3QsIG9wLCBwY30pID0+ICh7Z2FzQ29zdCwgb3AsIHBjfSlcbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogLnByb2dyYW1Db3VudGVyXG4gICAgICovXG4gICAgcHJvZ3JhbUNvdW50ZXI6IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIuL3RyYWNlXCJdLCAoc3RlcCkgPT4gc3RlcC5wY1xuICAgICksXG5cbiAgICAvKipcbiAgICAgKiAuaXNKdW1wXG4gICAgICovXG4gICAgaXNKdW1wOiBjcmVhdGVMZWFmKFxuICAgICAgW1wiLi90cmFjZVwiXSwgKHN0ZXApID0+IChcbiAgICAgICAgc3RlcC5vcCAhPSBcIkpVTVBERVNUXCIgJiYgc3RlcC5vcC5pbmRleE9mKFwiSlVNUFwiKSA9PSAwXG4gICAgICApXG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIC5pc0NhbGxcbiAgICAgKlxuICAgICAqIHdoZXRoZXIgdGhlIG9wY29kZSB3aWxsIHN3aXRjaCB0byBhbm90aGVyIGNhbGxpbmcgY29udGV4dFxuICAgICAqL1xuICAgIGlzQ2FsbDogY3JlYXRlTGVhZihcbiAgICAgIFtcIi4vdHJhY2VcIl0sIChzdGVwKSA9PiBzdGVwLm9wID09IFwiQ0FMTFwiIHx8IHN0ZXAub3AgPT0gXCJERUxFR0FURUNBTExcIlxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiAuaXNDcmVhdGVcbiAgICAgKi9cbiAgICBpc0NyZWF0ZTogY3JlYXRlTGVhZihcbiAgICAgIFtcIi4vdHJhY2VcIl0sIChzdGVwKSA9PiBzdGVwLm9wID09IFwiQ1JFQVRFXCJcbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogLmlzSGFsdGluZ1xuICAgICAqXG4gICAgICogd2hldGhlciB0aGUgaW5zdHJ1Y3Rpb24gaGFsdHMgb3IgcmV0dXJucyBmcm9tIGEgY2FsbGluZyBjb250ZXh0XG4gICAgICovXG4gICAgaXNIYWx0aW5nOiBjcmVhdGVMZWFmKFxuICAgICAgW1wiLi90cmFjZVwiXSwgKHN0ZXApID0+IHN0ZXAub3AgPT0gXCJTVE9QXCIgfHwgc3RlcC5vcCA9PSBcIlJFVFVSTlwiXG4gICAgKVxuICB9O1xuXG4gIGlmIChzdGF0ZSkge1xuICAgIGNvbnN0IGlzUmVsYXRpdmUgPSAocGF0aCkgPT4gKFxuICAgICAgdHlwZW9mIHBhdGggPT0gXCJzdHJpbmdcIiAmJiAoXG4gICAgICAgIHBhdGguc3RhcnRzV2l0aChcIi4vXCIpIHx8IHBhdGguc3RhcnRzV2l0aChcIi4uL1wiKVxuICAgICAgKVxuICAgICk7XG5cbiAgICBpZiAoaXNSZWxhdGl2ZShzdGF0ZSkpIHtcbiAgICAgIHN0YXRlID0gYC4uLyR7c3RhdGV9YDtcbiAgICB9XG5cbiAgICBPYmplY3QuYXNzaWduKGJhc2UsIHtcbiAgICAgIC8qKlxuICAgICAgICogLmNhbGxBZGRyZXNzXG4gICAgICAgKlxuICAgICAgICogYWRkcmVzcyB0cmFuc2ZlcnJlZCB0byBieSBjYWxsIG9wZXJhdGlvblxuICAgICAgICovXG4gICAgICBjYWxsQWRkcmVzczogY3JlYXRlTGVhZihcbiAgICAgICAgW1wiLi9pc0NhbGxcIiwgXCIuL3RyYWNlXCIsIHN0YXRlXSxcblxuICAgICAgICAobWF0Y2hlcywgc3RlcCwge3N0YWNrfSkgPT4ge1xuICAgICAgICAgIGlmICghbWF0Y2hlcykgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgICBsZXQgYWRkcmVzcyA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDJdXG4gICAgICAgICAgYWRkcmVzcyA9IFwiMHhcIiArIGFkZHJlc3Muc3Vic3RyaW5nKDI0KTtcbiAgICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICAgICAgfVxuICAgICAgKSxcblxuICAgICAgLyoqXG4gICAgICAgKiAuY3JlYXRlQmluYXJ5XG4gICAgICAgKlxuICAgICAgICogYmluYXJ5IGNvZGUgdG8gZXhlY3V0ZSB2aWEgY3JlYXRlIG9wZXJhdGlvblxuICAgICAgICovXG4gICAgICBjcmVhdGVCaW5hcnk6IGNyZWF0ZUxlYWYoXG4gICAgICAgIFtcIi4vaXNDcmVhdGVcIiwgXCIuL3RyYWNlXCIsIHN0YXRlXSxcblxuICAgICAgICAobWF0Y2hlcywgc3RlcCwge3N0YWNrLCBtZW1vcnl9KSA9PiB7XG4gICAgICAgICAgaWYgKCFtYXRjaGVzKSByZXR1cm4gbnVsbDtcblxuICAgICAgICAgIC8vIEdldCB0aGUgY29kZSB0aGF0J3MgZ29pbmcgdG8gYmUgY3JlYXRlZCBmcm9tIG1lbW9yeS5cbiAgICAgICAgICAvLyBOb3RlIHdlIG11bHRpcGx5IGJ5IDIgYmVjYXVzZSB0aGVzZSBvZmZzZXRzIGFyZSBpbiBieXRlcy5cbiAgICAgICAgICBjb25zdCBvZmZzZXQgPSBwYXJzZUludChzdGFja1tzdGFjay5sZW5ndGggLSAyXSwgMTYpICogMjtcbiAgICAgICAgICBjb25zdCBsZW5ndGggPSBwYXJzZUludChzdGFja1tzdGFjay5sZW5ndGggLSAzXSwgMTYpICogMjtcblxuICAgICAgICAgIHJldHVybiBcIjB4XCIgKyBtZW1vcnkuam9pbihcIlwiKS5zdWJzdHJpbmcob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICApXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gYmFzZTtcbn1cblxuY29uc3QgZXZtID0gY3JlYXRlU2VsZWN0b3JUcmVlKHtcbiAgLyoqXG4gICAqIGV2bS5zdGF0ZVxuICAgKi9cbiAgc3RhdGU6IChzdGF0ZSkgPT4gc3RhdGUuZXZtLFxuXG4gIC8qKlxuICAgKiBldm0uaW5mb1xuICAgKi9cbiAgaW5mbzoge1xuICAgIC8qKlxuICAgICAqIGV2bS5pbmZvLmNvbnRleHRzXG4gICAgICovXG4gICAgY29udGV4dHM6IGNyZWF0ZUxlYWYoWycvc3RhdGUnXSwgKHN0YXRlKSA9PiBzdGF0ZS5pbmZvLmNvbnRleHRzLmJ5Q29udGV4dCksXG5cbiAgICAvKipcbiAgICAgKiBldm0uaW5mby5pbnN0YW5jZXNcbiAgICAgKi9cbiAgICBpbnN0YW5jZXM6IGNyZWF0ZUxlYWYoWycvc3RhdGUnXSwgKHN0YXRlKSA9PiBzdGF0ZS5pbmZvLmluc3RhbmNlcy5ieUFkZHJlc3MpLFxuXG4gICAgLyoqXG4gICAgICogZXZtLmluZm8uYmluYXJpZXNcbiAgICAgKi9cbiAgICBiaW5hcmllczoge1xuICAgICAgXzogY3JlYXRlTGVhZihbJy9zdGF0ZSddLCAoc3RhdGUpID0+IHN0YXRlLmluZm8uY29udGV4dHMuYnlCaW5hcnkpLFxuXG4gICAgICAvKipcbiAgICAgICAqIGV2bS5pbmZvLmJpbmFyaWVzLnNlYXJjaFxuICAgICAgICpcbiAgICAgICAqIHJldHVybnMgZnVuY3Rpb24gKGJpbmFyeSkgPT4gY29udGV4dFxuICAgICAgICovXG4gICAgICBzZWFyY2g6IGNyZWF0ZUxlYWYoWycuL18nXSwgKGJpbmFyaWVzKSA9PiB7XG4gICAgICAgIC8vIEhBQ0sgaWdub3JlIGxpbmsgcmVmZXJlbmNlcyBmb3Igc2VhcmNoXG4gICAgICAgIC8vIGxpbmsgcmVmZXJlbmNlcyBjb21lIGluIHR3byBmb3Jtczogd2l0aCB1bmRlcnNjb3JlcyBvciBhbGwgemVyb2VzXG4gICAgICAgIC8vIHRoZSB1bmRlcnNjb3JlIGZvcm1hdCBpcyB1c2VkIGJ5IFRydWZmbGUgdG8gcmVmZXJlbmNlIGxpbmtzIGJ5IG5hbWVcbiAgICAgICAgLy8gemVyb2VzIGFyZSB1c2VkIGJ5IHNvbGMgZGlyZWN0bHksIGFzIGxpYnJhcmllcyBpbmplY3QgdGhlaXIgb3duXG4gICAgICAgIC8vIGFkZHJlc3MgYXQgQ1JFQVRFLXRpbWVcbiAgICAgICAgY29uc3QgdG9SZWdFeHAgPSAoYmluYXJ5KSA9PlxuICAgICAgICAgIG5ldyBSZWdFeHAoYF4ke2JpbmFyeS5yZXBsYWNlKC9fXy57Mzh9fDB7NDB9L2csIFwiLns0MH1cIil9YClcblxuICAgICAgICBsZXQgbWF0Y2hlcnMgPSBPYmplY3QuZW50cmllcyhiaW5hcmllcylcbiAgICAgICAgICAubWFwKCAoW2JpbmFyeSwge2NvbnRleHR9XSkgPT4gKHtcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICByZWdleDogdG9SZWdFeHAoYmluYXJ5KVxuICAgICAgICAgIH0pKVxuXG4gICAgICAgIHJldHVybiAoYmluYXJ5KSA9PiBtYXRjaGVyc1xuICAgICAgICAgIC5maWx0ZXIoICh7IGNvbnRleHQsIHJlZ2V4IH0pID0+IGJpbmFyeS5tYXRjaChyZWdleCkgKVxuICAgICAgICAgIC5tYXAoICh7IGNvbnRleHQgfSkgPT4gKHsgY29udGV4dCB9KSApXG4gICAgICAgICAgWzBdIHx8IG51bGw7XG4gICAgICB9KVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogZXZtLmN1cnJlbnRcbiAgICovXG4gIGN1cnJlbnQ6IHtcblxuICAgIC8qKlxuICAgICAqIGV2bS5jdXJyZW50LmNhbGxzdGFja1xuICAgICAqL1xuICAgIGNhbGxzdGFjazogKHN0YXRlKSA9PiBzdGF0ZS5ldm0ucHJvYy5jYWxsc3RhY2ssXG5cbiAgICAvKipcbiAgICAgKiBldm0uY3VycmVudC5jYWxsXG4gICAgICovXG4gICAgY2FsbDogY3JlYXRlTGVhZihcbiAgICAgIFtcIi4vY2FsbHN0YWNrXCJdLFxuXG4gICAgICAoc3RhY2spID0+IHN0YWNrLmxlbmd0aCA/IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdIDoge31cbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogZXZtLmN1cnJlbnQuY29udGV4dFxuICAgICAqL1xuICAgIGNvbnRleHQ6IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIuL2NhbGxcIiwgXCIvaW5mby9pbnN0YW5jZXNcIiwgXCIvaW5mby9iaW5hcmllcy9zZWFyY2hcIiwgXCIvaW5mby9jb250ZXh0c1wiXSxcblxuICAgICAgKHthZGRyZXNzLCBiaW5hcnl9LCBpbnN0YW5jZXMsIHNlYXJjaCwgY29udGV4dHMpID0+IHtcbiAgICAgICAgbGV0IHJlY29yZDtcbiAgICAgICAgaWYgKGFkZHJlc3MpIHtcbiAgICAgICAgICByZWNvcmQgPSBpbnN0YW5jZXNbYWRkcmVzc107XG4gICAgICAgICAgaWYgKCFyZWNvcmQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGFkZHJlc3MgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYmluYXJ5ID0gcmVjb3JkLmJpbmFyeVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlY29yZCA9IHNlYXJjaChiaW5hcnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNvbnRleHQgPSBjb250ZXh0c1socmVjb3JkIHx8IHt9KS5jb250ZXh0XTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmNvbnRleHQsXG4gICAgICAgICAgYmluYXJ5XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogZXZtLmN1cnJlbnQuc3RhdGVcbiAgICAgKlxuICAgICAqIGV2bSBzdGF0ZSBpbmZvOiBhcyBvZiBsYXN0IG9wZXJhdGlvbiwgYmVmb3JlIG9wIGRlZmluZWQgaW4gc3RlcFxuICAgICAqL1xuICAgIHN0YXRlOiBPYmplY3QuYXNzaWduKHt9LCAuLi4oXG4gICAgICBbXG4gICAgICAgIFwiZGVwdGhcIixcbiAgICAgICAgXCJlcnJvclwiLFxuICAgICAgICBcImdhc1wiLFxuICAgICAgICBcIm1lbW9yeVwiLFxuICAgICAgICBcInN0YWNrXCIsXG4gICAgICAgIFwic3RvcmFnZVwiXG4gICAgICBdLm1hcCggKHBhcmFtKSA9PiAoe1xuICAgICAgICBbcGFyYW1dOiBjcmVhdGVMZWFmKFt0cmFjZS5zdGVwXSwgKHN0ZXApID0+IHN0ZXBbcGFyYW1dKVxuICAgICAgfSkpXG4gICAgKSksXG5cbiAgICAvKipcbiAgICAgKiBldm0uY3VycmVudC5zdGVwXG4gICAgICovXG4gICAgc3RlcDogY3JlYXRlU3RlcFNlbGVjdG9ycyh0cmFjZS5zdGVwLCBcIi4vc3RhdGVcIilcbiAgfSxcblxuICAvKipcbiAgICogZXZtLm5leHRcbiAgICovXG4gIG5leHQ6IHtcblxuICAgIC8qKlxuICAgICAqIGV2bS5uZXh0LnN0YXRlXG4gICAgICpcbiAgICAgKiBldm0gc3RhdGUgYXMgYSByZXN1bHQgb2YgbmV4dCBzdGVwIG9wZXJhdGlvblxuICAgICAqL1xuICAgIHN0YXRlOiBPYmplY3QuYXNzaWduKHt9LCAuLi4oXG4gICAgICBbXG4gICAgICAgIFwiZGVwdGhcIixcbiAgICAgICAgXCJlcnJvclwiLFxuICAgICAgICBcImdhc1wiLFxuICAgICAgICBcIm1lbW9yeVwiLFxuICAgICAgICBcInN0YWNrXCIsXG4gICAgICAgIFwic3RvcmFnZVwiXG4gICAgICBdLm1hcCggKHBhcmFtKSA9PiAoe1xuICAgICAgICBbcGFyYW1dOiBjcmVhdGVMZWFmKFt0cmFjZS5uZXh0XSwgKHN0ZXApID0+IHN0ZXBbcGFyYW1dKVxuICAgICAgfSkpXG4gICAgKSksXG5cbiAgICBzdGVwOiBjcmVhdGVTdGVwU2VsZWN0b3JzKHRyYWNlLm5leHQsIFwiLi9zdGF0ZVwiKVxuICB9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgZXZtO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9ldm0vc2VsZWN0b3JzL2luZGV4LmpzIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOnNvbGlkaXR5OnNlbGVjdG9yc1wiKTtcblxuaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3JUcmVlLCBjcmVhdGVMZWFmIH0gZnJvbSBcInJlc2VsZWN0LXRyZWVcIjtcbmltcG9ydCBTb2xpZGl0eVV0aWxzIGZyb20gXCJ0cnVmZmxlLXNvbGlkaXR5LXV0aWxzXCI7XG5pbXBvcnQgQ29kZVV0aWxzIGZyb20gXCJ0cnVmZmxlLWNvZGUtdXRpbHNcIjtcblxuaW1wb3J0IGV2bSBmcm9tIFwibGliL2V2bS9zZWxlY3RvcnNcIjtcblxuZnVuY3Rpb24gZ2V0U291cmNlUmFuZ2UoaW5zdHJ1Y3Rpb24gPSB7fSkge1xuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBpbnN0cnVjdGlvbi5zdGFydCB8fCAwLFxuICAgIGxlbmd0aDogaW5zdHJ1Y3Rpb24ubGVuZ3RoIHx8IDAsXG4gICAgbGluZXM6IGluc3RydWN0aW9uLnJhbmdlIHx8IHtcbiAgICAgIHN0YXJ0OiB7XG4gICAgICAgIGxpbmU6IDAsIGNvbHVtbjogMFxuICAgICAgfSxcbiAgICAgIGVuZDoge1xuICAgICAgICBsaW5lOiAwLCBjb2x1bW46IDBcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmxldCBzb2xpZGl0eSA9IGNyZWF0ZVNlbGVjdG9yVHJlZSh7XG4gIC8qKlxuICAgKiBzb2xpZGl0eS5zdGF0ZVxuICAgKi9cbiAgc3RhdGU6IChzdGF0ZSkgPT4gc3RhdGUuc29saWRpdHksXG5cbiAgLyoqXG4gICAqIHNvbGlkaXR5LmluZm9cbiAgICovXG4gIGluZm86IHtcbiAgICAvKipcbiAgICAgKiBzb2xpZGl0eS5pbmZvLnNvdXJjZXNcbiAgICAgKi9cbiAgICBzb3VyY2VzOiBjcmVhdGVMZWFmKFsnL3N0YXRlJ10sIChzdGF0ZSkgPT4gc3RhdGUuaW5mby5zb3VyY2VzLmJ5SWQpLFxuXG4gICAgLyoqXG4gICAgICogc29saWRpdHkuaW5mby5zb3VyY2VNYXBzXG4gICAgICovXG4gICAgc291cmNlTWFwczogY3JlYXRlTGVhZihbJy9zdGF0ZSddLCAoc3RhdGUpID0+IHN0YXRlLmluZm8uc291cmNlTWFwcy5ieUNvbnRleHQpXG4gIH0sXG5cbiAgLyoqXG4gICAqIHNvbGlkaXR5LmN1cnJlbnRcbiAgICovXG4gIGN1cnJlbnQ6IHtcblxuICAgIC8qKlxuICAgICAqIHNvbGlkaXR5LmN1cnJlbnQuc291cmNlTWFwXG4gICAgICovXG4gICAgc291cmNlTWFwOiBjcmVhdGVMZWFmKFxuICAgICAgW2V2bS5jdXJyZW50LmNvbnRleHQsIFwiL2luZm8vc291cmNlTWFwc1wiXSxcblxuICAgICAgKHtjb250ZXh0fSwgc291cmNlTWFwcykgPT4gc291cmNlTWFwc1tjb250ZXh0XSB8fCB7fVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBzb2xpZGl0eS5jdXJyZW50LmZ1bmN0aW9uRGVwdGhcbiAgICAgKi9cbiAgICBmdW5jdGlvbkRlcHRoOiAoc3RhdGUpID0+IHN0YXRlLnNvbGlkaXR5LnByb2MuZnVuY3Rpb25EZXB0aCxcblxuICAgIC8qKlxuICAgICAqIHNvbGlkaXR5LmN1cnJlbnQuaW5zdHJ1Y3Rpb25zXG4gICAgICovXG4gICAgaW5zdHJ1Y3Rpb25zOiBjcmVhdGVMZWFmKFxuICAgICAgW1wiL2luZm8vc291cmNlc1wiLCBldm0uY3VycmVudC5jb250ZXh0LCBcIi4vc291cmNlTWFwXCJdLFxuXG4gICAgICAoc291cmNlcywge2JpbmFyeX0sIHtzb3VyY2VNYXB9KSA9PiB7XG4gICAgICAgIGlmICghYmluYXJ5KSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGluc3RydWN0aW9ucyA9IENvZGVVdGlscy5wYXJzZUNvZGUoYmluYXJ5KTtcblxuICAgICAgICBpZiAoIXNvdXJjZU1hcCkge1xuICAgICAgICAgIC8vIExldCdzIGNyZWF0ZSBhIHNvdXJjZSBtYXAgdG8gdXNlIHNpbmNlIG5vbmUgZXhpc3RzLiBUaGlzIHNvdXJjZSBtYXBcbiAgICAgICAgICAvLyBtYXBzIGp1c3QgYXMgbWFueSByYW5nZXMgYXMgdGhlcmUgYXJlIGluc3RydWN0aW9ucywgYW5kIGVuc3VyZXMgZXZlcnlcbiAgICAgICAgICAvLyBpbnN0cnVjdGlvbiBpcyBtYXJrZWQgYXMgXCJqdW1waW5nIG91dFwiLiBUaGlzIHdpbGwgZW5zdXJlIGFsbFxuICAgICAgICAgIC8vIGF2YWlsYWJsZSBkZWJ1Z2dlciBjb21tYW5kcyBzdGVwIG9uZSBpbnN0cnVjdGlvbiBhdCBhIHRpbWUuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBUaGlzIGlzIGtpbmRvZiBhIGhhY2s7IHBlcmhhcHMgdGhpcyBzaG91bGQgYmUgYnJva2VuIG91dCBpbnRvIHNlcGFyYXRlXG4gICAgICAgICAgLy8gY29udGV4dCB0eXBlcy4gVE9ET1xuICAgICAgICAgIHNvdXJjZU1hcCA9IFwiXCI7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnN0cnVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHNvdXJjZU1hcCArPSBpICsgXCI6XCIgKyBpICsgXCI6MTotMTtcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGluZUFuZENvbHVtbk1hcHBpbmdzID0gT2JqZWN0LmFzc2lnbih7fSxcbiAgICAgICAgICAuLi5PYmplY3QuZW50cmllcyhzb3VyY2VzKS5tYXAoXG4gICAgICAgICAgICAoW2lkLCB7c291cmNlfV0pID0+ICh7XG4gICAgICAgICAgICAgIFtpZF06IFNvbGlkaXR5VXRpbHMuZ2V0Q2hhcmFjdGVyT2Zmc2V0VG9MaW5lQW5kQ29sdW1uTWFwcGluZyhzb3VyY2UgfHwgXCJcIilcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgICB2YXIgaHVtYW5SZWFkYWJsZVNvdXJjZU1hcCA9IFNvbGlkaXR5VXRpbHMuZ2V0SHVtYW5SZWFkYWJsZVNvdXJjZU1hcChzb3VyY2VNYXApO1xuXG4gICAgICAgIGxldCBwcmltYXJ5RmlsZSA9IGh1bWFuUmVhZGFibGVTb3VyY2VNYXBbMF0uZmlsZTtcbiAgICAgICAgZGVidWcoXCJwcmltYXJ5RmlsZSAlb1wiLCBwcmltYXJ5RmlsZSk7XG5cbiAgICAgICAgcmV0dXJuIGluc3RydWN0aW9uc1xuICAgICAgICAgIC5tYXAoIChpbnN0cnVjdGlvbiwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIC8vIGxvb2t1cCBzb3VyY2UgbWFwIGJ5IGluZGV4IGFuZCBhZGQgYGluZGV4YCBwcm9wZXJ0eSB0b1xuICAgICAgICAgICAgLy8gaW5zdHJ1Y3Rpb25cbiAgICAgICAgICAgIC8vXG5cbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZU1hcCA9IGh1bWFuUmVhZGFibGVTb3VyY2VNYXBbaW5kZXhdIHx8IHt9O1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBpbnN0cnVjdGlvbjogeyAuLi5pbnN0cnVjdGlvbiwgaW5kZXggfSxcbiAgICAgICAgICAgICAgc291cmNlTWFwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5tYXAoICh7IGluc3RydWN0aW9uLCBzb3VyY2VNYXB9KSA9PiB7XG4gICAgICAgICAgICAvLyBhZGQgc291cmNlIG1hcCBpbmZvcm1hdGlvbiB0byBpbnN0cnVjdGlvbiwgb3IgZGVmYXVsdHNcbiAgICAgICAgICAgIC8vXG5cbiAgICAgICAgICAgIGNvbnN0IHsganVtcCwgc3RhcnQgPSAwLCBsZW5ndGggPSAwLCBmaWxlID0gcHJpbWFyeUZpbGUgfSA9IHNvdXJjZU1hcDtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVBbmRDb2x1bW5NYXBwaW5nID0gbGluZUFuZENvbHVtbk1hcHBpbmdzW2ZpbGVdIHx8IHt9O1xuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSB7XG4gICAgICAgICAgICAgIHN0YXJ0OiBsaW5lQW5kQ29sdW1uTWFwcGluZ1tzdGFydF0gfHxcbiAgICAgICAgICAgICAgICB7IGxpbmU6IG51bGwsIGNvbHVtbjogbnVsbCB9LFxuICAgICAgICAgICAgICBlbmQ6IGxpbmVBbmRDb2x1bW5NYXBwaW5nW3N0YXJ0ICsgbGVuZ3RoXSB8fFxuICAgICAgICAgICAgICAgIHsgbGluZTogbnVsbCwgY29sdW1uOiBudWxsIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChyYW5nZS5zdGFydC5saW5lID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIGRlYnVnKFwic291cmNlTWFwICVvXCIsIHNvdXJjZU1hcCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLmluc3RydWN0aW9uLFxuXG4gICAgICAgICAgICAgIGp1bXAsXG4gICAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgICBsZW5ndGgsXG4gICAgICAgICAgICAgIGZpbGUsXG4gICAgICAgICAgICAgIHJhbmdlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIHNvbGlkaXR5LmN1cnJlbnQuaW5zdHJ1Y3Rpb25BdFByb2dyYW1Db3VudGVyXG4gICAgICovXG4gICAgaW5zdHJ1Y3Rpb25BdFByb2dyYW1Db3VudGVyOiBjcmVhdGVMZWFmKFxuICAgICAgW1wiLi9pbnN0cnVjdGlvbnNcIl0sXG5cbiAgICAgIChpbnN0cnVjdGlvbnMpID0+IHtcbiAgICAgICAgbGV0IG1hcCA9IFtdO1xuICAgICAgICBpbnN0cnVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbihpbnN0cnVjdGlvbikge1xuICAgICAgICAgIG1hcFtpbnN0cnVjdGlvbi5wY10gPSBpbnN0cnVjdGlvbjtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gZmlsbCBpbiBnYXBzIGluIG1hcCBieSBkZWZhdWx0aW5nIHRvIHRoZSBsYXN0IGtub3duIGluc3RydWN0aW9uXG4gICAgICAgIGxldCBsYXN0U2VlbiA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IFtwYywgaW5zdHJ1Y3Rpb25dIG9mIG1hcC5lbnRyaWVzKCkpIHtcbiAgICAgICAgICBpZiAoaW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgICAgIGxhc3RTZWVuID0gaW5zdHJ1Y3Rpb247XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hcFtwY10gPSBsYXN0U2VlbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgIH1cbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogc29saWRpdHkuY3VycmVudC5pbnN0cnVjdGlvblxuICAgICAqL1xuICAgIGluc3RydWN0aW9uOiBjcmVhdGVMZWFmKFxuICAgICAgW1wiLi9pbnN0cnVjdGlvbkF0UHJvZ3JhbUNvdW50ZXJcIiwgZXZtLmN1cnJlbnQuc3RlcC5wcm9ncmFtQ291bnRlcl0sXG5cbiAgICAgIChtYXAsIHBjKSA9PiBtYXBbcGNdIHx8IHt9XG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIHNvbGlkaXR5LmN1cnJlbnQuc291cmNlXG4gICAgICovXG4gICAgc291cmNlOiBjcmVhdGVMZWFmKFxuICAgICAgW1wiL2luZm8vc291cmNlc1wiLCBcIi4vaW5zdHJ1Y3Rpb25cIl0sXG5cbiAgICAgIChzb3VyY2VzLCB7ZmlsZTogaWR9KSA9PiBzb3VyY2VzW2lkXSB8fCB7fVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBzb2xpZGl0eS5jdXJyZW50LnNvdXJjZVJhbmdlXG4gICAgICovXG4gICAgc291cmNlUmFuZ2U6IGNyZWF0ZUxlYWYoW1wiLi9pbnN0cnVjdGlvblwiXSwgZ2V0U291cmNlUmFuZ2UpLFxuXG4gICAgLyoqXG4gICAgICogc29saWRpdHkuY3VycmVudC5pc1NvdXJjZVJhbmdlRmluYWxcbiAgICAgKi9cbiAgICBpc1NvdXJjZVJhbmdlRmluYWw6IGNyZWF0ZUxlYWYoXG4gICAgICBbXG4gICAgICAgIFwiLi9pbnN0cnVjdGlvbkF0UHJvZ3JhbUNvdW50ZXJcIixcbiAgICAgICAgZXZtLmN1cnJlbnQuc3RlcC5wcm9ncmFtQ291bnRlcixcbiAgICAgICAgZXZtLm5leHQuc3RlcC5wcm9ncmFtQ291bnRlclxuICAgICAgXSxcblxuICAgICAgKG1hcCwgY3VycmVudCwgbmV4dCkgPT4ge1xuICAgICAgICBpZiAoIW1hcFtuZXh0XSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudCA9IG1hcFtjdXJyZW50XTtcbiAgICAgICAgbmV4dCA9IG1hcFtuZXh0XTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGN1cnJlbnQuc3RhcnQgIT0gbmV4dC5zdGFydCB8fFxuICAgICAgICAgIGN1cnJlbnQubGVuZ3RoICE9IG5leHQubGVuZ3RoIHx8XG4gICAgICAgICAgY3VycmVudC5maWxlICE9IG5leHQuZmlsZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBzb2xpZGl0eS5jdXJyZW50LmlzTXVsdGlsaW5lXG4gICAgICovXG4gICAgaXNNdWx0aWxpbmU6IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIuL3NvdXJjZVJhbmdlXCJdLFxuXG4gICAgICAoIHtsaW5lc30gKSA9PiBsaW5lcy5zdGFydC5saW5lICE9IGxpbmVzLmVuZC5saW5lXG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIHNvbGlkaXR5LmN1cnJlbnQud2lsbEp1bXBcbiAgICAgKi9cbiAgICB3aWxsSnVtcDogY3JlYXRlTGVhZihbZXZtLmN1cnJlbnQuc3RlcC5pc0p1bXBdLCAoaXNKdW1wKSA9PiBpc0p1bXApLFxuXG4gICAgLyoqXG4gICAgICogc29saWRpdHkuY3VycmVudC5qdW1wRGlyZWN0aW9uXG4gICAgICovXG4gICAganVtcERpcmVjdGlvbjogY3JlYXRlTGVhZihcbiAgICAgIFtcIi4vaW5zdHJ1Y3Rpb25cIl0sIChpID0ge30pID0+IChpLmp1bXAgfHwgXCItXCIpXG4gICAgKVxuICB9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgc29saWRpdHk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3NvbGlkaXR5L3NlbGVjdG9ycy9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlZHV4XCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwicmVkdXhcIlxuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6ZGF0YTpkZWNvZGU6dXRpbHNcIik7XG5cbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gXCJiaWdudW1iZXIuanNcIjtcbmltcG9ydCBXZWIzIGZyb20gXCJ3ZWIzXCI7XG5cbmV4cG9ydCBjb25zdCBXT1JEX1NJWkUgPSAweDIwO1xuZXhwb3J0IGNvbnN0IE1BWF9XT1JEID0gbmV3IEJpZ051bWJlcigyKS5wb3coMjU2KS5taW51cygxKTtcblxuLyoqXG4gKiByZWN1cnNpdmVseSBjb252ZXJ0cyBiaWcgbnVtYmVycyBpbnRvIHNvbWV0aGluZyBuaWNlciB0byBsb29rIGF0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhbkJpZ051bWJlcnModmFsdWUpIHtcbiAgaWYgKEJpZ051bWJlci5pc0JpZ051bWJlcih2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUudG9OdW1iZXIoKTtcblxuICB9IGVsc2UgaWYgKHZhbHVlICYmIHZhbHVlLm1hcCAhPSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdmFsdWUubWFwKCAoaW5uZXIpID0+IGNsZWFuQmlnTnVtYmVycyhpbm5lcikgKTtcblxuICB9IGVsc2UgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICB7fSwgLi4uT2JqZWN0LmVudHJpZXModmFsdWUpXG4gICAgICAgIC5tYXAoIChba2V5LCBpbm5lcl0pID0+ICh7IFtrZXldOiBjbGVhbkJpZ051bWJlcnMoaW5uZXIpIH0pIClcbiAgICApO1xuXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0eXBlSWRlbnRpZmllcihkZWZpbml0aW9uKSB7XG4gIHJldHVybiBkZWZpbml0aW9uLnR5cGVEZXNjcmlwdGlvbnMudHlwZUlkZW50aWZpZXI7XG59XG5cbi8qKlxuICogcmV0dXJucyBiYXNpYyB0eXBlIGNsYXNzIGZvciBhIHZhcmlhYmxlIGRlZmluaXRpb24gbm9kZVxuICogZS5nLjpcbiAqICBgdF91aW50MjU2YCBiZWNvbWVzIGB1aW50YFxuICogIGB0X3N0cnVjdCRfVGhpbmdfJDIwX21lbW9yeV9wdHJgIGJlY29tZXMgYHN0cnVjdGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHR5cGVDbGFzcyhkZWZpbml0aW9uKSB7XG4gIHJldHVybiB0eXBlSWRlbnRpZmllcihkZWZpbml0aW9uKS5tYXRjaCgvdF8oW14kXzAtOV0rKS8pWzFdO1xufVxuXG4vKipcbiAqIEFsbG9jYXRlIHN0b3JhZ2UgZm9yIGdpdmVuIHZhcmlhYmxlIGRlY2xhcmF0aW9uc1xuICpcbiAqIFBvc3Rjb25kaXRpb246IHN0YXJ0cyBhIG5ldyBzbG90IGFuZCBvY2N1cGllcyB3aG9sZSBzbG90c1xuICovXG5leHBvcnQgZnVuY3Rpb24gYWxsb2NhdGVEZWNsYXJhdGlvbnMoXG4gIGRlY2xhcmF0aW9ucyxcbiAgcmVmcyxcbiAgc2xvdCA9IDAsXG4gIGluZGV4ID0gV09SRF9TSVpFIC0gMSxcbiAgcGF0aCA9IFtdXG4pIHtcbiAgaWYgKGluZGV4IDwgV09SRF9TSVpFIC0gMSkgeyAgLy8gc3RhcnRzIGEgbmV3IHNsb3RcbiAgICBzbG90Kys7XG4gICAgaW5kZXggPSBXT1JEX1NJWkUgLSAxO1xuICB9XG5cbiAgbGV0IHBhcmVudEZyb20gPSB7IHNsb3QsIGluZGV4OiAwIH07XG4gIHZhciBwYXJlbnRUbyA9IHsgc2xvdCwgaW5kZXg6IFdPUkRfU0laRSAtIDEgfTtcbiAgbGV0IG1hcHBpbmcgPSB7fTtcblxuICBmb3IgKGxldCBkZWNsYXJhdGlvbiBvZiBkZWNsYXJhdGlvbnMpIHtcbiAgICBsZXQgeyBmcm9tLCB0bywgbmV4dCwgY2hpbGRyZW4gfSA9XG4gICAgICBhbGxvY2F0ZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9uLCByZWZzLCBzbG90LCBpbmRleCk7XG5cbiAgICBtYXBwaW5nW2RlY2xhcmF0aW9uLmlkXSA9IHsgZnJvbSwgdG8sIG5hbWU6IGRlY2xhcmF0aW9uLm5hbWUgfTtcbiAgICBpZiAoY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgbWFwcGluZ1tkZWNsYXJhdGlvbi5pZF0uY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICB9XG5cbiAgICBzbG90ID0gbmV4dC5zbG90O1xuICAgIGluZGV4ID0gbmV4dC5pbmRleDtcblxuICAgIHBhcmVudFRvID0geyBzbG90OiB0by5zbG90LCBpbmRleDogV09SRF9TSVpFIC0gMSB9O1xuICB9XG5cbiAgaWYgKGluZGV4IDwgV09SRF9TSVpFIC0gMSkge1xuICAgIHNsb3QrKztcbiAgICBpbmRleCA9IFdPUkRfU0laRSAtIDE7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGZyb206IHBhcmVudEZyb20sXG4gICAgdG86IHBhcmVudFRvLFxuICAgIG5leHQ6IHsgc2xvdCwgaW5kZXggfSxcbiAgICBjaGlsZHJlbjogbWFwcGluZ1xuICB9O1xufVxuXG5mdW5jdGlvbiBhbGxvY2F0ZVZhbHVlKHNsb3QsIGluZGV4LCBieXRlcykge1xuICBsZXQgZnJvbSA9IGluZGV4IC0gYnl0ZXMgKyAxID49IDAgP1xuICAgIHsgc2xvdCwgaW5kZXg6IGluZGV4IC0gYnl0ZXMgKyAxIH0gOlxuICAgIHsgc2xvdDogc2xvdCArIDEsIGluZGV4OiBXT1JEX1NJWkUgLSBieXRlcyB9O1xuXG4gIGxldCB0byA9IHsgc2xvdDogZnJvbS5zbG90LCBpbmRleDogZnJvbS5pbmRleCArIGJ5dGVzIC0gMSB9O1xuXG4gIGxldCBuZXh0ID0gZnJvbS5pbmRleCA9PSAwID9cbiAgICB7IHNsb3Q6IGZyb20uc2xvdCArIDEsIGluZGV4OiBXT1JEX1NJWkUgLSAxIH0gOlxuICAgIHsgc2xvdDogZnJvbS5zbG90LCBpbmRleDogZnJvbS5pbmRleCAtIDEgfTtcblxuICByZXR1cm4geyBmcm9tLCB0bywgbmV4dCB9O1xufVxuXG5mdW5jdGlvbiBhbGxvY2F0ZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9uLCByZWZzLCBzbG90LCBpbmRleCkge1xuICBsZXQgZGVmaW5pdGlvbiA9IHJlZnNbZGVjbGFyYXRpb24uaWRdLmRlZmluaXRpb247XG4gIHZhciBieXRlU2l6ZSA9IHN0b3JhZ2VTaXplKGRlZmluaXRpb24pOyAgLy8geXVtXG5cbiAgaWYgKHR5cGVDbGFzcyhkZWZpbml0aW9uKSAhPSBcInN0cnVjdFwiKSB7XG4gICAgcmV0dXJuIGFsbG9jYXRlVmFsdWUoc2xvdCwgaW5kZXgsIGJ5dGVTaXplKTtcbiAgfVxuXG4gIGxldCBzdHJ1Y3QgPSByZWZzW2RlZmluaXRpb24udHlwZU5hbWUucmVmZXJlbmNlZERlY2xhcmF0aW9uXTtcbiAgZGVidWcoXCJzdHJ1Y3Q6ICVPXCIsIHN0cnVjdCk7XG5cbiAgbGV0IHJlc3VsdCA9ICBhbGxvY2F0ZURlY2xhcmF0aW9ucyhzdHJ1Y3QudmFyaWFibGVzIHx8IFtdLCByZWZzLCBzbG90LCBpbmRleCk7XG4gIGRlYnVnKFwic3RydWN0IHJlc3VsdCAlb1wiLCByZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIGUuZy4gdWludDQ4IC0+IDZcbiAqIEByZXR1cm4gc2l6ZSBpbiBieXRlcyBmb3IgZXhwbGljaXQgdHlwZSBzaXplLCBvciBgbnVsbGAgaWYgbm90IHN0YXRlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3BlY2lmaWVkU2l6ZShkZWZpbml0aW9uKSB7XG4gIGxldCBzcGVjaWZpZWQgPSB0eXBlSWRlbnRpZmllcihkZWZpbml0aW9uKS5tYXRjaCgvdF9bYS16XSsoWzAtOV0rKS8pO1xuXG4gIGlmICghc3BlY2lmaWVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBsZXQgbnVtID0gc3BlY2lmaWVkWzFdO1xuXG4gIHN3aXRjaCAodHlwZUNsYXNzKGRlZmluaXRpb24pKSB7XG4gICAgY2FzZSBcImludFwiOlxuICAgIGNhc2UgXCJ1aW50XCI6XG4gICAgICByZXR1cm4gbnVtIC8gODtcblxuICAgIGNhc2UgXCJieXRlc1wiOlxuICAgICAgcmV0dXJuIG51bTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICBkZWJ1ZyhcIlVua25vd24gdHlwZSBmb3Igc2l6ZSBzcGVjaWZpY2F0aW9uOiAlc1wiLCB0eXBlSWRlbnRpZmllcihkZWZpbml0aW9uKSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0b3JhZ2VTaXplKGRlZmluaXRpb24pIHtcbiAgc3dpdGNoICh0eXBlQ2xhc3MoZGVmaW5pdGlvbikpIHtcbiAgICBjYXNlIFwiYm9vbFwiOlxuICAgICAgcmV0dXJuIDE7XG5cbiAgICBjYXNlIFwiYWRkcmVzc1wiOlxuICAgICAgcmV0dXJuIDIwO1xuXG4gICAgY2FzZSBcImludFwiOlxuICAgIGNhc2UgXCJ1aW50XCI6XG4gICAgICAvLyBpcyB0aGlzIGEgSEFDSz8gKFwiMjU2XCIgLyA4KVxuICAgICAgcmV0dXJuIHR5cGVJZGVudGlmaWVyKGRlZmluaXRpb24pLm1hdGNoKC90X1thLXpdKyhbMC05XSspLylbMV0gLyA4O1xuXG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgIGNhc2UgXCJieXRlc1wiOlxuICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgcmV0dXJuIFdPUkRfU0laRTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNSZWZlcmVuY2UoZGVmaW5pdGlvbikge1xuICByZXR1cm4gdHlwZUlkZW50aWZpZXIoZGVmaW5pdGlvbikubWF0Y2goL18obWVtb3J5fHN0b3JhZ2UpKF9wdHIpPyQvKSAhPSBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVmZXJlbmNlVHlwZShkZWZpbml0aW9uKSB7XG4gIHJldHVybiB0eXBlSWRlbnRpZmllcihkZWZpbml0aW9uKS5tYXRjaCgvXyhbXl9dKykoX3B0cik/JC8pWzFdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmFzZURlZmluaXRpb24oZGVmaW5pdGlvbikge1xuICBsZXQgYmFzZUlkZW50aWZpZXIgPSB0eXBlSWRlbnRpZmllcihkZWZpbml0aW9uKVxuICAgIC8vIGZpcnN0IGRvbGxhciBzaWduICAgICBsYXN0IGRvbGxhciBzaWduXG4gICAgLy8gICBgLS0tLS0tLS0tLiAgICAgICAsLS0tJ1xuICAgIC5tYXRjaCgvXlteJF0rXFwkXyguKylfXFwkW14kXSskLylbMV1cbiAgICAvLyAgICAgICAgICAgICAgYC0tLS0nIGdyZWVkeSBtYXRjaFxuXG4gIC8vIEhBQ0sgLSBpbnRlcm5hbCB0eXBlcyBmb3IgbWVtb3J5IG9yIHN0b3JhZ2UgYWxzbyBzZWVtIHRvIGJlIHBvaW50ZXJzXG4gIGlmIChiYXNlSWRlbnRpZmllci5tYXRjaCgvXyhtZW1vcnl8c3RvcmFnZSkkLykgIT0gbnVsbCkge1xuICAgIGJhc2VJZGVudGlmaWVyID0gYCR7YmFzZUlkZW50aWZpZXJ9X3B0cmA7XG4gIH1cblxuICAvLyBhbm90aGVyIEhBQ0sgLSB3ZSBnZXQgYXdheSB3aXRoIGl0IGJlY2F1c2V3ZSdyZSBvbmx5IHVzaW5nIHRoYXQgb25lIHByb3BlcnR5XG4gIHJldHVybiB7XG4gICAgdHlwZURlc2NyaXB0aW9uczoge1xuICAgICAgdHlwZUlkZW50aWZpZXI6IGJhc2VJZGVudGlmaWVyXG4gICAgfVxuICB9O1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiB0b0JpZ051bWJlcihieXRlcykge1xuICBpZiAoYnl0ZXMgPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYnl0ZXMgPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKGJ5dGVzLCAxNik7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGJ5dGVzID09IFwibnVtYmVyXCIgfHwgQmlnTnVtYmVyLmlzQmlnTnVtYmVyKGJ5dGVzKSkge1xuICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKGJ5dGVzKTtcbiAgfSBlbHNlIGlmIChieXRlcy5yZWR1Y2UpIHtcbiAgICByZXR1cm4gYnl0ZXMucmVkdWNlKFxuICAgICAgKG51bSwgYnl0ZSkgPT4gbnVtLnRpbWVzKDB4MTAwKS5wbHVzKGJ5dGUpLFxuICAgICAgbmV3IEJpZ051bWJlcigwKVxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvU2lnbmVkQmlnTnVtYmVyKGJ5dGVzKSB7XG4gIGlmIChieXRlc1swXSA8IDBiMTAwMDAwMDApIHsgIC8vIGZpcnN0IGJpdCBpcyAwXG4gICAgcmV0dXJuIHRvQmlnTnVtYmVyKGJ5dGVzKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdG9CaWdOdW1iZXIoYnl0ZXMubWFwKCAoYikgPT4gMHhmZiAtIGIgKSkucGx1cygxKS5uZWdhdGVkKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0gYnl0ZXMgLSBVaW50OEFycmF5XG4gKiBAcGFyYW0gbGVuZ3RoIC0gZGVzaXJlZCBieXRlIGxlbmd0aCAocGFkIHdpdGggemVyb2VzKVxuICogQHBhcmFtIHRyaW0gLSBvbWl0IGxlYWRpbmcgemVyb2VzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0hleFN0cmluZyhieXRlcywgbGVuZ3RoID0gMCwgdHJpbSA9IGZhbHNlKSB7XG4gIGlmICh0eXBlb2YgbGVuZ3RoID09IFwiYm9vbGVhblwiKSB7XG4gICAgdHJpbSA9IGxlbmd0aDtcbiAgICBsZW5ndGggPSAwO1xuICB9XG5cbiAgaWYgKEJpZ051bWJlci5pc0JpZ051bWJlcihieXRlcykpIHtcbiAgICBieXRlcyA9IHRvQnl0ZXMoYnl0ZXMpO1xuICB9XG5cbiAgY29uc3QgcGFkID0gKHMpID0+IGAke1wiMDBcIi5zbGljZSgwLCAyIC0gcy5sZW5ndGgpfSR7c31gXG5cbiAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwICAxICAyICAzICA0XG4gIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCAgMSAgMiAgMyAgNCAgNSAgNiAgN1xuICAvLyBieXRlcy5sZW5ndGg6ICAgICAgICA1ICAtICAweCggICAgICAgICAgZTUgYzIgYWEgMDkgMTEgKVxuICAvLyBsZW5ndGggKHByZWZlcnJlZCk6ICA4ICAtICAweCggMDAgMDAgMDAgZTUgYzIgYWEgMDkgMTEgKVxuICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYC0tLi0tLSdcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0IDNcbiAgaWYgKGJ5dGVzLmxlbmd0aCA8IGxlbmd0aCkge1xuICAgIGxldCBwcmlvciA9IGJ5dGVzO1xuICAgIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcblxuICAgIGJ5dGVzLnNldChwcmlvciwgbGVuZ3RoIC0gcHJpb3IubGVuZ3RoKTtcbiAgfVxuXG4gIGRlYnVnKFwiYnl0ZXM6ICVvXCIsIGJ5dGVzKTtcblxuICBsZXQgc3RyaW5nID0gYnl0ZXMucmVkdWNlKFxuICAgIChzdHIsIGJ5dGUpID0+IGAke3N0cn0ke3BhZChieXRlLnRvU3RyaW5nKDE2KSl9YCwgXCJcIlxuICApO1xuXG4gIGlmICh0cmltKSB7XG4gICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoL14oMDApKy8sIFwiXCIpO1xuICB9XG5cbiAgaWYgKHN0cmluZy5sZW5ndGggPT0gMCkge1xuICAgIHN0cmluZyA9IFwiMDBcIjtcbiAgfVxuXG4gIHJldHVybiBgMHgke3N0cmluZ31gO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9CeXRlcyhudW1iZXIsIGxlbmd0aCA9IDApIHtcbiAgaWYgKG51bWJlciA8IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBsZXQgaGV4ID0gbnVtYmVyLnRvU3RyaW5nKDE2KTtcbiAgaWYgKGhleC5sZW5ndGggJSAyID09IDEpIHtcbiAgICBoZXggPSBgMCR7aGV4fWA7XG4gIH1cblxuICBsZXQgYnl0ZXMgPSBuZXcgVWludDhBcnJheShcbiAgICBoZXgubWF0Y2goLy57Mn0vZylcbiAgICAgIC5tYXAoIChieXRlKSA9PiBwYXJzZUludChieXRlLCAxNikgKVxuICApO1xuXG4gIGlmIChieXRlcy5sZW5ndGggPCBsZW5ndGgpIHtcbiAgICBsZXQgcHJpb3IgPSBieXRlcztcbiAgICBieXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgYnl0ZXMuc2V0KHByaW9yLCBsZW5ndGggLSBwcmlvci5sZW5ndGgpO1xuICB9XG5cbiAgcmV0dXJuIGJ5dGVzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24ga2VjY2FrMjU2KC4uLmFyZ3MpIHtcbiAgbGV0IHdlYjMgPSBuZXcgV2ViMygpO1xuXG4gIGFyZ3MgPSBhcmdzLm1hcCggKGFyZykgPT4ge1xuICAgIGlmICh0eXBlb2YgYXJnID09IFwibnVtYmVyXCIgfHwgQmlnTnVtYmVyLmlzQmlnTnVtYmVyKGFyZykpIHtcbiAgICAgIHJldHVybiB0b0hleFN0cmluZyh0b0J5dGVzKGFyZywgV09SRF9TSVpFKSkuc2xpY2UoMilcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcgPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIHdlYjMudG9IZXgoYXJnKS5zbGljZSgyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICB9KTtcblxuICBsZXQgc2hhID0gd2ViMy5zaGEzKGFyZ3Muam9pbignJyksIHsgZW5jb2Rpbmc6ICdoZXgnIH0pO1xuICBkZWJ1ZyhcInNoYSAlb1wiLCBzaGEpO1xuICByZXR1cm4gdG9CaWdOdW1iZXIoc2hhKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvZGF0YS9kZWNvZGUvdXRpbHMuanMiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6YXN0OnNlbGVjdG9yc1wiKTtcblxuaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3JUcmVlLCBjcmVhdGVMZWFmIH0gZnJvbSBcInJlc2VsZWN0LXRyZWVcIjtcbmltcG9ydCBqc29ucG9pbnRlciBmcm9tIFwianNvbi1wb2ludGVyXCI7XG5cbmltcG9ydCBzb2xpZGl0eSBmcm9tIFwibGliL3NvbGlkaXR5L3NlbGVjdG9yc1wiO1xuXG5pbXBvcnQgeyBmaW5kUmFuZ2UgfSBmcm9tIFwiLi4vbWFwXCI7XG5cblxuLyoqXG4gKiBhc3RcbiAqL1xuY29uc3QgYXN0ID0gY3JlYXRlU2VsZWN0b3JUcmVlKHtcbiAgLyoqXG4gICAqIGFzdC52aWV3c1xuICAgKi9cbiAgdmlld3M6IHtcbiAgICAvKipcbiAgICAgKiBhc3Qudmlld3Muc291cmNlc1xuICAgICAqL1xuICAgIHNvdXJjZXM6IGNyZWF0ZUxlYWYoW3NvbGlkaXR5LmluZm8uc291cmNlc10sIHNvdXJjZXMgPT4gc291cmNlcylcbiAgfSxcblxuICAvKipcbiAgICogYXN0LmN1cnJlbnRcbiAgICovXG4gIGN1cnJlbnQ6IHtcblxuICAgIC8qKlxuICAgICAqIGFzdC5jdXJyZW50LnRyZWVcbiAgICAgKlxuICAgICAqIGFzdCBmb3IgY3VycmVudCBzb3VyY2VcbiAgICAgKi9cbiAgICB0cmVlOiBjcmVhdGVMZWFmKFxuICAgICAgW3NvbGlkaXR5LmN1cnJlbnQuc291cmNlXSwgKHthc3R9KSA9PiBhc3RcbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogYXN0LmN1cnJlbnQuaW5kZXhcbiAgICAgKlxuICAgICAqIHNvdXJjZSBJRFxuICAgICAqL1xuICAgIGluZGV4OiBjcmVhdGVMZWFmKFxuICAgICAgW3NvbGlkaXR5LmN1cnJlbnQuc291cmNlXSwgKHtpZH0pID0+IGlkXG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIGFzdC5jdXJyZW50LnBvaW50ZXJcbiAgICAgKlxuICAgICAqIGpzb25wb2ludGVyIGZvciBjdXJyZW50IGFzdCBub2RlXG4gICAgICovXG4gICAgcG9pbnRlcjogY3JlYXRlTGVhZihcbiAgICAgIFtcIi4vdHJlZVwiLCBzb2xpZGl0eS5jdXJyZW50LnNvdXJjZVJhbmdlXSxcblxuICAgICAgKGFzdCwgcmFuZ2UpID0+IGZpbmRSYW5nZShhc3QsIHJhbmdlLnN0YXJ0LCByYW5nZS5sZW5ndGgpXG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIGFzdC5jdXJyZW50Lm5vZGVcbiAgICAgKlxuICAgICAqIGN1cnJlbnQgYXN0IG5vZGUgdG8gZXhlY3V0ZVxuICAgICAqL1xuICAgIG5vZGU6IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIuL3RyZWVcIiwgXCIuL3BvaW50ZXJcIl0sIChhc3QsIHBvaW50ZXIpID0+XG4gICAgICAgIChwb2ludGVyKVxuICAgICAgICAgID8ganNvbnBvaW50ZXIuZ2V0KGFzdCwgcG9pbnRlcilcbiAgICAgICAgICA6IGpzb25wb2ludGVyLmdldChhc3QsIFwiXCIpXG4gICAgKSxcblxuICB9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgYXN0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9hc3Qvc2VsZWN0b3JzL2luZGV4LmpzIiwiZXhwb3J0IGNvbnN0IFNBVkVfU1RFUFMgPSBcIlNBVkVfU1RFUFNcIjtcbmV4cG9ydCBmdW5jdGlvbiBzYXZlU3RlcHMoc3RlcHMpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBTQVZFX1NURVBTLFxuICAgIHN0ZXBzXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBSRUNFSVZFX0FERFJFU1NFUyA9IFwiUkVDRUlWRV9BRERSRVNTRVNcIjtcbmV4cG9ydCBmdW5jdGlvbiByZWNlaXZlQWRkcmVzc2VzKGFkZHJlc3Nlcykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFJFQ0VJVkVfQUREUkVTU0VTLFxuICAgIGFkZHJlc3Nlc1xuICB9O1xufVxuXG5leHBvcnQgY29uc3QgTkVYVCA9IFwiTkVYVFwiO1xuZXhwb3J0IGZ1bmN0aW9uIG5leHQoKSB7XG4gIHJldHVybiB7dHlwZTogTkVYVH07XG59XG5cbmV4cG9ydCBjb25zdCBUSUNLID0gXCJUSUNLXCI7XG5leHBvcnQgZnVuY3Rpb24gdGljaygpIHtcbiAgcmV0dXJuIHt0eXBlOiBUSUNLfTtcbn1cblxuZXhwb3J0IGNvbnN0IFRPQ0sgPSBcIlRPQ0tcIjtcbmV4cG9ydCBmdW5jdGlvbiB0b2NrKCkge1xuICByZXR1cm4ge3R5cGU6IFRPQ0t9O1xufVxuXG5leHBvcnQgY29uc3QgRU5EX09GX1RSQUNFID0gXCJFT1RcIjtcbmV4cG9ydCBmdW5jdGlvbiBlbmRUcmFjZSgpIHtcbiAgcmV0dXJuIHt0eXBlOiBFTkRfT0ZfVFJBQ0V9O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi90cmFjZS9hY3Rpb25zL2luZGV4LmpzIiwiaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3JUcmVlLCBjcmVhdGVMZWFmIH0gZnJvbSBcInJlc2VsZWN0LXRyZWVcIjtcblxubGV0IHRyYWNlID0gY3JlYXRlU2VsZWN0b3JUcmVlKHtcbiAgLyoqXG4gICAqIHRyYWNlLmluZGV4XG4gICAqXG4gICAqIGN1cnJlbnQgc3RlcCBpbmRleFxuICAgKi9cbiAgaW5kZXg6IChzdGF0ZSkgPT4gc3RhdGUudHJhY2UucHJvYy5pbmRleCxcblxuICAvKipcbiAgICogdHJhY2Uuc3RlcHNcbiAgICpcbiAgICogYWxsIHRyYWNlIHN0ZXBzXG4gICAqL1xuICBzdGVwczogKHN0YXRlKSA9PiBzdGF0ZS50cmFjZS5pbmZvLnN0ZXBzLFxuXG4gIC8qKlxuICAgKiB0cmFjZS5zdGVwc1JlbWFpbmluZ1xuICAgKlxuICAgKiBudW1iZXIgb2Ygc3RlcHMgcmVtYWluaW5nIGluIHRyYWNlXG4gICAqL1xuICBzdGVwc1JlbWFpbmluZzogY3JlYXRlTGVhZihcbiAgICBbXCIuL3N0ZXBzXCIsIFwiLi9pbmRleFwiXSwgKHN0ZXBzLCBpbmRleCkgPT4gc3RlcHMubGVuZ3RoIC0gaW5kZXhcbiAgKSxcblxuICAvKipcbiAgICogdHJhY2Uuc3RlcFxuICAgKlxuICAgKiBjdXJyZW50IHRyYWNlIHN0ZXBcbiAgICovXG4gIHN0ZXA6IGNyZWF0ZUxlYWYoXG4gICAgW1wiLi9zdGVwc1wiLCBcIi4vaW5kZXhcIl0sIChzdGVwcywgaW5kZXgpID0+IHN0ZXBzW2luZGV4XVxuICApLFxuXG4gIC8qKlxuICAgKiB0cmFjZS5uZXh0XG4gICAqXG4gICAqIG5leHQgdHJhY2Ugc3RlcCBvciB7fVxuICAgKi9cbiAgbmV4dDogY3JlYXRlTGVhZihcbiAgICBbXCIuL3N0ZXBzXCIsIFwiLi9pbmRleFwiXSwgKHN0ZXBzLCBpbmRleCkgPT5cbiAgICAgIGluZGV4IDwgc3RlcHMubGVuZ3RoIC0gMSA/IHN0ZXBzW2luZGV4ICsgMV0gOiB7fVxuICApXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgdHJhY2U7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3RyYWNlL3NlbGVjdG9ycy9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImJpZ251bWJlci5qc1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImJpZ251bWJlci5qc1wiXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJqc29uLXBvaW50ZXJcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJqc29uLXBvaW50ZXJcIlxuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9rZXlzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9rZXlzXCJcbi8vIG1vZHVsZSBpZCA9IDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydCBjb25zdCBTVEFSVCA9IFwiU0VTU0lPTl9TVEFSVFwiO1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0KHR4SGFzaCwgcHJvdmlkZXIpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBTVEFSVCxcbiAgICB0eEhhc2gsIHByb3ZpZGVyXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBSRUFEWSA9IFwiU0VTU0lPTl9SRUFEWVwiO1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWR5KCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFJFQURZLFxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgRVJST1IgPSBcIlNFU1NJT05fRVJST1JcIjtcbmV4cG9ydCBmdW5jdGlvbiBlcnJvcihlcnJvcikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEVSUk9SLFxuICAgIGVycm9yXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBGSU5JU0ggPSBcIlNFU1NJT05fRklOSVNIXCI7XG5leHBvcnQgZnVuY3Rpb24gZmluaXNoKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEZJTklTSCxcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IFJFQ09SRF9DT05UUkFDVFMgPSBcIlJFQ09SRF9DT05UUkFDVFNcIjtcbmV4cG9ydCBmdW5jdGlvbiByZWNvcmRDb250cmFjdHMoY29udGV4dHMsIHNvdXJjZXMpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBSRUNPUkRfQ09OVFJBQ1RTLFxuICAgIGNvbnRleHRzLCBzb3VyY2VzXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvc2Vzc2lvbi9hY3Rpb25zL2luZGV4LmpzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL3NldFwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9zZXRcIlxuLy8gbW9kdWxlIGlkID0gMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiXG4vLyBtb2R1bGUgaWQgPSAxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvcHJvbWlzZVwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9wcm9taXNlXCJcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydCBjb25zdCBCRUdJTl9TVEVQID0gXCJCRUdJTl9TVEVQXCI7XG5leHBvcnQgZnVuY3Rpb24gYmVnaW5TdGVwKHR5cGUpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBCRUdJTl9TVEVQLFxuICAgIHN0ZXBUeXBlOiB0eXBlXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBBRFZBTkNFID0gXCJBRFZBTkNFXCI7XG5leHBvcnQgZnVuY3Rpb24gYWR2YW5jZSgpIHtcbiAgcmV0dXJuIHt0eXBlOiBBRFZBTkNFfTtcbn1cblxuZXhwb3J0IGNvbnN0IFNURVBfTkVYVCA9IFwiU1RFUF9ORVhUXCI7XG5leHBvcnQgZnVuY3Rpb24gc3RlcE5leHQoKSB7XG4gIHJldHVybiB7dHlwZTogU1RFUF9ORVhUfTtcbn1cblxuZXhwb3J0IGNvbnN0IFNURVBfT1ZFUiA9IFwiU1RFUF9PVkVSXCI7XG5leHBvcnQgZnVuY3Rpb24gc3RlcE92ZXIoKSB7XG4gIHJldHVybiB7dHlwZTogU1RFUF9PVkVSfTtcbn1cblxuZXhwb3J0IGNvbnN0IFNURVBfSU5UTyA9IFwiU1RFUF9JTlRPXCI7XG5leHBvcnQgZnVuY3Rpb24gc3RlcEludG8oKSB7XG4gIHJldHVybiB7dHlwZTogU1RFUF9JTlRPfTtcbn1cblxuZXhwb3J0IGNvbnN0IFNURVBfT1VUID0gXCJTVEVQX09VVFwiO1xuZXhwb3J0IGZ1bmN0aW9uIHN0ZXBPdXQoKSB7XG4gIHJldHVybiB7dHlwZTogU1RFUF9PVVR9O1xufVxuXG5leHBvcnQgY29uc3QgSU5URVJSVVBUID0gXCJJTlRFUlJVUFRcIjtcbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnJ1cHQgKCkge1xuICByZXR1cm4ge3R5cGU6IElOVEVSUlVQVH07XG59XG5cblxuZXhwb3J0IGNvbnN0IENPTlRJTlVFX1VOVElMID0gXCJDT05USU5VRV9VTlRJTFwiO1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnRpbnVlVW50aWwoLi4uYnJlYWtwb2ludHMpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBDT05USU5VRV9VTlRJTCxcbiAgICBicmVha3BvaW50c1xuICB9O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9jb250cm9sbGVyL2FjdGlvbnMvaW5kZXguanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ3ZWIzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwid2ViM1wiXG4vLyBtb2R1bGUgaWQgPSAyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6ZGF0YTpzYWdhc1wiKTtcblxuaW1wb3J0IHsgcHV0LCB0YWtlRXZlcnksIHNlbGVjdCB9IGZyb20gXCJyZWR1eC1zYWdhL2VmZmVjdHNcIjtcbmltcG9ydCBqc29ucG9pbnRlciBmcm9tIFwianNvbi1wb2ludGVyXCI7XG5cbmltcG9ydCB7IHByZWZpeE5hbWUgfSBmcm9tIFwibGliL2hlbHBlcnNcIjtcblxuaW1wb3J0IHsgVElDSyB9IGZyb20gXCJsaWIvdHJhY2UvYWN0aW9uc1wiO1xuaW1wb3J0ICogYXMgYWN0aW9ucyBmcm9tIFwiLi4vYWN0aW9uc1wiO1xuXG5pbXBvcnQgZGF0YSBmcm9tIFwiLi4vc2VsZWN0b3JzXCI7XG5cbmltcG9ydCB7IFdPUkRfU0laRSB9IGZyb20gXCJsaWIvZGF0YS9kZWNvZGUvdXRpbHNcIjtcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gXCJsaWIvZGF0YS9kZWNvZGUvdXRpbHNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uICpzY29wZShub2RlSWQsIHBvaW50ZXIsIHBhcmVudElkLCBzb3VyY2VJZCkge1xuICB5aWVsZCBwdXQoYWN0aW9ucy5zY29wZShub2RlSWQsIHBvaW50ZXIsIHBhcmVudElkLCBzb3VyY2VJZCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gKmRlY2xhcmUobm9kZSkge1xuICB5aWVsZCBwdXQoYWN0aW9ucy5kZWNsYXJlKG5vZGUpKTtcbn1cblxuZnVuY3Rpb24gKnRpY2tTYWdhKCkge1xuICBsZXQge1xuICAgIHRyZWUsXG4gICAgaWQ6IHRyZWVJZCxcbiAgICBub2RlLFxuICAgIHBvaW50ZXJcbiAgfSA9IHlpZWxkIHNlbGVjdChkYXRhLnZpZXdzLmFzdCk7XG5cbiAgbGV0IHNjb3BlcyA9IHlpZWxkIHNlbGVjdChkYXRhLmluZm8uc2NvcGVzKTtcbiAgbGV0IGRlZmluaXRpb25zID0geWllbGQgc2VsZWN0KGRhdGEudmlld3Muc2NvcGVzLmlubGluZWQpO1xuXG4gIGxldCBzdGFjayA9IHlpZWxkIHNlbGVjdChkYXRhLm5leHQuc3RhdGUuc3RhY2spO1xuICBpZiAoIXN0YWNrKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IHRvcCA9IHN0YWNrLmxlbmd0aCAtIDE7XG4gIHZhciBwYXJhbWV0ZXJzLCByZXR1cm5QYXJhbWV0ZXJzLCBhc3NpZ25tZW50cywgc3RvcmFnZVZhcnM7XG5cbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3dpdGNoIChub2RlLm5vZGVUeXBlKSB7XG5cbiAgICBjYXNlIFwiRnVuY3Rpb25EZWZpbml0aW9uXCI6XG4gICAgICAvLyBzdGFjayBpcyBvbmx5IHJlYWR5IGZvciBpbnRlcnByZXRhdGlvbiBhZnRlciB0aGUgbGFzdCBzdGVwIG9mIGVhY2hcbiAgICAgIC8vIHNvdXJjZSByYW5nZVxuICAgICAgLy9cbiAgICAgIC8vIHRoZSBkYXRhIG1vZHVsZSBhbHdheXMgbG9va3MgYXQgdGhlIHJlc3VsdCBvZiBhIHBhcnRpY3VsYXIgb3Bjb2RlXG4gICAgICAvLyAoaS5lLiwgdGhlIGZvbGxvd2luZyB0cmFjZSBzdGVwJ3Mgc3RhY2svbWVtb3J5L3N0b3JhZ2UpLCBzbyB0aGlzXG4gICAgICAvLyBhc3NlcnRzIHRoYXQgdGhlIF9jdXJyZW50XyBvcGVyYXRpb24gaXMgdGhlIGZpbmFsIG9uZSBiZWZvcmVcbiAgICAgIC8vIHByb2NlZWRpbmdcbiAgICAgIGlmICghKHlpZWxkIHNlbGVjdChkYXRhLnZpZXdzLmF0TGFzdEluc3RydWN0aW9uRm9yU291cmNlUmFuZ2UpKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcGFyYW1ldGVycyA9IG5vZGUucGFyYW1ldGVycy5wYXJhbWV0ZXJzXG4gICAgICAgIC5tYXAoIChwLCBpKSA9PiBgJHtwb2ludGVyfS9wYXJhbWV0ZXJzL3BhcmFtZXRlcnMvJHtpfWAgKTtcblxuICAgICAgcmV0dXJuUGFyYW1ldGVycyA9IG5vZGUucmV0dXJuUGFyYW1ldGVycy5wYXJhbWV0ZXJzXG4gICAgICAgIC5tYXAoIChwLCBpKSA9PiBgJHtwb2ludGVyfS9yZXR1cm5QYXJhbWV0ZXJzL3BhcmFtZXRlcnMvJHtpfWAgKTtcblxuICAgICAgYXNzaWdubWVudHMgPSByZXR1cm5QYXJhbWV0ZXJzLmNvbmNhdChwYXJhbWV0ZXJzKS5yZXZlcnNlKClcbiAgICAgICAgLm1hcCggKHBvaW50ZXIpID0+IGpzb25wb2ludGVyLmdldCh0cmVlLCBwb2ludGVyKS5pZCApXG4gICAgICAgIC5tYXAoIChpZCwgaSkgPT4gKHsgW2lkXToge1wic3RhY2tcIjogdG9wIC0gaX0gfSkgKVxuICAgICAgICAucmVkdWNlKCAoYWNjLCBhc3NpZ25tZW50KSA9PiBPYmplY3QuYXNzaWduKGFjYywgYXNzaWdubWVudCksIHt9ICk7XG5cbiAgICAgIHlpZWxkIHB1dChhY3Rpb25zLmFzc2lnbih0cmVlSWQsIGFzc2lnbm1lbnRzKSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJDb250cmFjdERlZmluaXRpb25cIjpcbiAgICAgIGxldCBzdG9yYWdlVmFycyA9IHNjb3Blc1tub2RlLmlkXS52YXJpYWJsZXMgfHwgW107XG4gICAgICBsZXQgc2xvdCA9IDA7XG4gICAgICBsZXQgaW5kZXggPSBXT1JEX1NJWkUgLSAxOyAgLy8gY2F1c2UgbG93ZXItb3JkZXJcbiAgICAgIGRlYnVnKFwic3RvcmFnZSB2YXJzICVvXCIsIHN0b3JhZ2VWYXJzKTtcblxuICAgICAgbGV0IGFsbG9jYXRpb24gPSB1dGlscy5hbGxvY2F0ZURlY2xhcmF0aW9ucyhzdG9yYWdlVmFycywgZGVmaW5pdGlvbnMpO1xuICAgICAgYXNzaWdubWVudHMgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICB7fSwgLi4uT2JqZWN0LmVudHJpZXMoYWxsb2NhdGlvbi5jaGlsZHJlbilcbiAgICAgICAgICAubWFwKCAoW2lkLCBzdG9yYWdlXSkgPT4gKHsgW2lkXToge3N0b3JhZ2V9IH0pIClcbiAgICAgICk7XG4gICAgICBkZWJ1ZyhcImFzc2lnbm1lbnRzICVPXCIsIGFzc2lnbm1lbnRzKTtcblxuICAgICAgeWllbGQgcHV0KGFjdGlvbnMuYXNzaWduKHRyZWVJZCwgYXNzaWdubWVudHMpKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIjpcbiAgICAgIHlpZWxkIHB1dChhY3Rpb25zLmFzc2lnbih0cmVlSWQsIHtcbiAgICAgICAgW2pzb25wb2ludGVyLmdldCh0cmVlLCBwb2ludGVyKS5pZF06IHtcInN0YWNrXCI6IHRvcH1cbiAgICAgIH0pKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhaztcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24qIHNhZ2EgKCkge1xuICB5aWVsZCB0YWtlRXZlcnkoVElDSywgZnVuY3Rpb24qICgpIHtcbiAgICB0cnkge1xuICAgICAgeWllbGQgKnRpY2tTYWdhKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZGVidWcoZSk7XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcHJlZml4TmFtZShcImRhdGFcIiwgc2FnYSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2RhdGEvc2FnYXMvaW5kZXguanMiLCJleHBvcnQgY29uc3QgU0NPUEUgPSBcIlNDT1BFXCI7XG5leHBvcnQgZnVuY3Rpb24gc2NvcGUoaWQsIHBvaW50ZXIsIHBhcmVudElkLCBzb3VyY2VJZCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFNDT1BFLFxuICAgIGlkLCBwb2ludGVyLCBwYXJlbnRJZCwgc291cmNlSWRcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgREVDTEFSRSA9IFwiREVDTEFSRV9WQVJJQUJMRVwiO1xuZXhwb3J0IGZ1bmN0aW9uIGRlY2xhcmUobm9kZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IERFQ0xBUkUsXG4gICAgbm9kZVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBBU1NJR04gPSBcIkFTU0lHTlwiO1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbihjb250ZXh0LCBhc3NpZ25tZW50cykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEFTU0lHTixcbiAgICBjb250ZXh0LCBhc3NpZ25tZW50c1xuICB9O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9kYXRhL2FjdGlvbnMvaW5kZXguanMiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6ZGF0YTpzZWxlY3RvcnNcIik7XG5cbmltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yVHJlZSwgY3JlYXRlTGVhZiB9IGZyb20gXCJyZXNlbGVjdC10cmVlXCI7XG5pbXBvcnQganNvbnBvaW50ZXIgZnJvbSBcImpzb24tcG9pbnRlclwiO1xuXG5pbXBvcnQgYXN0IGZyb20gXCJsaWIvYXN0L3NlbGVjdG9yc1wiO1xuaW1wb3J0IGV2bSBmcm9tIFwibGliL2V2bS9zZWxlY3RvcnNcIjtcbmltcG9ydCBzb2xpZGl0eSBmcm9tIFwibGliL3NvbGlkaXR5L3NlbGVjdG9yc1wiO1xuXG5pbXBvcnQgZGVjb2RlIGZyb20gXCIuLi9kZWNvZGVcIjtcbmltcG9ydCAqIGFzIGRlY29kZVV0aWxzIGZyb20gXCIuLi9kZWNvZGUvdXRpbHNcIjtcblxuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSBcImJpZ251bWJlci5qc1wiO1xuXG5mdW5jdGlvbiBjcmVhdGVTdGF0ZVNlbGVjdG9ycyh7IHN0YWNrLCBtZW1vcnksIHN0b3JhZ2UgfSkge1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIC5zdGFja1xuICAgICAqL1xuICAgIHN0YWNrOiBjcmVhdGVMZWFmKFxuICAgICAgW3N0YWNrXSxcblxuICAgICAgKHdvcmRzKSA9PiAod29yZHMgfHwgW10pLm1hcChcbiAgICAgICAgKHdvcmQpID0+IGRlY29kZVV0aWxzLnRvQnl0ZXMoZGVjb2RlVXRpbHMudG9CaWdOdW1iZXIod29yZCwgZGVjb2RlVXRpbHMuV09SRF9TSVpFKSlcbiAgICAgIClcbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogLm1lbW9yeVxuICAgICAqL1xuICAgIG1lbW9yeTogY3JlYXRlTGVhZihcbiAgICAgIFttZW1vcnldLFxuXG4gICAgICAod29yZHMpID0+IG5ldyBVaW50OEFycmF5KFxuICAgICAgICAod29yZHMuam9pbihcIlwiKS5tYXRjaCgvLnsxLDJ9L2cpIHx8IFtdKVxuICAgICAgICAgIC5tYXAoIChieXRlKSA9PiBwYXJzZUludChieXRlLCAxNikgKVxuICAgICAgKVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiAuc3RvcmFnZVxuICAgICAqL1xuICAgIHN0b3JhZ2U6IGNyZWF0ZUxlYWYoXG4gICAgICBbc3RvcmFnZV0sXG5cbiAgICAgIChtYXBwaW5nKSA9PiBPYmplY3QuYXNzaWduKFxuICAgICAgICB7fSwgLi4uT2JqZWN0LmVudHJpZXMobWFwcGluZykubWFwKCAoWyBhZGRyZXNzLCB3b3JkIF0pID0+XG4gICAgICAgICAgKHtcbiAgICAgICAgICAgIFtgMHgke2FkZHJlc3N9YF06IG5ldyBVaW50OEFycmF5KFxuICAgICAgICAgICAgICAod29yZC5tYXRjaCgvLnsxLDJ9L2cpIHx8IFtdKVxuICAgICAgICAgICAgICAgIC5tYXAoIChieXRlKSA9PiBwYXJzZUludChieXRlLCAxNikgKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgIClcbiAgICApXG4gIH07XG59XG5cbmNvbnN0IGRhdGEgPSBjcmVhdGVTZWxlY3RvclRyZWUoe1xuICBzdGF0ZTogKHN0YXRlKSA9PiBzdGF0ZS5kYXRhLFxuXG4gIC8qKlxuICAgKiBkYXRhLnZpZXdzXG4gICAqL1xuICB2aWV3czoge1xuICAgIGFzdDogY3JlYXRlTGVhZihcbiAgICAgIFthc3QuY3VycmVudF0sICh0cmVlKSA9PiB0cmVlXG4gICAgKSxcblxuICAgIGF0TGFzdEluc3RydWN0aW9uRm9yU291cmNlUmFuZ2U6IGNyZWF0ZUxlYWYoXG4gICAgICBbc29saWRpdHkuY3VycmVudC5pc1NvdXJjZVJhbmdlRmluYWxdLCAoZmluYWwpID0+IGZpbmFsXG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIGRhdGEudmlld3Muc2NvcGVzXG4gICAgICovXG4gICAgc2NvcGVzOiB7XG5cbiAgICAgIC8qKlxuICAgICAgICogZGF0YS52aWV3cy5zY29wZXMuaW5saW5lZFxuICAgICAgICovXG4gICAgICBpbmxpbmVkOiBjcmVhdGVMZWFmKFxuICAgICAgICBbXCIvaW5mby9zY29wZXNcIiwgc29saWRpdHkuaW5mby5zb3VyY2VzXSxcblxuICAgICAgICAoc2NvcGVzLCBzb3VyY2VzKSA9PiBPYmplY3QuYXNzaWduKHt9LFxuICAgICAgICAgIC4uLk9iamVjdC5lbnRyaWVzKHNjb3BlcykubWFwKFxuICAgICAgICAgICAgKFtpZCwgZW50cnldKSA9PiAoe1xuICAgICAgICAgICAgICBbaWRdOiB7XG4gICAgICAgICAgICAgICAgLi4uZW50cnksXG5cbiAgICAgICAgICAgICAgICBkZWZpbml0aW9uOiBqc29ucG9pbnRlci5nZXQoXG4gICAgICAgICAgICAgICAgICBzb3VyY2VzW2VudHJ5LnNvdXJjZUlkXS5hc3QsIGVudHJ5LnBvaW50ZXJcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICApXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGRhdGEudmlld3MuZGVjb2RlclxuICAgICAqXG4gICAgICogc2VsZWN0b3IgcmV0dXJucyAoYXN0IG5vZGUgZGVmaW5pdGlvbiwgZGF0YSByZWZlcmVuY2UpID0+IHZhbHVlXG4gICAgICovXG4gICAgZGVjb2RlcjogY3JlYXRlTGVhZihcbiAgICAgIFtcIi92aWV3cy9zY29wZXMvaW5saW5lZFwiLCBcIi9jdXJyZW50L3N0YXRlXCJdLFxuXG4gICAgICAoc2NvcGVzLCBzdGF0ZSkgPT4ge1xuICAgICAgICByZXR1cm4gKGRlZmluaXRpb24sIHJlZikgPT4gZGVjb2RlKGRlZmluaXRpb24sIHJlZiwgc3RhdGUsIHNjb3BlcylcbiAgICAgIH1cbiAgICApXG4gIH0sXG5cbiAgLyoqXG4gICAqIGRhdGEuaW5mb1xuICAgKi9cbiAgaW5mbzoge1xuXG4gICAgLyoqXG4gICAgICogZGF0YS5pbmZvLnNjb3Blc1xuICAgICAqL1xuICAgIHNjb3BlczogY3JlYXRlTGVhZihbXCIvc3RhdGVcIl0sIChzdGF0ZSkgPT4gc3RhdGUuaW5mby5zY29wZXMuYnlJZClcbiAgfSxcblxuICAvKipcbiAgICogZGF0YS5wcm9jXG4gICAqL1xuICBwcm9jOiB7XG5cbiAgICAvKipcbiAgICAgKiBkYXRhLnByb2MuYXNzaWdubWVudHNcbiAgICAgKi9cbiAgICBhc3NpZ25tZW50czogY3JlYXRlTGVhZihbXCIvc3RhdGVcIl0sIChzdGF0ZSkgPT4gc3RhdGUucHJvYy5hc3NpZ25tZW50cy5ieUlkKVxuICB9LFxuXG4gIC8qKlxuICAgKiBkYXRhLmN1cnJlbnRcbiAgICovXG4gIGN1cnJlbnQ6IHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIGRhdGEuY3VycmVudC5zY29wZVxuICAgICAqL1xuICAgIHNjb3BlOiB7XG5cbiAgICAgIC8qKlxuICAgICAgICogZGF0YS5jdXJyZW50LnNjb3BlLmlkXG4gICAgICAgKi9cbiAgICAgIGlkOiBjcmVhdGVMZWFmKFxuICAgICAgICBbYXN0LmN1cnJlbnQubm9kZV0sIChub2RlKSA9PiBub2RlLmlkXG4gICAgICApXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGRhdGEuY3VycmVudC5zdGF0ZVxuICAgICAqL1xuICAgIHN0YXRlOiBjcmVhdGVTdGF0ZVNlbGVjdG9ycyhldm0uY3VycmVudC5zdGF0ZSksXG5cbiAgICAvKipcbiAgICAgKiBkYXRhLmN1cnJlbnQuaWRlbnRpZmllcnMgKG5hbWVzcGFjZSlcbiAgICAgKi9cbiAgICBpZGVudGlmaWVyczoge1xuXG4gICAgICAvKipcbiAgICAgICAqIGRhdGEuY3VycmVudC5pZGVudGlmaWVycyAoc2VsZWN0b3IpXG4gICAgICAgKlxuICAgICAgICogcmV0dXJucyBpZGVudGlmZXJzIGFuZCBjb3JyZXNwb25kaW5nIGRlZmluaXRpb24gbm9kZSBJRFxuICAgICAgICovXG4gICAgICBfOiBjcmVhdGVMZWFmKFxuICAgICAgICBbXG4gICAgICAgICAgXCIvdmlld3Mvc2NvcGVzL2lubGluZWRcIixcbiAgICAgICAgICBcIi9jdXJyZW50L3Njb3BlXCIsXG4gICAgICAgIF0sXG5cbiAgICAgICAgKHNjb3Blcywgc2NvcGUpID0+IHtcbiAgICAgICAgICBsZXQgY3VyID0gc2NvcGUuaWQ7XG4gICAgICAgICAgbGV0IHZhcmlhYmxlcyA9IHt9O1xuXG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgdmFyaWFibGVzID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgICAgdmFyaWFibGVzLFxuICAgICAgICAgICAgICAuLi4oc2NvcGVzW2N1cl0udmFyaWFibGVzIHx8IFtdKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoICh2KSA9PiB2YXJpYWJsZXNbdi5uYW1lXSA9PSB1bmRlZmluZWQgKVxuICAgICAgICAgICAgICAgIC5tYXAoICh2KSA9PiAoeyBbdi5uYW1lXTogdi5pZCB9KSApXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBjdXIgPSBzY29wZXNbY3VyXS5wYXJlbnRJZDtcbiAgICAgICAgICB9IHdoaWxlIChjdXIgIT0gbnVsbCk7XG5cbiAgICAgICAgICByZXR1cm4gdmFyaWFibGVzO1xuICAgICAgICB9XG4gICAgICApLFxuXG4gICAgICAvKipcbiAgICAgICAqIGRhdGEuY3VycmVudC5pZGVudGlmaWVycy5kZWZpbml0aW9uc1xuICAgICAgICpcbiAgICAgICAqIGN1cnJlbnQgdmFyaWFibGUgZGVmaW5pdGlvbnNcbiAgICAgICAqL1xuICAgICAgZGVmaW5pdGlvbnM6IGNyZWF0ZUxlYWYoXG4gICAgICAgIFtcbiAgICAgICAgICBcIi92aWV3cy9zY29wZXMvaW5saW5lZFwiLFxuICAgICAgICAgIFwiLi9fXCJcbiAgICAgICAgXSxcblxuICAgICAgICAoc2NvcGVzLCBpZGVudGlmaWVycykgPT4gT2JqZWN0LmFzc2lnbih7fSxcbiAgICAgICAgICAuLi5PYmplY3QuZW50cmllcyhpZGVudGlmaWVycylcbiAgICAgICAgICAgIC5tYXAoIChbaWRlbnRpZmllciwgaWRdKSA9PiB7XG4gICAgICAgICAgICAgIGxldCB7IGRlZmluaXRpb24gfSA9IHNjb3Blc1tpZF07XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHsgW2lkZW50aWZpZXJdOiBkZWZpbml0aW9uIH07XG4gICAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApLFxuXG4gICAgICAvKipcbiAgICAgICAqIGRhdGEuY3VycmVudC5pZGVudGlmaWVycy5yZWZzXG4gICAgICAgKlxuICAgICAgICogY3VycmVudCB2YXJpYWJsZXMnIHZhbHVlIHJlZnNcbiAgICAgICAqL1xuICAgICAgcmVmczogY3JlYXRlTGVhZihcbiAgICAgICAgW1xuICAgICAgICAgIFwiL3Byb2MvYXNzaWdubWVudHNcIixcbiAgICAgICAgICBcIi4vX1wiXG4gICAgICAgIF0sXG5cbiAgICAgICAgKGFzc2lnbm1lbnRzLCBpZGVudGlmaWVycykgPT4gT2JqZWN0LmFzc2lnbih7fSxcbiAgICAgICAgICAuLi5PYmplY3QuZW50cmllcyhpZGVudGlmaWVycylcbiAgICAgICAgICAgIC5tYXAoIChbaWRlbnRpZmllciwgaWRdKSA9PiB7XG4gICAgICAgICAgICAgIGxldCB7IHJlZiB9ID0gKGFzc2lnbm1lbnRzW2lkXSB8fCB7fSlcbiAgICAgICAgICAgICAgaWYgKCFyZWYpIHsgcmV0dXJuIHVuZGVmaW5lZCB9O1xuXG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgW2lkZW50aWZpZXJdOiByZWZcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICksXG5cbiAgICAgIGRlY29kZWQ6IGNyZWF0ZUxlYWYoXG4gICAgICAgIFtcbiAgICAgICAgICBcIi92aWV3cy9kZWNvZGVyXCIsXG4gICAgICAgICAgXCIuL2RlZmluaXRpb25zXCIsXG4gICAgICAgICAgXCIuL3JlZnNcIixcbiAgICAgICAgXSxcblxuICAgICAgICAoZGVjb2RlLCBkZWZpbml0aW9ucywgcmVmcykgPT4gT2JqZWN0LmFzc2lnbih7fSxcbiAgICAgICAgICAuLi5PYmplY3QuZW50cmllcyhyZWZzKVxuICAgICAgICAgICAgLm1hcCggKFtpZGVudGlmaWVyLCByZWZdKSA9PiAoe1xuICAgICAgICAgICAgICBbaWRlbnRpZmllcl06IGRlY29kZShkZWZpbml0aW9uc1tpZGVudGlmaWVyXSwgcmVmKVxuICAgICAgICAgICAgfSkgKVxuICAgICAgICApXG4gICAgICApLFxuXG4gICAgICBuYXRpdmU6IGNyZWF0ZUxlYWYoWycuL2RlY29kZWQnXSwgZGVjb2RlVXRpbHMuY2xlYW5CaWdOdW1iZXJzKVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogZGF0YS5uZXh0XG4gICAqL1xuICBuZXh0OiB7XG5cbiAgICAvKipcbiAgICAgKiBkYXRhLm5leHQuc3RhdGVcbiAgICAgKi9cbiAgICBzdGF0ZTogY3JlYXRlU3RhdGVTZWxlY3RvcnMoZXZtLm5leHQuc3RhdGUpXG4gIH1cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBkYXRhO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9kYXRhL3NlbGVjdG9ycy9pbmRleC5qcyIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjp0cmFjZTpzYWdhc1wiKTtcblxuaW1wb3J0IHsgdGFrZSwgdGFrZUV2ZXJ5LCBwdXQsIHNlbGVjdCB9IGZyb20gXCJyZWR1eC1zYWdhL2VmZmVjdHNcIjtcbmltcG9ydCB7IHByZWZpeE5hbWUgfSBmcm9tIFwibGliL2hlbHBlcnNcIjtcblxuaW1wb3J0ICogYXMgYWN0aW9ucyBmcm9tIFwiLi4vYWN0aW9uc1wiO1xuXG5pbXBvcnQgdHJhY2UgZnJvbSBcIi4uL3NlbGVjdG9yc1wiO1xuXG5mdW5jdGlvbiAqd2FpdEZvclRyYWNlKCkge1xuICBsZXQge3N0ZXBzfSA9IHlpZWxkIHRha2UoYWN0aW9ucy5TQVZFX1NURVBTKTtcblxuICBsZXQgYWRkcmVzc2VzID0gW1xuICAgIC4uLm5ldyBTZXQoXG4gICAgICBzdGVwc1xuICAgICAgICAuZmlsdGVyKCAoe29wfSkgPT4gb3AgPT0gXCJDQUxMXCIgfHwgb3AgPT0gXCJERUxFR0FURUNBTExcIiApXG4gICAgICAgIC5tYXAoICh7c3RhY2t9KSA9PiBcIjB4XCIgKyBzdGFja1tzdGFjay5sZW5ndGggLSAyXS5zdWJzdHJpbmcoMjQpIClcbiAgICApXG4gIF07XG5cbiAgeWllbGQgcHV0KGFjdGlvbnMucmVjZWl2ZUFkZHJlc3NlcyhhZGRyZXNzZXMpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uICphZHZhbmNlKCkge1xuICB5aWVsZCBwdXQoYWN0aW9ucy5uZXh0KCkpO1xuXG4gIHlpZWxkIHRha2UoYWN0aW9ucy5UT0NLKTtcbn1cblxuZnVuY3Rpb24qIG5leHQoKSB7XG4gIGxldCByZW1haW5pbmcgPSB5aWVsZCBzZWxlY3QodHJhY2Uuc3RlcHNSZW1haW5pbmcpO1xuICBkZWJ1ZyhcInJlbWFpbmluZzogJW9cIiwgcmVtYWluaW5nKTtcbiAgbGV0IHN0ZXBzID0geWllbGQgc2VsZWN0KHRyYWNlLnN0ZXBzKTtcbiAgZGVidWcoXCJ0b3RhbCBzdGVwczogJW9cIiwgc3RlcHMubGVuZ3RoKTtcblxuICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgIGRlYnVnKFwicHV0dGluZyBUSUNLXCIpO1xuICAgIC8vIHVwZGF0ZXMgc3RhdGUgZm9yIGN1cnJlbnQgc3RlcFxuICAgIHlpZWxkIHB1dChhY3Rpb25zLnRpY2soKSk7XG4gICAgZGVidWcoXCJwdXQgVElDS1wiKTtcblxuICAgIHJlbWFpbmluZy0tOyAvLyBsb2NhbCB1cGRhdGUsIGp1c3QgZm9yIGNvbnZlbmllbmNlXG4gIH1cblxuICBpZiAocmVtYWluaW5nKSB7XG4gICAgZGVidWcoXCJwdXR0aW5nIFRPQ0tcIik7XG4gICAgLy8gdXBkYXRlcyBzdGVwIHRvIG5leHQgc3RlcCBpbiB0cmFjZVxuICAgIHlpZWxkIHB1dChhY3Rpb25zLnRvY2soKSk7XG4gICAgZGVidWcoXCJwdXQgVE9DS1wiKTtcblxuICB9IGVsc2Uge1xuXG4gICAgeWllbGQgcHV0KGFjdGlvbnMuZW5kVHJhY2UoKSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uKiB3YWl0KCkge1xuICB5aWVsZCB0YWtlKGFjdGlvbnMuRU5EX09GX1RSQUNFKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uICpwcm9jZXNzVHJhY2UodHJhY2UpIHtcbiAgeWllbGQgcHV0KGFjdGlvbnMuc2F2ZVN0ZXBzKHRyYWNlKSk7XG5cbiAgbGV0IHthZGRyZXNzZXN9ID0geWllbGQgdGFrZShhY3Rpb25zLlJFQ0VJVkVfQUREUkVTU0VTKTtcbiAgZGVidWcoXCJyZWNlaXZlZCBhZGRyZXNzZXNcIik7XG5cbiAgcmV0dXJuIGFkZHJlc3Nlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uKiBzYWdhKCkge1xuICAvLyB3YWl0IGZvciB0cmFjZSB0byBiZSBkZWZpbmVkXG4gIHlpZWxkICp3YWl0Rm9yVHJhY2UoKTtcblxuICB5aWVsZCB0YWtlRXZlcnkoYWN0aW9ucy5ORVhULCBuZXh0KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcHJlZml4TmFtZShcInRyYWNlXCIsIHNhZ2EpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi90cmFjZS9zYWdhcy9pbmRleC5qcyIsImV4cG9ydCBjb25zdCBBRERfU09VUkNFID0gXCJTT0xJRElUWV9BRERfU09VUkNFXCI7XG5leHBvcnQgZnVuY3Rpb24gYWRkU291cmNlKHNvdXJjZSwgc291cmNlUGF0aCwgYXN0KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQUREX1NPVVJDRSxcbiAgICBzb3VyY2UsIHNvdXJjZVBhdGgsIGFzdFxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgQUREX1NPVVJDRU1BUCA9IFwiU09MSURJVFlfQUREX1NPVVJDRU1BUFwiO1xuZXhwb3J0IGZ1bmN0aW9uIGFkZFNvdXJjZU1hcChiaW5hcnksIHNvdXJjZU1hcCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEFERF9TT1VSQ0VNQVAsXG4gICAgYmluYXJ5LCBzb3VyY2VNYXBcbiAgfTtcbn1cblxuXG5leHBvcnQgY29uc3QgSlVNUCA9IFwiSlVNUFwiO1xuZXhwb3J0IGZ1bmN0aW9uIGp1bXAoanVtcERpcmVjdGlvbikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEpVTVAsXG4gICAganVtcERpcmVjdGlvblxuICB9O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9zb2xpZGl0eS9hY3Rpb25zL2luZGV4LmpzIiwiZXhwb3J0IGNvbnN0IEFERF9DT05URVhUID0gXCJFVk1fQUREX0NPTlRFWFRcIjtcbmV4cG9ydCBmdW5jdGlvbiBhZGRDb250ZXh0KGNvbnRyYWN0TmFtZSwgYmluYXJ5KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQUREX0NPTlRFWFQsXG4gICAgY29udHJhY3ROYW1lLCBiaW5hcnlcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgQUREX0lOU1RBTkNFID0gXCJFVk1fQUREX0lOU1RBTkNFXCI7XG5leHBvcnQgZnVuY3Rpb24gYWRkSW5zdGFuY2UoYWRkcmVzcywgY29udGV4dCwgYmluYXJ5KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQUREX0lOU1RBTkNFLFxuICAgIGFkZHJlc3MsIGNvbnRleHQsIGJpbmFyeVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBDQUxMID0gXCJDQUxMXCI7XG5leHBvcnQgZnVuY3Rpb24gY2FsbChhZGRyZXNzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQ0FMTCxcbiAgICBhZGRyZXNzXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBDUkVBVEUgPSBcIkNSRUFURVwiO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZShiaW5hcnkpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBDUkVBVEUsXG4gICAgYmluYXJ5XG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBSRVRVUk4gPSBcIlJFVFVSTlwiO1xuZXhwb3J0IGZ1bmN0aW9uIHJldHVybkNhbGwoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogUkVUVVJOXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvZXZtL2FjdGlvbnMvaW5kZXguanMiLCJ2YXIgRGVidWdnZXIgPSByZXF1aXJlKFwiLi9saWIvZGVidWdnZXJcIikuZGVmYXVsdDtcblxubW9kdWxlLmV4cG9ydHMgPSBEZWJ1Z2dlcjtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kZWJ1Z2dlci5qc1xuLy8gbW9kdWxlIGlkID0gMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gJ2RlYnVnJztcbmltcG9ydCBleHBlY3QgZnJvbSBcInRydWZmbGUtZXhwZWN0XCI7XG5cbmltcG9ydCBTZXNzaW9uIGZyb20gXCIuL3Nlc3Npb25cIjtcblxuaW1wb3J0IHsgY3JlYXRlTmVzdGVkU2VsZWN0b3IgfSBmcm9tIFwicmVzZWxlY3QtdHJlZVwiO1xuXG5pbXBvcnQgZGF0YVNlbGVjdG9yIGZyb20gXCIuL2RhdGEvc2VsZWN0b3JzXCI7XG5pbXBvcnQgYXN0U2VsZWN0b3IgZnJvbSBcIi4vYXN0L3NlbGVjdG9yc1wiO1xuaW1wb3J0IHRyYWNlU2VsZWN0b3IgZnJvbSBcIi4vdHJhY2Uvc2VsZWN0b3JzXCI7XG5pbXBvcnQgZXZtU2VsZWN0b3IgZnJvbSBcIi4vZXZtL3NlbGVjdG9yc1wiO1xuaW1wb3J0IHNvbGlkaXR5U2VsZWN0b3IgZnJvbSBcIi4vc29saWRpdHkvc2VsZWN0b3JzXCI7XG5pbXBvcnQgc2Vzc2lvblNlbGVjdG9yIGZyb20gXCIuL3Nlc3Npb24vc2VsZWN0b3JzXCI7XG5cbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlclwiKTtcblxuLyoqXG4gKiBAZXhhbXBsZVxuICogbGV0IHNlc3Npb24gPSBEZWJ1Z2dlclxuICogICAuZm9yVHgoPHR4SGFzaD4sIHtcbiAqICAgICBjb250cmFjdHM6IFs8Y29udHJhY3Qgb2JqPiwgLi4uXSxcbiAqICAgICBwcm92aWRlcjogPHByb3ZpZGVyIGluc3RhbmNlPlxuICogICB9KVxuICogICAuY29ubmVjdCgpO1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZWJ1Z2dlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1Nlc3Npb259IHNlc3Npb24gLSBkZWJ1Z2dlciBzZXNzaW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihzZXNzaW9uKSB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9zZXNzaW9uID0gc2Vzc2lvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnN0YW50aWF0ZXMgYSBEZWJ1Z2dlciBmb3IgYSBnaXZlbiB0cmFuc2FjdGlvbiBoYXNoLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHhIYXNoIC0gdHJhbnNhY3Rpb24gaGFzaCB3aXRoIGxlYWRpbmcgXCIweFwiXG4gICAqIEBwYXJhbSB7e2NvbnRyYWN0czogQXJyYXk8Q29udHJhY3Q+LCBmaWxlczogQXJyYXk8U3RyaW5nPiwgcHJvdmlkZXI6IFdlYjNQcm92aWRlcn19IG9wdGlvbnMgLVxuICAgKiBAcmV0dXJuIHtEZWJ1Z2dlcn0gaW5zdGFuY2VcbiAgICovXG4gIHN0YXRpYyBhc3luYyBmb3JUeCh0eEhhc2gsIG9wdGlvbnMgPSB7fSkge1xuICAgIGV4cGVjdC5vcHRpb25zKG9wdGlvbnMsIFtcbiAgICAgIFwiY29udHJhY3RzXCIsXG4gICAgICBcInByb3ZpZGVyXCJcbiAgICBdKTtcblxuICAgIGxldCBzZXNzaW9uID0gbmV3IFNlc3Npb24oXG4gICAgICBvcHRpb25zLmNvbnRyYWN0cywgb3B0aW9ucy5maWxlcyxcbiAgICAgIHR4SGFzaCwgb3B0aW9ucy5wcm92aWRlclxuICAgICk7XG5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgc2Vzc2lvbi5yZWFkeSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyB0aGlzKHNlc3Npb24pO1xuICB9XG5cblxuICAvKipcbiAgICogQ29ubmVjdHMgdG8gdGhlIGluc3RhbnRpYXRlZCBEZWJ1Z2dlci5cbiAgICpcbiAgICogQHJldHVybiB7U2Vzc2lvbn0gc2Vzc2lvbiBpbnN0YW5jZVxuICAgKi9cbiAgY29ubmVjdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2Vzc2lvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBvcnRlZCBzZWxlY3RvcnNcbiAgICpcbiAgICogU2VlIGluZGl2aWR1YWwgc2VsZWN0b3IgZG9jcyBmb3IgZnVsbCBsaXN0aW5nXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIERlYnVnZ2VyLnNlbGVjdG9ycy5hc3QuY3VycmVudC50cmVlXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIERlYnVnZ2VyLnNlbGVjdG9ycy5zb2xpZGl0eS5jdXJyZW50Lmluc3RydWN0aW9uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIERlYnVnZ2VyLnNlbGVjdG9ycy50cmFjZS5zdGVwc1xuICAgKi9cbiAgc3RhdGljIGdldCBzZWxlY3RvcnMoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZU5lc3RlZFNlbGVjdG9yKHtcbiAgICAgIGFzdDogYXN0U2VsZWN0b3IsXG4gICAgICBkYXRhOiBkYXRhU2VsZWN0b3IsXG4gICAgICB0cmFjZTogdHJhY2VTZWxlY3RvcixcbiAgICAgIGV2bTogZXZtU2VsZWN0b3IsXG4gICAgICBzb2xpZGl0eTogc29saWRpdHlTZWxlY3RvcixcbiAgICAgIHNlc3Npb246IHNlc3Npb25TZWxlY3RvcixcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IENvbnRyYWN0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gY29udHJhY3ROYW1lIGNvbnRyYWN0IG5hbWVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzb3VyY2Ugc29saWRpdHkgc291cmNlIGNvZGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzb3VyY2VQYXRoIHBhdGggdG8gc291cmNlIGZpbGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBiaW5hcnkgMHgtcHJlZml4ZWQgaGV4IHN0cmluZyB3aXRoIGNyZWF0ZSBieXRlY29kZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNvdXJjZU1hcCBzb2xpZGl0eSBzb3VyY2UgbWFwIGZvciBjcmVhdGUgYnl0ZWNvZGVcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBhc3QgQWJzdHJhY3QgU3ludGF4IFRyZWUgZnJvbSBTb2xpZGl0eVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGRlcGxveWVkQmluYXJ5IDB4LXByZWZpeGVkIGNvbXBpbGVkIGJpbmFyeSAob24gY2hhaW4pXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZGVwbG95ZWRTb3VyY2VNYXAgc29saWRpdHkgc291cmNlIG1hcCBmb3Igb24tY2hhaW4gYnl0ZWNvZGVcbiAqL1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9kZWJ1Z2dlci5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInRydWZmbGUtZXhwZWN0XCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwidHJ1ZmZsZS1leHBlY3RcIlxuLy8gbW9kdWxlIGlkID0gMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOnNlc3Npb25cIik7XG5cbmltcG9ydCB0cmFjZSBmcm9tIFwibGliL3RyYWNlL3NlbGVjdG9yc1wiO1xuaW1wb3J0IGV2bSBmcm9tIFwibGliL2V2bS9zZWxlY3RvcnNcIjtcbmltcG9ydCBhc3QgZnJvbSBcImxpYi9hc3Qvc2VsZWN0b3JzXCI7XG5pbXBvcnQgc29saWRpdHkgZnJvbSBcImxpYi9zb2xpZGl0eS9zZWxlY3RvcnNcIjtcblxuaW1wb3J0IGNvbmZpZ3VyZVN0b3JlIGZyb20gXCJsaWIvc3RvcmVcIjtcblxuaW1wb3J0ICogYXMgY29udHJvbGxlciBmcm9tIFwibGliL2NvbnRyb2xsZXIvYWN0aW9uc1wiO1xuaW1wb3J0ICogYXMgYWN0aW9ucyBmcm9tIFwiLi9hY3Rpb25zXCI7XG5cbmltcG9ydCByb290U2FnYSBmcm9tIFwiLi9zYWdhc1wiO1xuaW1wb3J0IHJlZHVjZXIgZnJvbSBcIi4vcmVkdWNlcnNcIjtcblxuLyoqXG4gKiBEZWJ1Z2dlciBTZXNzaW9uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlc3Npb24ge1xuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxDb250cmFjdD59IGNvbnRyYWN0cyAtIGNvbnRyYWN0IGRlZmluaXRpb25zXG4gICAqIEBwYXJhbSB7QXJyYXk8U3RyaW5nPn0gZmlsZXMgLSBhcnJheSBvZiBmaWxlbmFtZXMgZm9yIHNvdXJjZU1hcCBpbmRleGVzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eEhhc2ggLSB0cmFuc2FjdGlvbiBoYXNoXG4gICAqIEBwYXJhbSB7V2ViM1Byb3ZpZGVyfSBwcm92aWRlciAtIHdlYjMgcHJvdmlkZXJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbnRyYWN0cywgZmlsZXMsIHR4SGFzaCwgcHJvdmlkZXIpIHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3N0b3JlID0gY29uZmlndXJlU3RvcmUocmVkdWNlciwgcm9vdFNhZ2EpO1xuXG4gICAgbGV0IHsgY29udGV4dHMsIHNvdXJjZXMgfSA9IFNlc3Npb24ubm9ybWFsaXplKGNvbnRyYWN0cywgZmlsZXMpO1xuXG4gICAgLy8gcmVjb3JkIGNvbnRyYWN0c1xuICAgIHRoaXMuX3N0b3JlLmRpc3BhdGNoKGFjdGlvbnMucmVjb3JkQ29udHJhY3RzKGNvbnRleHRzLCBzb3VyY2VzKSk7XG5cbiAgICB0aGlzLl9zdG9yZS5kaXNwYXRjaChhY3Rpb25zLnN0YXJ0KHR4SGFzaCwgcHJvdmlkZXIpKTtcbiAgfVxuXG4gIHJlYWR5KCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSggKGFjY2VwdCwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLl9zdG9yZS5zdWJzY3JpYmUoICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuc2Vzc2lvbiA9PSBcIkFDVElWRVwiKSB7XG4gICAgICAgICAgYWNjZXB0KClcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5zdGF0ZS5zZXNzaW9uID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICByZWplY3QodGhpcy5zdGF0ZS5zZXNzaW9uLmVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3BsaXQgdXAgYXJ0aWZhY3RzIGludG8gXCJjb250ZXh0c1wiIGFuZCBcInNvdXJjZXNcIiwgZGl2aWRpbmcgYXJ0aWZhY3RcbiAgICogZGF0YSBpbnRvIGFwcHJvcHJpYXRlIGJ1Y2tldHMuXG4gICAqXG4gICAqIE11bHRpcGxlIGNvbnRyYWN0cyBjYW4gYmUgZGVmaW5lZCBpbiB0aGUgc2FtZSBzb3VyY2UgZmlsZSwgYnV0IGhhdmVcbiAgICogZGlmZmVyZW50IGJ5dGVjb2Rlcy5cbiAgICpcbiAgICogVGhpcyBpdGVyYXRlcyBvdmVyIHRoZSBjb250cmFjdHMgYW5kIGNvbGxlY3RzIGJpbmFyaWVzIHNlcGFyYXRlbHlcbiAgICogZnJvbSBzb3VyY2VzLCB1c2luZyB0aGUgb3B0aW9uYWwgYGZpbGVzYCBhcmd1bWVudCB0byBmb3JjZVxuICAgKiBzb3VyY2Ugb3JkZXJpbmcuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGF0aWMgbm9ybWFsaXplKGNvbnRyYWN0cywgZmlsZXMgPSBudWxsKSB7XG4gICAgbGV0IHNvdXJjZXNCeVBhdGggPSB7fTtcbiAgICBsZXQgY29udGV4dHMgPSBbXTtcbiAgICBsZXQgc291cmNlcztcblxuICAgIGZvciAobGV0IGNvbnRyYWN0IG9mIGNvbnRyYWN0cykge1xuICAgICAgbGV0IHtcbiAgICAgICAgY29udHJhY3ROYW1lLFxuICAgICAgICBiaW5hcnksXG4gICAgICAgIHNvdXJjZU1hcCxcbiAgICAgICAgZGVwbG95ZWRCaW5hcnksXG4gICAgICAgIGRlcGxveWVkU291cmNlTWFwLFxuICAgICAgICBzb3VyY2VQYXRoLFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIGFzdFxuICAgICAgfSA9IGNvbnRyYWN0O1xuXG4gICAgICBzb3VyY2VzQnlQYXRoW3NvdXJjZVBhdGhdID0geyBzb3VyY2VQYXRoLCBzb3VyY2UsIGFzdCB9O1xuXG4gICAgICBpZiAoYmluYXJ5ICYmIGJpbmFyeSAhPSBcIjB4XCIpIHtcbiAgICAgICAgY29udGV4dHMucHVzaCh7XG4gICAgICAgICAgY29udHJhY3ROYW1lLFxuICAgICAgICAgIGJpbmFyeSxcbiAgICAgICAgICBzb3VyY2VNYXBcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkZXBsb3llZEJpbmFyeSAmJiBkZXBsb3llZEJpbmFyeSAhPSBcIjB4XCIpIHtcbiAgICAgICAgY29udGV4dHMucHVzaCh7XG4gICAgICAgICAgY29udHJhY3ROYW1lLFxuICAgICAgICAgIGJpbmFyeTogZGVwbG95ZWRCaW5hcnksXG4gICAgICAgICAgc291cmNlTWFwOiBkZXBsb3llZFNvdXJjZU1hcFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWZpbGVzKSB7XG4gICAgICBzb3VyY2VzID0gT2JqZWN0LnZhbHVlcyhzb3VyY2VzQnlQYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc291cmNlcyA9IGZpbGVzLm1hcChmaWxlID0+IHNvdXJjZXNCeVBhdGhbZmlsZV0pO1xuICAgIH1cblxuICAgIHJldHVybiB7IGNvbnRleHRzLCBzb3VyY2VzIH07XG4gIH1cblxuICBnZXQgc3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0b3JlLmdldFN0YXRlKCk7XG4gIH1cblxuICB2aWV3KHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHNlbGVjdG9yKHRoaXMuc3RhdGUpO1xuICB9XG5cbiAgZ2V0IGZpbmlzaGVkKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLnNlc3Npb24gPT0gXCJGSU5JU0hFRFwiO1xuICB9XG5cbiAgZ2V0IGZhaWxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hlZCAmJiB0aGlzLnZpZXcoZXZtLmN1cnJlbnQuY2FsbHN0YWNrKS5sZW5ndGhcbiAgfVxuXG4gIGRpc3BhdGNoKGFjdGlvbikge1xuICAgIGlmICh0aGlzLmZpbmlzaGVkKSB7XG4gICAgICBkZWJ1ZyhcImZpbmlzaGVkOiBpbnRlcmNlcHRpbmcgYWN0aW9uICVvXCIsIGFjdGlvbik7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLl9zdG9yZS5kaXNwYXRjaChhY3Rpb24pO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpbnRlcnJ1cHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goY29udHJvbGxlci5pbnRlcnJ1cHQoKSk7XG4gIH1cblxuICBhZHZhbmNlKCkge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKGNvbnRyb2xsZXIuYWR2YW5jZSgpKTtcbiAgfVxuXG4gIHN0ZXBOZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKGNvbnRyb2xsZXIuc3RlcE5leHQoKSk7XG4gIH1cblxuICBzdGVwT3ZlcigpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChjb250cm9sbGVyLnN0ZXBPdmVyKCkpO1xuICB9XG5cbiAgc3RlcEludG8oKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goY29udHJvbGxlci5zdGVwSW50bygpKTtcbiAgfVxuXG4gIHN0ZXBPdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goY29udHJvbGxlci5zdGVwT3V0KCkpO1xuICB9XG5cbiAgY29udGludWVVbnRpbCguLi5icmVha3BvaW50cykge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKGNvbnRyb2xsZXIuY29udGludWVVbnRpbCguLi5icmVha3BvaW50cykpO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3Nlc3Npb24vaW5kZXguanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L3ZhbHVlc1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvdmFsdWVzXCJcbi8vIG1vZHVsZSBpZCA9IDMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInRydWZmbGUtc29saWRpdHktdXRpbHNcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJ0cnVmZmxlLXNvbGlkaXR5LXV0aWxzXCJcbi8vIG1vZHVsZSBpZCA9IDM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInRydWZmbGUtY29kZS11dGlsc1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInRydWZmbGUtY29kZS11dGlsc1wiXG4vLyBtb2R1bGUgaWQgPSAzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6YXN0Om1hcFwiKTtcblxuaW1wb3J0IEludGVydmFsVHJlZSBmcm9tIFwibm9kZS1pbnRlcnZhbC10cmVlXCI7XG5cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmFuZ2Uobm9kZSkge1xuICAvLyBzcmM6IFwiPHN0YXJ0Pjo8bGVuZ3RoPjo8Xz5cIlxuICAvLyByZXR1cm5zIFtzdGFydCwgZW5kXVxuICBsZXQgW3N0YXJ0LCBsZW5ndGhdID0gbm9kZS5zcmNcbiAgICAuc3BsaXQoXCI6XCIpXG4gICAgLnNsaWNlKDAsIDIpXG4gICAgLm1hcCggKGkpID0+IHBhcnNlSW50KGkpICk7XG5cbiAgcmV0dXJuIFtzdGFydCwgc3RhcnQgKyBsZW5ndGhdO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5nZU5vZGVzKG5vZGUsIHBvaW50ZXIgPSBcIlwiKSB7XG4gIGlmIChub2RlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICByZXR1cm4gW10uY29uY2F0KFxuICAgICAgLi4ubm9kZS5tYXAoIChzdWIsIGkpID0+IHJhbmdlTm9kZXMoc3ViLCBgJHtwb2ludGVyfS8ke2l9YCkgKVxuICAgICk7XG4gIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgIGxldCByZXN1bHRzID0gW107XG5cbiAgICBpZiAobm9kZS5zcmMpIHtcbiAgICAgIHJlc3VsdHMucHVzaCh7cG9pbnRlciwgcmFuZ2U6IGdldFJhbmdlKG5vZGUpfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHMuY29uY2F0KFxuICAgICAgLi4uT2JqZWN0LmtleXMobm9kZSkubWFwKFxuICAgICAgICAoa2V5KSA9PiByYW5nZU5vZGVzKG5vZGVba2V5XSwgYCR7cG9pbnRlcn0vJHtrZXl9YClcbiAgICAgIClcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbXTtcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kUmFuZ2Uobm9kZSwgc291cmNlU3RhcnQsIHNvdXJjZUxlbmd0aCkge1xuICBsZXQgcmFuZ2VzID0gcmFuZ2VOb2Rlcyhub2RlKTtcbiAgbGV0IHRyZWUgPSBuZXcgSW50ZXJ2YWxUcmVlKCk7XG5cbiAgcmFuZ2VzLmZvckVhY2goICh7cmFuZ2UsIHBvaW50ZXJ9KSA9PiB7XG4gICAgbGV0IFtzdGFydCwgZW5kXSA9IHJhbmdlO1xuXG4gICAgdHJlZS5pbnNlcnQoc3RhcnQsIGVuZCwge3JhbmdlLCBwb2ludGVyfSk7XG4gIH0pO1xuXG4gIGxldCBzb3VyY2VFbmQgPSBzb3VyY2VTdGFydCArIHNvdXJjZUxlbmd0aDtcblxuICBsZXQgb3ZlcmxhcHBpbmcgPSB0cmVlLnNlYXJjaChzb3VyY2VTdGFydCwgc291cmNlRW5kKTtcblxuICAvLyBmaW5kIG5vZGVzIHRoYXQgZnVsbHkgY29udGFpbiByZXF1ZXN0ZWQgcmFuZ2UsXG4gIC8vIHJldHVybiBsb25nZXN0IHBvaW50ZXJcbiAgcmV0dXJuIG92ZXJsYXBwaW5nXG4gICAgLmZpbHRlciggKHtyYW5nZX0pID0+IHNvdXJjZVN0YXJ0ID49IHJhbmdlWzBdICYmIHNvdXJjZUVuZCA8PSByYW5nZVsxXSApXG4gICAgLm1hcCggKHtwb2ludGVyfSkgPT4gcG9pbnRlciApXG4gICAgLnJlZHVjZSggKGEsIGIpID0+IGEubGVuZ3RoID4gYi5sZW5ndGggPyBhIDogYiwgXCJcIiApO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9hc3QvbWFwLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8vIEFuIGF1Z21lbnRlZCBBVkwgVHJlZSB3aGVyZSBlYWNoIG5vZGUgbWFpbnRhaW5zIGEgbGlzdCBvZiByZWNvcmRzIGFuZCB0aGVpciBzZWFyY2ggaW50ZXJ2YWxzLlxyXG4vLyBSZWNvcmQgaXMgY29tcG9zZWQgb2YgYW4gaW50ZXJ2YWwgYW5kIGl0cyB1bmRlcmx5aW5nIGRhdGEsIHNlbnQgYnkgYSBjbGllbnQuIFRoaXMgYWxsb3dzIHRoZVxyXG4vLyBpbnRlcnZhbCB0cmVlIHRvIGhhdmUgdGhlIHNhbWUgaW50ZXJ2YWwgaW5zZXJ0ZWQgbXVsdGlwbGUgdGltZXMsIGFzIGxvbmcgaXRzIGRhdGEgaXMgZGlmZmVyZW50LlxyXG4vLyBCb3RoIGluc2VydGlvbiBhbmQgZGVsZXRpb24gcmVxdWlyZSBPKGxvZyBuKSB0aW1lLiBTZWFyY2hpbmcgcmVxdWlyZXMgTyhrKmxvZ24pIHRpbWUsIHdoZXJlIGBrYFxyXG4vLyBpcyB0aGUgbnVtYmVyIG9mIGludGVydmFscyBpbiB0aGUgb3V0cHV0IGxpc3QuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIGlzU2FtZSA9IHJlcXVpcmUoXCJzaGFsbG93ZXF1YWxcIik7XHJcbmZ1bmN0aW9uIGhlaWdodChub2RlKSB7XHJcbiAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG5vZGUuaGVpZ2h0O1xyXG4gICAgfVxyXG59XHJcbnZhciBOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTm9kZShpbnRlcnZhbFRyZWUsIHJlY29yZCkge1xyXG4gICAgICAgIHRoaXMuaW50ZXJ2YWxUcmVlID0gaW50ZXJ2YWxUcmVlO1xyXG4gICAgICAgIHRoaXMucmVjb3JkcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gMDtcclxuICAgICAgICB0aGlzLmtleSA9IHJlY29yZC5sb3c7XHJcbiAgICAgICAgdGhpcy5tYXggPSByZWNvcmQuaGlnaDtcclxuICAgICAgICAvLyBTYXZlIHRoZSBhcnJheSBvZiBhbGwgcmVjb3JkcyB3aXRoIHRoZSBzYW1lIGtleSBmb3IgdGhpcyBub2RlXHJcbiAgICAgICAgdGhpcy5yZWNvcmRzLnB1c2gocmVjb3JkKTtcclxuICAgIH1cclxuICAgIC8vIEdldHMgdGhlIGhpZ2hlc3QgcmVjb3JkLmhpZ2ggdmFsdWUgZm9yIHRoaXMgbm9kZVxyXG4gICAgTm9kZS5wcm90b3R5cGUuZ2V0Tm9kZUhpZ2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGhpZ2ggPSB0aGlzLnJlY29yZHNbMF0uaGlnaDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMucmVjb3Jkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5yZWNvcmRzW2ldLmhpZ2ggPiBoaWdoKSB7XHJcbiAgICAgICAgICAgICAgICBoaWdoID0gdGhpcy5yZWNvcmRzW2ldLmhpZ2g7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGhpZ2g7XHJcbiAgICB9O1xyXG4gICAgLy8gVXBkYXRlcyBoZWlnaHQgdmFsdWUgb2YgdGhlIG5vZGUuIENhbGxlZCBkdXJpbmcgaW5zZXJ0aW9uLCByZWJhbGFuY2UsIHJlbW92YWxcclxuICAgIE5vZGUucHJvdG90eXBlLnVwZGF0ZUhlaWdodCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IE1hdGgubWF4KGhlaWdodCh0aGlzLmxlZnQpLCBoZWlnaHQodGhpcy5yaWdodCkpICsgMTtcclxuICAgIH07XHJcbiAgICAvLyBVcGRhdGVzIHRoZSBtYXggdmFsdWUgb2YgYWxsIHRoZSBwYXJlbnRzIGFmdGVyIGluc2VydGluZyBpbnRvIGFscmVhZHkgZXhpc3Rpbmcgbm9kZSwgYXMgd2VsbCBhc1xyXG4gICAgLy8gcmVtb3ZpbmcgdGhlIG5vZGUgY29tcGxldGVseSBvciByZW1vdmluZyB0aGUgcmVjb3JkIG9mIGFuIGFscmVhZHkgZXhpc3Rpbmcgbm9kZS4gU3RhcnRzIHdpdGhcclxuICAgIC8vIHRoZSBwYXJlbnQgb2YgYW4gYWZmZWN0ZWQgbm9kZSBhbmQgYnViYmxlcyB1cCB0byByb290XHJcbiAgICBOb2RlLnByb3RvdHlwZS51cGRhdGVNYXhPZlBhcmVudHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB0aGlzSGlnaCA9IHRoaXMuZ2V0Tm9kZUhpZ2goKTtcclxuICAgICAgICBpZiAodGhpcy5sZWZ0ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF4ID0gTWF0aC5tYXgoTWF0aC5tYXgodGhpcy5sZWZ0Lm1heCwgdGhpcy5yaWdodC5tYXgpLCB0aGlzSGlnaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMubGVmdCAhPT0gdW5kZWZpbmVkICYmIHRoaXMucmlnaHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IE1hdGgubWF4KHRoaXMubGVmdC5tYXgsIHRoaXNIaWdoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5sZWZ0ID09PSB1bmRlZmluZWQgJiYgdGhpcy5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF4ID0gTWF0aC5tYXgodGhpcy5yaWdodC5tYXgsIHRoaXNIaWdoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF4ID0gdGhpc0hpZ2g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xyXG4gICAgICAgICAgICB0aGlzLnBhcmVudC51cGRhdGVNYXhPZlBhcmVudHMoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIExlZnQtTGVmdCBjYXNlOlxyXG4gIFxyXG4gICAgICAgICAgIHogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlcclxuICAgICAgICAgIC8gXFwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8gICBcXFxyXG4gICAgICAgICB5ICAgVDQgICAgICBSaWdodCBSb3RhdGUgKHopICAgICAgICAgIHggICAgIHpcclxuICAgICAgICAvIFxcICAgICAgICAgIC0gLSAtIC0gLSAtIC0gLSAtPiAgICAgICAvIFxcICAgLyBcXFxyXG4gICAgICAgeCAgIFQzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUMSBUMiBUMyBUNFxyXG4gICAgICAvIFxcXHJcbiAgICBUMSAgIFQyXHJcbiAgXHJcbiAgICBMZWZ0LVJpZ2h0IGNhc2U6XHJcbiAgXHJcbiAgICAgICAgIHogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeiAgICAgICAgICAgICAgICAgICAgICAgICAgIHhcclxuICAgICAgICAvIFxcICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvIFxcICAgICAgICAgICAgICAgICAgICAgICAgLyAgIFxcXHJcbiAgICAgICB5ICAgVDQgIExlZnQgUm90YXRlICh5KSAgICAgICAgIHggIFQ0ICBSaWdodCBSb3RhdGUoeikgICAgIHkgICAgIHpcclxuICAgICAgLyBcXCAgICAgIC0gLSAtIC0gLSAtIC0gLSAtPiAgICAgLyBcXCAgICAgIC0gLSAtIC0gLSAtIC0gLT4gIC8gXFwgICAvIFxcXHJcbiAgICBUMSAgIHggICAgICAgICAgICAgICAgICAgICAgICAgICB5ICBUMyAgICAgICAgICAgICAgICAgICAgICBUMSBUMiBUMyBUNFxyXG4gICAgICAgIC8gXFwgICAgICAgICAgICAgICAgICAgICAgICAgLyBcXFxyXG4gICAgICBUMiAgIFQzICAgICAgICAgICAgICAgICAgICAgIFQxIFQyXHJcbiAgICAqL1xyXG4gICAgLy8gSGFuZGxlcyBMZWZ0LUxlZnQgY2FzZSBhbmQgTGVmdC1SaWdodCBjYXNlIGFmdGVyIHJlYmFsYW5jaW5nIEFWTCB0cmVlXHJcbiAgICBOb2RlLnByb3RvdHlwZS5fdXBkYXRlTWF4QWZ0ZXJSaWdodFJvdGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XHJcbiAgICAgICAgdmFyIGxlZnQgPSBwYXJlbnQubGVmdDtcclxuICAgICAgICAvLyBVcGRhdGUgbWF4IG9mIGxlZnQgc2libGluZyAoeCBpbiBmaXJzdCBjYXNlLCB5IGluIHNlY29uZClcclxuICAgICAgICB2YXIgdGhpc1BhcmVudExlZnRIaWdoID0gbGVmdC5nZXROb2RlSGlnaCgpO1xyXG4gICAgICAgIGlmIChsZWZ0LmxlZnQgPT09IHVuZGVmaW5lZCAmJiBsZWZ0LnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgbGVmdC5tYXggPSBNYXRoLm1heCh0aGlzUGFyZW50TGVmdEhpZ2gsIGxlZnQucmlnaHQubWF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobGVmdC5sZWZ0ICE9PSB1bmRlZmluZWQgJiYgbGVmdC5yaWdodCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGxlZnQubWF4ID0gTWF0aC5tYXgodGhpc1BhcmVudExlZnRIaWdoLCBsZWZ0LmxlZnQubWF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobGVmdC5sZWZ0ID09PSB1bmRlZmluZWQgJiYgbGVmdC5yaWdodCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGxlZnQubWF4ID0gdGhpc1BhcmVudExlZnRIaWdoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGVmdC5tYXggPSBNYXRoLm1heChNYXRoLm1heChsZWZ0LmxlZnQubWF4LCBsZWZ0LnJpZ2h0Lm1heCksIHRoaXNQYXJlbnRMZWZ0SGlnaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFVwZGF0ZSBtYXggb2YgaXRzZWxmICh6KVxyXG4gICAgICAgIHZhciB0aGlzSGlnaCA9IHRoaXMuZ2V0Tm9kZUhpZ2goKTtcclxuICAgICAgICBpZiAodGhpcy5sZWZ0ID09PSB1bmRlZmluZWQgJiYgdGhpcy5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF4ID0gTWF0aC5tYXgodGhpc0hpZ2gsIHRoaXMucmlnaHQubWF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5sZWZ0ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5yaWdodCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF4ID0gTWF0aC5tYXgodGhpc0hpZ2gsIHRoaXMubGVmdC5tYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmxlZnQgPT09IHVuZGVmaW5lZCAmJiB0aGlzLnJpZ2h0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXggPSB0aGlzSGlnaDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF4ID0gTWF0aC5tYXgoTWF0aC5tYXgodGhpcy5sZWZ0Lm1heCwgdGhpcy5yaWdodC5tYXgpLCB0aGlzSGlnaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFVwZGF0ZSBtYXggb2YgcGFyZW50ICh5IGluIGZpcnN0IGNhc2UsIHggaW4gc2Vjb25kKVxyXG4gICAgICAgIHBhcmVudC5tYXggPSBNYXRoLm1heChNYXRoLm1heChwYXJlbnQubGVmdC5tYXgsIHBhcmVudC5yaWdodC5tYXgpLCBwYXJlbnQuZ2V0Tm9kZUhpZ2goKSk7XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIFJpZ2h0LVJpZ2h0IGNhc2U6XHJcbiAgXHJcbiAgICAgIHogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeVxyXG4gICAgIC8gXFwgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyAgIFxcXHJcbiAgICBUMSAgeSAgICAgTGVmdCBSb3RhdGUoeikgICAgICAgeiAgICAgeFxyXG4gICAgICAgLyBcXCAgIC0gLSAtIC0gLSAtIC0gLT4gICAgIC8gXFwgICAvIFxcXHJcbiAgICAgIFQyICB4ICAgICAgICAgICAgICAgICAgICAgIFQxIFQyIFQzIFQ0XHJcbiAgICAgICAgIC8gXFxcclxuICAgICAgICBUMyBUNFxyXG4gIFxyXG4gICAgUmlnaHQtTGVmdCBjYXNlOlxyXG4gIFxyXG4gICAgICAgeiAgICAgICAgICAgICAgICAgICAgICAgICAgICB6ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhcclxuICAgICAgLyBcXCAgICAgICAgICAgICAgICAgICAgICAgICAgLyBcXCAgICAgICAgICAgICAgICAgICAgICAgICAvICAgXFxcclxuICAgICBUMSAgeSAgIFJpZ2h0IFJvdGF0ZSAoeSkgICAgIFQxICB4ICAgICAgTGVmdCBSb3RhdGUoeikgICB6ICAgICB5XHJcbiAgICAgICAgLyBcXCAgLSAtIC0gLSAtIC0gLSAtIC0+ICAgICAgLyBcXCAgIC0gLSAtIC0gLSAtIC0gLT4gIC8gXFwgICAvIFxcXHJcbiAgICAgICB4ICBUNCAgICAgICAgICAgICAgICAgICAgICAgIFQyICB5ICAgICAgICAgICAgICAgICAgIFQxIFQyIFQzIFQ0XHJcbiAgICAgIC8gXFwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvIFxcXHJcbiAgICBUMiAgIFQzICAgICAgICAgICAgICAgICAgICAgICAgICAgVDMgVDRcclxuICAgICovXHJcbiAgICAvLyBIYW5kbGVzIFJpZ2h0LVJpZ2h0IGNhc2UgYW5kIFJpZ2h0LUxlZnQgY2FzZSBpbiByZWJhbGFuY2luZyBBVkwgdHJlZVxyXG4gICAgTm9kZS5wcm90b3R5cGUuX3VwZGF0ZU1heEFmdGVyTGVmdFJvdGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XHJcbiAgICAgICAgdmFyIHJpZ2h0ID0gcGFyZW50LnJpZ2h0O1xyXG4gICAgICAgIC8vIFVwZGF0ZSBtYXggb2YgcmlnaHQgc2libGluZyAoeCBpbiBmaXJzdCBjYXNlLCB5IGluIHNlY29uZClcclxuICAgICAgICB2YXIgdGhpc1BhcmVudFJpZ2h0SGlnaCA9IHJpZ2h0LmdldE5vZGVIaWdoKCk7XHJcbiAgICAgICAgaWYgKHJpZ2h0LmxlZnQgPT09IHVuZGVmaW5lZCAmJiByaWdodC5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJpZ2h0Lm1heCA9IE1hdGgubWF4KHRoaXNQYXJlbnRSaWdodEhpZ2gsIHJpZ2h0LnJpZ2h0Lm1heCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHJpZ2h0LmxlZnQgIT09IHVuZGVmaW5lZCAmJiByaWdodC5yaWdodCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJpZ2h0Lm1heCA9IE1hdGgubWF4KHRoaXNQYXJlbnRSaWdodEhpZ2gsIHJpZ2h0LmxlZnQubWF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocmlnaHQubGVmdCA9PT0gdW5kZWZpbmVkICYmIHJpZ2h0LnJpZ2h0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmlnaHQubWF4ID0gdGhpc1BhcmVudFJpZ2h0SGlnaDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJpZ2h0Lm1heCA9IE1hdGgubWF4KE1hdGgubWF4KHJpZ2h0LmxlZnQubWF4LCByaWdodC5yaWdodC5tYXgpLCB0aGlzUGFyZW50UmlnaHRIaWdoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVXBkYXRlIG1heCBvZiBpdHNlbGYgKHopXHJcbiAgICAgICAgdmFyIHRoaXNIaWdoID0gdGhpcy5nZXROb2RlSGlnaCgpO1xyXG4gICAgICAgIGlmICh0aGlzLmxlZnQgPT09IHVuZGVmaW5lZCAmJiB0aGlzLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXggPSBNYXRoLm1heCh0aGlzSGlnaCwgdGhpcy5yaWdodC5tYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmxlZnQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnJpZ2h0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXggPSBNYXRoLm1heCh0aGlzSGlnaCwgdGhpcy5sZWZ0Lm1heCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMubGVmdCA9PT0gdW5kZWZpbmVkICYmIHRoaXMucmlnaHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IHRoaXNIaWdoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5tYXggPSBNYXRoLm1heChNYXRoLm1heCh0aGlzLmxlZnQubWF4LCB0aGlzLnJpZ2h0Lm1heCksIHRoaXNIaWdoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVXBkYXRlIG1heCBvZiBwYXJlbnQgKHkgaW4gZmlyc3QgY2FzZSwgeCBpbiBzZWNvbmQpXHJcbiAgICAgICAgcGFyZW50Lm1heCA9IE1hdGgubWF4KE1hdGgubWF4KHBhcmVudC5sZWZ0Lm1heCwgcmlnaHQubWF4KSwgcGFyZW50LmdldE5vZGVIaWdoKCkpO1xyXG4gICAgfTtcclxuICAgIE5vZGUucHJvdG90eXBlLl9sZWZ0Um90YXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByaWdodENoaWxkID0gdGhpcy5yaWdodDtcclxuICAgICAgICByaWdodENoaWxkLnBhcmVudCA9IHRoaXMucGFyZW50O1xyXG4gICAgICAgIGlmIChyaWdodENoaWxkLnBhcmVudCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWxUcmVlLnJvb3QgPSByaWdodENoaWxkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHJpZ2h0Q2hpbGQucGFyZW50LmxlZnQgPT09IHRoaXMpIHtcclxuICAgICAgICAgICAgICAgIHJpZ2h0Q2hpbGQucGFyZW50LmxlZnQgPSByaWdodENoaWxkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHJpZ2h0Q2hpbGQucGFyZW50LnJpZ2h0ID09PSB0aGlzKSB7XHJcbiAgICAgICAgICAgICAgICByaWdodENoaWxkLnBhcmVudC5yaWdodCA9IHJpZ2h0Q2hpbGQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0Q2hpbGQubGVmdDtcclxuICAgICAgICBpZiAodGhpcy5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmlnaHQucGFyZW50ID0gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmlnaHRDaGlsZC5sZWZ0ID0gdGhpcztcclxuICAgICAgICB0aGlzLnBhcmVudCA9IHJpZ2h0Q2hpbGQ7XHJcbiAgICAgICAgdGhpcy51cGRhdGVIZWlnaHQoKTtcclxuICAgICAgICByaWdodENoaWxkLnVwZGF0ZUhlaWdodCgpO1xyXG4gICAgfTtcclxuICAgIE5vZGUucHJvdG90eXBlLl9yaWdodFJvdGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbGVmdENoaWxkID0gdGhpcy5sZWZ0O1xyXG4gICAgICAgIGxlZnRDaGlsZC5wYXJlbnQgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICBpZiAobGVmdENoaWxkLnBhcmVudCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWxUcmVlLnJvb3QgPSBsZWZ0Q2hpbGQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAobGVmdENoaWxkLnBhcmVudC5sZWZ0ID09PSB0aGlzKSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0Q2hpbGQucGFyZW50LmxlZnQgPSBsZWZ0Q2hpbGQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobGVmdENoaWxkLnBhcmVudC5yaWdodCA9PT0gdGhpcykge1xyXG4gICAgICAgICAgICAgICAgbGVmdENoaWxkLnBhcmVudC5yaWdodCA9IGxlZnRDaGlsZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0Q2hpbGQucmlnaHQ7XHJcbiAgICAgICAgaWYgKHRoaXMubGVmdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGVmdC5wYXJlbnQgPSB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZWZ0Q2hpbGQucmlnaHQgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMucGFyZW50ID0gbGVmdENoaWxkO1xyXG4gICAgICAgIHRoaXMudXBkYXRlSGVpZ2h0KCk7XHJcbiAgICAgICAgbGVmdENoaWxkLnVwZGF0ZUhlaWdodCgpO1xyXG4gICAgfTtcclxuICAgIC8vIFJlYmFsYW5jZXMgdGhlIHRyZWUgaWYgdGhlIGhlaWdodCB2YWx1ZSBiZXR3ZWVuIHR3byBub2RlcyBvZiB0aGUgc2FtZSBwYXJlbnQgaXMgZ3JlYXRlciB0aGFuXHJcbiAgICAvLyB0d28uIFRoZXJlIGFyZSA0IGNhc2VzIHRoYXQgY2FuIGhhcHBlbiB3aGljaCBhcmUgb3V0bGluZWQgaW4gdGhlIGdyYXBoaWNzIGFib3ZlXHJcbiAgICBOb2RlLnByb3RvdHlwZS5fcmViYWxhbmNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChoZWlnaHQodGhpcy5sZWZ0KSA+PSAyICsgaGVpZ2h0KHRoaXMucmlnaHQpKSB7XHJcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gdGhpcy5sZWZ0O1xyXG4gICAgICAgICAgICBpZiAoaGVpZ2h0KGxlZnQubGVmdCkgPj0gaGVpZ2h0KGxlZnQucmlnaHQpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBMZWZ0LUxlZnQgY2FzZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmlnaHRSb3RhdGUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZU1heEFmdGVyUmlnaHRSb3RhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIExlZnQtUmlnaHQgY2FzZVxyXG4gICAgICAgICAgICAgICAgbGVmdC5fbGVmdFJvdGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmlnaHRSb3RhdGUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZU1heEFmdGVyUmlnaHRSb3RhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChoZWlnaHQodGhpcy5yaWdodCkgPj0gMiArIGhlaWdodCh0aGlzLmxlZnQpKSB7XHJcbiAgICAgICAgICAgIHZhciByaWdodCA9IHRoaXMucmlnaHQ7XHJcbiAgICAgICAgICAgIGlmIChoZWlnaHQocmlnaHQucmlnaHQpID49IGhlaWdodChyaWdodC5sZWZ0KSkge1xyXG4gICAgICAgICAgICAgICAgLy8gUmlnaHQtUmlnaHQgY2FzZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGVmdFJvdGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlTWF4QWZ0ZXJMZWZ0Um90YXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBSaWdodC1MZWZ0IGNhc2VcclxuICAgICAgICAgICAgICAgIHJpZ2h0Ll9yaWdodFJvdGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGVmdFJvdGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlTWF4QWZ0ZXJMZWZ0Um90YXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTm9kZS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKHJlY29yZCkge1xyXG4gICAgICAgIGlmIChyZWNvcmQubG93IDwgdGhpcy5rZXkpIHtcclxuICAgICAgICAgICAgLy8gSW5zZXJ0IGludG8gbGVmdCBzdWJ0cmVlXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxlZnQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sZWZ0ID0gbmV3IE5vZGUodGhpcy5pbnRlcnZhbFRyZWUsIHJlY29yZCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxlZnQucGFyZW50ID0gdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubGVmdC5pbnNlcnQocmVjb3JkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gSW5zZXJ0IGludG8gcmlnaHQgc3VidHJlZVxyXG4gICAgICAgICAgICBpZiAodGhpcy5yaWdodCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0ID0gbmV3IE5vZGUodGhpcy5pbnRlcnZhbFRyZWUsIHJlY29yZCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0LnBhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0Lmluc2VydChyZWNvcmQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgbWF4IHZhbHVlIG9mIHRoaXMgYW5jZXN0b3IgaWYgbmVlZGVkXHJcbiAgICAgICAgaWYgKHRoaXMubWF4IDwgcmVjb3JkLmhpZ2gpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXggPSByZWNvcmQuaGlnaDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVXBkYXRlIGhlaWdodCBvZiBlYWNoIG5vZGVcclxuICAgICAgICB0aGlzLnVwZGF0ZUhlaWdodCgpO1xyXG4gICAgICAgIC8vIFJlYmFsYW5jZSB0aGUgdHJlZSB0byBlbnN1cmUgYWxsIG9wZXJhdGlvbnMgYXJlIGV4ZWN1dGVkIGluIE8obG9nbikgdGltZS4gVGhpcyBpcyBlc3BlY2lhbGx5XHJcbiAgICAgICAgLy8gaW1wb3J0YW50IGluIHNlYXJjaGluZywgYXMgdGhlIHRyZWUgaGFzIGEgaGlnaCBjaGFuY2Ugb2YgZGVnZW5lcmF0aW5nIHdpdGhvdXQgdGhlIHJlYmFsYW5jaW5nXHJcbiAgICAgICAgdGhpcy5fcmViYWxhbmNlKCk7XHJcbiAgICB9O1xyXG4gICAgTm9kZS5wcm90b3R5cGUuX2dldE92ZXJsYXBwaW5nUmVjb3JkcyA9IGZ1bmN0aW9uIChjdXJyZW50Tm9kZSwgbG93LCBoaWdoKSB7XHJcbiAgICAgICAgaWYgKGN1cnJlbnROb2RlLmtleSA8PSBoaWdoICYmIGxvdyA8PSBjdXJyZW50Tm9kZS5nZXROb2RlSGlnaCgpKSB7XHJcbiAgICAgICAgICAgIC8vIE5vZGVzIGFyZSBvdmVybGFwcGluZywgY2hlY2sgaWYgaW5kaXZpZHVhbCByZWNvcmRzIGluIHRoZSBub2RlIGFyZSBvdmVybGFwcGluZ1xyXG4gICAgICAgICAgICB2YXIgdGVtcFJlc3VsdHMgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdXJyZW50Tm9kZS5yZWNvcmRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUucmVjb3Jkc1tpXS5oaWdoID49IGxvdykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRlbXBSZXN1bHRzLnB1c2goY3VycmVudE5vZGUucmVjb3Jkc1tpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRlbXBSZXN1bHRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9O1xyXG4gICAgTm9kZS5wcm90b3R5cGUuc2VhcmNoID0gZnVuY3Rpb24gKGxvdywgaGlnaCkge1xyXG4gICAgICAgIC8vIERvbid0IHNlYXJjaCBub2RlcyB0aGF0IGRvbid0IGV4aXN0XHJcbiAgICAgICAgaWYgKHRoaXMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBsZWZ0U2VhcmNoID0gW107XHJcbiAgICAgICAgdmFyIG93blNlYXJjaCA9IFtdO1xyXG4gICAgICAgIHZhciByaWdodFNlYXJjaCA9IFtdO1xyXG4gICAgICAgIC8vIElmIGludGVydmFsIGlzIHRvIHRoZSByaWdodCBvZiB0aGUgcmlnaHRtb3N0IHBvaW50IG9mIGFueSBpbnRlcnZhbCBpbiB0aGlzIG5vZGUgYW5kIGFsbCBpdHNcclxuICAgICAgICAvLyBjaGlsZHJlbiwgdGhlcmUgd29uJ3QgYmUgYW55IG1hdGNoZXNcclxuICAgICAgICBpZiAobG93ID4gdGhpcy5tYXgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTZWFyY2ggbGVmdCBjaGlsZHJlblxyXG4gICAgICAgIGlmICh0aGlzLmxlZnQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmxlZnQubWF4ID49IGxvdykge1xyXG4gICAgICAgICAgICBsZWZ0U2VhcmNoID0gdGhpcy5sZWZ0LnNlYXJjaChsb3csIGhpZ2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDaGVjayB0aGlzIG5vZGVcclxuICAgICAgICBvd25TZWFyY2ggPSB0aGlzLl9nZXRPdmVybGFwcGluZ1JlY29yZHModGhpcywgbG93LCBoaWdoKTtcclxuICAgICAgICAvLyBJZiBpbnRlcnZhbCBpcyB0byB0aGUgbGVmdCBvZiB0aGUgc3RhcnQgb2YgdGhpcyBpbnRlcnZhbCwgdGhlbiBpdCBjYW4ndCBiZSBpbiBhbnkgY2hpbGQgdG9cclxuICAgICAgICAvLyB0aGUgcmlnaHRcclxuICAgICAgICBpZiAoaGlnaCA8IHRoaXMua2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBsZWZ0U2VhcmNoLmNvbmNhdChvd25TZWFyY2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBPdGhlcndpc2UsIHNlYXJjaCByaWdodCBjaGlsZHJlblxyXG4gICAgICAgIGlmICh0aGlzLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmlnaHRTZWFyY2ggPSB0aGlzLnJpZ2h0LnNlYXJjaChsb3csIGhpZ2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSZXR1cm4gYWNjdW11bGF0ZWQgcmVzdWx0cywgaWYgYW55XHJcbiAgICAgICAgcmV0dXJuIGxlZnRTZWFyY2guY29uY2F0KG93blNlYXJjaCwgcmlnaHRTZWFyY2gpO1xyXG4gICAgfTtcclxuICAgIC8vIFNlYXJjaGVzIGZvciBhIG5vZGUgYnkgYSBga2V5YCB2YWx1ZVxyXG4gICAgTm9kZS5wcm90b3R5cGUuc2VhcmNoRXhpc3RpbmcgPSBmdW5jdGlvbiAobG93KSB7XHJcbiAgICAgICAgaWYgKHRoaXMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5rZXkgPT09IGxvdykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobG93IDwgdGhpcy5rZXkpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubGVmdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sZWZ0LnNlYXJjaEV4aXN0aW5nKGxvdyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJpZ2h0LnNlYXJjaEV4aXN0aW5nKGxvdyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH07XHJcbiAgICAvLyBSZXR1cm5zIHRoZSBzbWFsbGVzdCBub2RlIG9mIHRoZSBzdWJ0cmVlXHJcbiAgICBOb2RlLnByb3RvdHlwZS5fbWluVmFsdWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGVmdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5fbWluVmFsdWUoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTm9kZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XHJcbiAgICAgICAgaWYgKG5vZGUua2V5IDwgdGhpcy5rZXkpIHtcclxuICAgICAgICAgICAgLy8gTm9kZSB0byBiZSByZW1vdmVkIGlzIG9uIHRoZSBsZWZ0IHNpZGVcclxuICAgICAgICAgICAgaWYgKHRoaXMubGVmdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sZWZ0LnJlbW92ZShub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobm9kZS5rZXkgPiB0aGlzLmtleSkge1xyXG4gICAgICAgICAgICAvLyBOb2RlIHRvIGJlIHJlbW92ZWQgaXMgb24gdGhlIHJpZ2h0IHNpZGVcclxuICAgICAgICAgICAgaWYgKHRoaXMucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmlnaHQucmVtb3ZlKG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubGVmdCAhPT0gdW5kZWZpbmVkICYmIHRoaXMucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gTm9kZSBoYXMgdHdvIGNoaWxkcmVuXHJcbiAgICAgICAgICAgICAgICB2YXIgbWluVmFsdWUgPSB0aGlzLnJpZ2h0Ll9taW5WYWx1ZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5rZXkgPSBtaW5WYWx1ZS5rZXk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlY29yZHMgPSBtaW5WYWx1ZS5yZWNvcmRzO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmlnaHQucmVtb3ZlKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmVudC5sZWZ0ID09PSB0aGlzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBPbmUgY2hpbGQgb3Igbm8gY2hpbGQgY2FzZSBvbiBsZWZ0IHNpZGVcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQubGVmdCA9IHRoaXMucmlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yaWdodC5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQubGVmdCA9IHRoaXMubGVmdDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5sZWZ0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sZWZ0LnBhcmVudCA9IHBhcmVudDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwYXJlbnQudXBkYXRlTWF4T2ZQYXJlbnRzKCk7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnQudXBkYXRlSGVpZ2h0KCk7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnQuX3JlYmFsYW5jZSgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocGFyZW50LnJpZ2h0ID09PSB0aGlzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBPbmUgY2hpbGQgb3Igbm8gY2hpbGQgY2FzZSBvbiByaWdodCBzaWRlXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LnJpZ2h0ID0gdGhpcy5yaWdodDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0LnBhcmVudCA9IHBhcmVudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5yaWdodCA9IHRoaXMubGVmdDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5sZWZ0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sZWZ0LnBhcmVudCA9IHBhcmVudDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwYXJlbnQudXBkYXRlTWF4T2ZQYXJlbnRzKCk7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnQudXBkYXRlSGVpZ2h0KCk7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnQuX3JlYmFsYW5jZSgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE5vZGU7XHJcbn0oKSk7XHJcbmV4cG9ydHMuTm9kZSA9IE5vZGU7XHJcbnZhciBJbnRlcnZhbFRyZWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBJbnRlcnZhbFRyZWUoKSB7XHJcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XHJcbiAgICB9XHJcbiAgICBJbnRlcnZhbFRyZWUucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcclxuICAgICAgICBpZiAocmVjb3JkLmxvdyA+IHJlY29yZC5oaWdoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYGxvd2AgdmFsdWUgbXVzdCBiZSBsb3dlciBvciBlcXVhbCB0byBgaGlnaGAgdmFsdWUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMucm9vdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIC8vIEJhc2UgY2FzZTogVHJlZSBpcyBlbXB0eSwgbmV3IG5vZGUgYmVjb21lcyByb290XHJcbiAgICAgICAgICAgIHRoaXMucm9vdCA9IG5ldyBOb2RlKHRoaXMsIHJlY29yZCk7XHJcbiAgICAgICAgICAgIHRoaXMuY291bnQrKztcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIGNoZWNrIGlmIG5vZGUgYWxyZWFkeSBleGlzdHMgd2l0aCB0aGUgc2FtZSBrZXlcclxuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnJvb3Quc2VhcmNoRXhpc3RpbmcocmVjb3JkLmxvdyk7XHJcbiAgICAgICAgICAgIGlmIChub2RlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoZSByZWNvcmRzIGluIHRoaXMgbm9kZSBpZiB0aGVyZSBhbHJlYWR5IGlzIHRoZSBvbmUgd2l0aCBzYW1lIGxvdywgaGlnaCwgZGF0YVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLnJlY29yZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTYW1lKG5vZGUucmVjb3Jkc1tpXSwgcmVjb3JkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHJlY29yZCBpcyBzYW1lIGFzIHRoZSBvbmUgd2UncmUgdHJ5aW5nIHRvIGluc2VydDsgcmV0dXJuIGZhbHNlIHRvIGluZGljYXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdGhpbmcgaGFzIGJlZW4gaW5zZXJ0ZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgcmVjb3JkIHRvIHRoZSBub2RlXHJcbiAgICAgICAgICAgICAgICBub2RlLnJlY29yZHMucHVzaChyZWNvcmQpO1xyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIG1heCBvZiB0aGUgbm9kZSBhbmQgaXRzIHBhcmVudHMgaWYgbmVjZXNzYXJ5XHJcbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkLmhpZ2ggPiBub2RlLm1heCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUubWF4ID0gcmVjb3JkLmhpZ2g7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50LnVwZGF0ZU1heE9mUGFyZW50cygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuY291bnQrKztcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gTm9kZSB3aXRoIHRoaXMga2V5IGRvZXNuJ3QgYWxyZWFkeSBleGlzdC4gQ2FsbCBpbnNlcnQgZnVuY3Rpb24gb24gcm9vdCdzIG5vZGVcclxuICAgICAgICAgICAgICAgIHRoaXMucm9vdC5pbnNlcnQocmVjb3JkKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY291bnQrKztcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEludGVydmFsVHJlZS5wcm90b3R5cGUuc2VhcmNoID0gZnVuY3Rpb24gKGxvdywgaGlnaCkge1xyXG4gICAgICAgIGlmICh0aGlzLnJvb3QgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAvLyBUcmVlIGlzIGVtcHR5OyByZXR1cm4gZW1wdHkgYXJyYXlcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5zZWFyY2gobG93LCBoaWdoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgSW50ZXJ2YWxUcmVlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAocmVjb3JkKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucm9vdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIC8vIFRyZWUgaXMgZW1wdHk7IG5vdGhpbmcgdG8gcmVtb3ZlXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5yb290LnNlYXJjaEV4aXN0aW5nKHJlY29yZC5sb3cpO1xyXG4gICAgICAgICAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5yZWNvcmRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZW1vdmVkUmVjb3JkID0gdm9pZCAwO1xyXG4gICAgICAgICAgICAgICAgLy8gTm9kZSB3aXRoIHRoaXMga2V5IGhhcyAyIG9yIG1vcmUgcmVjb3Jkcy4gRmluZCB0aGUgb25lIHdlIG5lZWQgYW5kIHJlbW92ZSBpdFxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLnJlY29yZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTYW1lKG5vZGUucmVjb3Jkc1tpXSwgcmVjb3JkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkUmVjb3JkID0gbm9kZS5yZWNvcmRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnJlY29yZHMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocmVtb3ZlZFJlY29yZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWRSZWNvcmQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIG1heCBvZiB0aGF0IG5vZGUgYW5kIGl0cyBwYXJlbnRzIGlmIG5lY2Vzc2FyeVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNvcmQuaGlnaCA9PT0gbm9kZS5tYXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVIaWdoID0gbm9kZS5nZXROb2RlSGlnaCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5sZWZ0ICE9PSB1bmRlZmluZWQgJiYgbm9kZS5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLm1heCA9IE1hdGgubWF4KE1hdGgubWF4KG5vZGUubGVmdC5tYXgsIG5vZGUucmlnaHQubWF4KSwgbm9kZUhpZ2gpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUubGVmdCAhPT0gdW5kZWZpbmVkICYmIG5vZGUucmlnaHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5tYXggPSBNYXRoLm1heChub2RlLmxlZnQubWF4LCBub2RlSGlnaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5sZWZ0ID09PSB1bmRlZmluZWQgJiYgbm9kZS5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLm1heCA9IE1hdGgubWF4KG5vZGUucmlnaHQubWF4LCBub2RlSGlnaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLm1heCA9IG5vZGVIaWdoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnQudXBkYXRlTWF4T2ZQYXJlbnRzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb3VudC0tO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUucmVjb3Jkcy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vZGUgd2l0aCB0aGlzIGtleSBoYXMgb25seSAxIHJlY29yZC4gQ2hlY2sgaWYgdGhlIHJlbWFpbmluZyByZWNvcmQgaW4gdGhpcyBub2RlIGlzXHJcbiAgICAgICAgICAgICAgICAvLyBhY3R1YWxseSB0aGUgb25lIHdlIHdhbnQgdG8gcmVtb3ZlXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNTYW1lKG5vZGUucmVjb3Jkc1swXSwgcmVjb3JkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZW1haW5pbmcgcmVjb3JkIGlzIHRoZSBvbmUgd2Ugd2FudCB0byByZW1vdmUuIFJlbW92ZSB0aGUgd2hvbGUgbm9kZSBmcm9tIHRoZSB0cmVlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucm9vdC5rZXkgPT09IG5vZGUua2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlJ3JlIHJlbW92aW5nIHRoZSByb290IGVsZW1lbnQuIENyZWF0ZSBhIGR1bW15IG5vZGUgdGhhdCB3aWxsIHRlbXBvcmFyaWx5IHRha2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcm9vdCdzIHBhcmVudCByb2xlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb290UGFyZW50ID0gbmV3IE5vZGUodGhpcywgeyBsb3c6IHJlY29yZC5sb3csIGhpZ2g6IHJlY29yZC5sb3cgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RQYXJlbnQubGVmdCA9IHRoaXMucm9vdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yb290LnBhcmVudCA9IHJvb3RQYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZW1vdmVkTm9kZSA9IHRoaXMucm9vdC5yZW1vdmUobm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucm9vdCA9IHJvb3RQYXJlbnQubGVmdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucm9vdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJvb3QucGFyZW50ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZW1vdmVkTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZE5vZGUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvdW50LS07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlbW92ZWROb2RlID0gdGhpcy5yb290LnJlbW92ZShub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlbW92ZWROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkTm9kZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY291bnQtLTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJlbWFpbmluZyByZWNvcmQgaXMgbm90IHRoZSBvbmUgd2Ugd2FudCB0byByZW1vdmVcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBObyByZWNvcmRzIGF0IGFsbCBpbiB0aGlzIG5vZGU/ISBTaG91bGRuJ3QgaGFwcGVuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgSW50ZXJ2YWxUcmVlLnByb3RvdHlwZS5pbk9yZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgSW5PcmRlcih0aGlzLnJvb3QpO1xyXG4gICAgfTtcclxuICAgIEludGVydmFsVHJlZS5wcm90b3R5cGUucHJlT3JkZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcmVPcmRlcih0aGlzLnJvb3QpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBJbnRlcnZhbFRyZWU7XHJcbn0oKSk7XHJcbmV4cG9ydHMuSW50ZXJ2YWxUcmVlID0gSW50ZXJ2YWxUcmVlO1xyXG52YXIgRGF0YUludGVydmFsVHJlZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERhdGFJbnRlcnZhbFRyZWUoKSB7XHJcbiAgICAgICAgdGhpcy50cmVlID0gbmV3IEludGVydmFsVHJlZSgpO1xyXG4gICAgfVxyXG4gICAgRGF0YUludGVydmFsVHJlZS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKGxvdywgaGlnaCwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRyZWUuaW5zZXJ0KHsgbG93OiBsb3csIGhpZ2g6IGhpZ2gsIGRhdGE6IGRhdGEgfSk7XHJcbiAgICB9O1xyXG4gICAgRGF0YUludGVydmFsVHJlZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGxvdywgaGlnaCwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRyZWUucmVtb3ZlKHsgbG93OiBsb3csIGhpZ2g6IGhpZ2gsIGRhdGE6IGRhdGEgfSk7XHJcbiAgICB9O1xyXG4gICAgRGF0YUludGVydmFsVHJlZS5wcm90b3R5cGUuc2VhcmNoID0gZnVuY3Rpb24gKGxvdywgaGlnaCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRyZWUuc2VhcmNoKGxvdywgaGlnaCkubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiB2LmRhdGE7IH0pO1xyXG4gICAgfTtcclxuICAgIERhdGFJbnRlcnZhbFRyZWUucHJvdG90eXBlLmluT3JkZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZS5pbk9yZGVyKCk7XHJcbiAgICB9O1xyXG4gICAgRGF0YUludGVydmFsVHJlZS5wcm90b3R5cGUucHJlT3JkZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZS5wcmVPcmRlcigpO1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhSW50ZXJ2YWxUcmVlLnByb3RvdHlwZSwgXCJjb3VudFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyZWUuY291bnQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gRGF0YUludGVydmFsVHJlZTtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRGF0YUludGVydmFsVHJlZTtcclxudmFyIEluT3JkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBJbk9yZGVyKHN0YXJ0Tm9kZSkge1xyXG4gICAgICAgIHRoaXMuc3RhY2sgPSBbXTtcclxuICAgICAgICBpZiAoc3RhcnROb2RlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5wdXNoKHN0YXJ0Tm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgSW5PcmRlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBXaWxsIG9ubHkgaGFwcGVuIGlmIHN0YWNrIGlzIGVtcHR5IGFuZCBwb3AgaXMgY2FsbGVkXHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudE5vZGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgZG9uZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFByb2Nlc3MgdGhpcyBub2RlXHJcbiAgICAgICAgaWYgKHRoaXMuaSA8IHRoaXMuY3VycmVudE5vZGUucmVjb3Jkcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuY3VycmVudE5vZGUucmVjb3Jkc1t0aGlzLmkrK10sXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnROb2RlLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5wdXNoKHRoaXMuY3VycmVudE5vZGUucmlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gTWlnaHQgcG9wIHRoZSBsYXN0IGFuZCBzZXQgdGhpcy5jdXJyZW50Tm9kZSA9IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICB0aGlzLnBvcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5uZXh0KCk7XHJcbiAgICB9O1xyXG4gICAgSW5PcmRlci5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50Tm9kZSA9IG5vZGU7XHJcbiAgICAgICAgdGhpcy5pID0gMDtcclxuICAgICAgICB3aGlsZSAodGhpcy5jdXJyZW50Tm9kZS5sZWZ0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRoaXMuY3VycmVudE5vZGUpO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnROb2RlID0gdGhpcy5jdXJyZW50Tm9kZS5sZWZ0O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBJbk9yZGVyLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50Tm9kZSA9IHRoaXMuc3RhY2sucG9wKCk7XHJcbiAgICAgICAgdGhpcy5pID0gMDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gSW5PcmRlcjtcclxufSgpKTtcclxuZXhwb3J0cy5Jbk9yZGVyID0gSW5PcmRlcjtcclxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcclxuICAgIEluT3JkZXIucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xyXG59XHJcbnZhciBQcmVPcmRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFByZU9yZGVyKHN0YXJ0Tm9kZSkge1xyXG4gICAgICAgIHRoaXMuc3RhY2sgPSBbXTtcclxuICAgICAgICB0aGlzLmkgPSAwO1xyXG4gICAgICAgIHRoaXMuY3VycmVudE5vZGUgPSBzdGFydE5vZGU7XHJcbiAgICB9XHJcbiAgICBQcmVPcmRlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBXaWxsIG9ubHkgaGFwcGVuIGlmIHN0YWNrIGlzIGVtcHR5IGFuZCBwb3AgaXMgY2FsbGVkLFxyXG4gICAgICAgIC8vIHdoaWNoIG9ubHkgaGFwcGVucyBpZiB0aGVyZSBpcyBubyByaWdodCBub2RlIChpLmUgd2UgYXJlIGRvbmUpXHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudE5vZGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgZG9uZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFByb2Nlc3MgdGhpcyBub2RlXHJcbiAgICAgICAgaWYgKHRoaXMuaSA8IHRoaXMuY3VycmVudE5vZGUucmVjb3Jkcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuY3VycmVudE5vZGUucmVjb3Jkc1t0aGlzLmkrK10sXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnROb2RlLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5wdXNoKHRoaXMuY3VycmVudE5vZGUucmlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50Tm9kZS5sZWZ0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5wdXNoKHRoaXMuY3VycmVudE5vZGUubGVmdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucG9wKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dCgpO1xyXG4gICAgfTtcclxuICAgIFByZU9yZGVyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICB0aGlzLnN0YWNrLnB1c2gobm9kZSk7XHJcbiAgICB9O1xyXG4gICAgUHJlT3JkZXIucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnROb2RlID0gdGhpcy5zdGFjay5wb3AoKTtcclxuICAgICAgICB0aGlzLmkgPSAwO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBQcmVPcmRlcjtcclxufSgpKTtcclxuZXhwb3J0cy5QcmVPcmRlciA9IFByZU9yZGVyO1xyXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgUHJlT3JkZXIucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9Vc2Vycy9jcnV6bW9saW5hL0NvZGUvdHJ1ZmZsZS1wcm9qZWN0cy90cnVmZmxlL25vZGVfbW9kdWxlcy9ub2RlLWludGVydmFsLXRyZWUvbGliL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmpBLCBvYmpCLCBjb21wYXJlLCBjb21wYXJlQ29udGV4dCkge1xuICB2YXIgcmV0ID0gY29tcGFyZSA/IGNvbXBhcmUuY2FsbChjb21wYXJlQ29udGV4dCwgb2JqQSwgb2JqQikgOiB2b2lkIDA7XG5cbiAgaWYgKHJldCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuICEhcmV0O1xuICB9XG5cbiAgaWYgKG9iakEgPT09IG9iakIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqQSAhPT0gXCJvYmplY3RcIiB8fCAhb2JqQSB8fCB0eXBlb2Ygb2JqQiAhPT0gXCJvYmplY3RcIiB8fCAhb2JqQikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpO1xuICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcblxuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgYkhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5iaW5kKG9iakIpO1xuXG4gIC8vIFRlc3QgZm9yIEEncyBrZXlzIGRpZmZlcmVudCBmcm9tIEIuXG4gIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGtleXNBLmxlbmd0aDsgaWR4KyspIHtcbiAgICB2YXIga2V5ID0ga2V5c0FbaWR4XTtcblxuICAgIGlmICghYkhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWVBID0gb2JqQVtrZXldO1xuICAgIHZhciB2YWx1ZUIgPSBvYmpCW2tleV07XG5cbiAgICByZXQgPSBjb21wYXJlID8gY29tcGFyZS5jYWxsKGNvbXBhcmVDb250ZXh0LCB2YWx1ZUEsIHZhbHVlQiwga2V5KSA6IHZvaWQgMDtcblxuICAgIGlmIChyZXQgPT09IGZhbHNlIHx8IChyZXQgPT09IHZvaWQgMCAmJiB2YWx1ZUEgIT09IHZhbHVlQikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvVXNlcnMvY3J1em1vbGluYS9Db2RlL3RydWZmbGUtcHJvamVjdHMvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvc2hhbGxvd2VxdWFsL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9wcm9kdWN0aW9uXCIpO1xufSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PSBcInRlc3RcIikge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3Rlc3RcIik7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2RldmVsb3BtZW50XCIpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9zdG9yZS9pbmRleC5qcyIsImltcG9ydCBjb25maWd1cmVTdG9yZSBmcm9tIFwiLi9jb21tb25cIjtcbmV4cG9ydCBkZWZhdWx0IGNvbmZpZ3VyZVN0b3JlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9zdG9yZS9wcm9kdWN0aW9uLmpzIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOnN0b3JlOmNvbW1vblwiKTtcbmNvbnN0IHJlZHV4RGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOnJlZHV4XCIpO1xuXG5pbXBvcnQgeyBjb21wb3NlLCBjcmVhdGVTdG9yZSwgYXBwbHlNaWRkbGV3YXJlIH0gZnJvbSBcInJlZHV4XCI7XG5pbXBvcnQgY3JlYXRlU2FnYU1pZGRsZXdhcmUgZnJvbSBcInJlZHV4LXNhZ2FcIjtcbmltcG9ydCBjcmVhdGVMb2dnZXIgZnJvbSBcInJlZHV4LWNsaS1sb2dnZXJcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGFiYnJldmlhdGVWYWx1ZXModmFsdWUsIG9wdGlvbnMgPSB7fSwgZGVwdGggPSAwKSB7XG4gIG9wdGlvbnMuc3RyaW5nTGltaXQgPSBvcHRpb25zLnN0cmluZ0xpbWl0IHx8IDY2O1xuICBvcHRpb25zLmFycmF5TGltaXQgPSBvcHRpb25zLmFycmF5TGltaXQgfHwgODtcbiAgb3B0aW9ucy5yZWN1cnNlTGltaXQgPSBvcHRpb25zLnJlY3Vyc2VMaW1pdCB8fCA0O1xuXG4gIGlmIChkZXB0aCA+IG9wdGlvbnMucmVjdXJzZUxpbWl0KSB7XG4gICAgcmV0dXJuIFwiLi4uXCI7XG4gIH1cblxuICBjb25zdCByZWN1cnNlID0gKGNoaWxkKSA9PiBhYmJyZXZpYXRlVmFsdWVzKGNoaWxkLCBvcHRpb25zLCBkZXB0aCArIDEpO1xuXG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgaWYgKHZhbHVlLmxlbmd0aCA+IG9wdGlvbnMuYXJyYXlMaW1pdCkge1xuICAgICAgdmFsdWUgPSBbXG4gICAgICAgIC4uLnZhbHVlLnNsaWNlKDAsIG9wdGlvbnMuYXJyYXlMaW1pdCAvIDIpLFxuICAgICAgICBcIi4uLlwiLFxuICAgICAgICAuLi52YWx1ZS5zbGljZSh2YWx1ZS5sZW5ndGggLSBvcHRpb25zLmFycmF5TGltaXQgLyAyICsgMSlcbiAgICAgIF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlLm1hcChyZWN1cnNlKTtcblxuICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sXG4gICAgICAuLi5PYmplY3QuZW50cmllcyh2YWx1ZSkubWFwKFxuICAgICAgICAoW2ssIHZdKSA9PiAoeyBbcmVjdXJzZShrKV06IHJlY3Vyc2UodikgfSlcbiAgICAgIClcbiAgICApO1xuXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlLmxlbmd0aCA+IG9wdGlvbnMuc3RyaW5nTGltaXQpIHtcbiAgICBsZXQgaW5uZXIgPSBcIi4uLlwiO1xuICAgIGxldCBleHRyYWN0QW1vdW50ID0gKG9wdGlvbnMuc3RyaW5nTGltaXQgLSBpbm5lci5sZW5ndGgpIC8gMjtcbiAgICBsZXQgbGVhZGluZyA9IHZhbHVlLnNsaWNlKDAsIE1hdGguY2VpbChleHRyYWN0QW1vdW50KSk7XG4gICAgbGV0IHRyYWlsaW5nID0gdmFsdWUuc2xpY2UodmFsdWUubGVuZ3RoIC0gTWF0aC5mbG9vcihleHRyYWN0QW1vdW50KSk7XG4gICAgcmV0dXJuIGAke2xlYWRpbmd9JHtpbm5lcn0ke3RyYWlsaW5nfWA7XG5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29uZmlndXJlU3RvcmUgKHJlZHVjZXIsIHNhZ2EsIGluaXRpYWxTdGF0ZSwgY29tcG9zZUVuaGFuY2Vycykge1xuICBjb25zdCBzYWdhTWlkZGxld2FyZSA9IGNyZWF0ZVNhZ2FNaWRkbGV3YXJlKCk7XG5cbiAgaWYgKCFjb21wb3NlRW5oYW5jZXJzKSB7XG4gICAgY29tcG9zZUVuaGFuY2VycyA9IGNvbXBvc2U7XG4gIH1cblxuICBjb25zdCBsb2dnZXJNaWRkbGV3YXJlID0gY3JlYXRlTG9nZ2VyKHtcbiAgICBsb2c6IHJlZHV4RGVidWcsXG4gICAgc3RhdGVUcmFuc2Zvcm1lcjogKHN0YXRlKSA9PiBhYmJyZXZpYXRlVmFsdWVzKHN0YXRlLCB7XG4gICAgICBhcnJheUxpbWl0OiA0LFxuICAgICAgcmVjdXJzZUxpbWl0OiAzXG4gICAgfSksXG4gICAgYWN0aW9uVHJhbnNmb3JtZXI6IGFiYnJldmlhdGVWYWx1ZXMsXG4gIH0pO1xuXG4gIGxldCBzdG9yZSA9IGNyZWF0ZVN0b3JlKFxuICAgIHJlZHVjZXIsIGluaXRpYWxTdGF0ZSxcblxuICAgIGNvbXBvc2VFbmhhbmNlcnMoXG4gICAgICBhcHBseU1pZGRsZXdhcmUoXG4gICAgICAgIHNhZ2FNaWRkbGV3YXJlLFxuICAgICAgICBsb2dnZXJNaWRkbGV3YXJlXG4gICAgICApXG4gICAgKVxuICApO1xuXG4gIHNhZ2FNaWRkbGV3YXJlLnJ1bihzYWdhKTtcblxuICByZXR1cm4gc3RvcmU7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3N0b3JlL2NvbW1vbi5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlZHV4LXNhZ2FcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJyZWR1eC1zYWdhXCJcbi8vIG1vZHVsZSBpZCA9IDQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlZHV4LWNsaS1sb2dnZXJcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJyZWR1eC1jbGktbG9nZ2VyXCJcbi8vIG1vZHVsZSBpZCA9IDQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjpzZXNzaW9uOnNhZ2FzXCIpO1xuXG5pbXBvcnQgeyBjYW5jZWwsIGNhbGwsIGFsbCwgZm9yaywgdGFrZSwgcHV0IH0gZnJvbSAncmVkdXgtc2FnYS9lZmZlY3RzJztcblxuaW1wb3J0IHsgcHJlZml4TmFtZSB9IGZyb20gXCJsaWIvaGVscGVyc1wiO1xuXG5pbXBvcnQgKiBhcyBhc3QgZnJvbSBcImxpYi9hc3Qvc2FnYXNcIjtcbmltcG9ydCAqIGFzIGNvbnRyb2xsZXIgZnJvbSBcImxpYi9jb250cm9sbGVyL3NhZ2FzXCI7XG5pbXBvcnQgKiBhcyBzb2xpZGl0eSBmcm9tIFwibGliL3NvbGlkaXR5L3NhZ2FzXCI7XG5pbXBvcnQgKiBhcyBldm0gZnJvbSBcImxpYi9ldm0vc2FnYXNcIjtcbmltcG9ydCAqIGFzIHRyYWNlIGZyb20gXCJsaWIvdHJhY2Uvc2FnYXNcIjtcbmltcG9ydCAqIGFzIGRhdGEgZnJvbSBcImxpYi9kYXRhL3NhZ2FzXCI7XG5pbXBvcnQgKiBhcyB3ZWIzIGZyb20gXCJsaWIvd2ViMy9zYWdhc1wiO1xuXG5pbXBvcnQgKiBhcyBhY3Rpb25zIGZyb20gXCIuLi9hY3Rpb25zXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiAqc2FnYSAoKSB7XG4gIGRlYnVnKFwic3RhcnRpbmcgbGlzdGVuZXJzXCIpO1xuICBsZXQgbGlzdGVuZXJzID0geWllbGQgKmZvcmtMaXN0ZW5lcnMoKTtcblxuICAvLyByZWNlaXZpbmcgJiBzYXZpbmcgY29udHJhY3RzIGludG8gc3RhdGVcbiAgZGVidWcoXCJ3YWl0aW5nIGZvciBjb250cmFjdCBpbmZvcm1hdGlvblwiKTtcbiAgbGV0IHsgY29udGV4dHMsIHNvdXJjZXMgfSA9IHlpZWxkIHRha2UoYWN0aW9ucy5SRUNPUkRfQ09OVFJBQ1RTKTtcblxuICBkZWJ1ZyhcInJlY29yZGluZyBjb250cmFjdCBiaW5hcmllc1wiKTtcbiAgeWllbGQgKnJlY29yZENvbnRleHRzKC4uLmNvbnRleHRzKTtcblxuICBkZWJ1ZyhcInJlY29yZGluZyBjb250cmFjdCBzb3VyY2VzXCIpO1xuICB5aWVsZCAqcmVjb3JkU291cmNlcyguLi5zb3VyY2VzKTtcblxuICBkZWJ1ZyhcIndhaXRpbmcgZm9yIHN0YXJ0XCIpO1xuICAvLyB3YWl0IGZvciBzdGFydCBzaWduYWxcbiAgbGV0IHt0eEhhc2gsIHByb3ZpZGVyfSA9IHlpZWxkIHRha2UoYWN0aW9ucy5TVEFSVCk7XG4gIGRlYnVnKFwic3RhcnRpbmdcIik7XG5cbiAgLy8gcHJvY2VzcyB0cmFuc2FjdGlvblxuICBkZWJ1ZyhcImZldGNoaW5nIHRyYW5zYWN0aW9uIGluZm9cIik7XG4gIGxldCBlcnIgPSB5aWVsZCAqZmV0Y2hUeCh0eEhhc2gsIHByb3ZpZGVyKTtcbiAgaWYgKGVycikge1xuICAgIGRlYnVnKFwiZXJyb3IgJW9cIiwgZXJyKTtcbiAgICB5aWVsZCAqZXJyb3IoZXJyKTtcblxuICB9IGVsc2Uge1xuICAgIGRlYnVnKFwidmlzaXRpbmcgQVNUc1wiKTtcbiAgICAvLyB2aXNpdCBhc3RzXG4gICAgeWllbGQgKmFzdC52aXNpdEFsbCgpO1xuXG4gICAgZGVidWcoXCJyZWFkeWluZ1wiKTtcbiAgICAvLyBzaWduYWwgdGhhdCBzdGVwcGluZyBjYW4gYmVnaW5cbiAgICB5aWVsZCAqcmVhZHkoKTtcblxuICAgIGRlYnVnKFwid2FpdGluZyBmb3IgdHJhY2UgRU9UXCIpO1xuICAgIC8vIHdhaXQgdW50aWwgdHJhY2UgaGl0cyBFT1RcbiAgICB5aWVsZCAqdHJhY2Uud2FpdCgpO1xuXG4gICAgZGVidWcoXCJmaW5pc2hpbmdcIik7XG4gICAgLy8gZmluaXNoXG4gICAgeWllbGQgcHV0KGFjdGlvbnMuZmluaXNoKCkpO1xuICB9XG5cbiAgZGVidWcoXCJzdG9wcGluZyBsaXN0ZW5lcnNcIik7XG4gIHlpZWxkIGFsbChcbiAgICBsaXN0ZW5lcnMubWFwKHRhc2sgPT4gY2FuY2VsKHRhc2spKVxuICApO1xufVxuXG5leHBvcnQgZGVmYXVsdCBwcmVmaXhOYW1lKFwic2Vzc2lvblwiLCBzYWdhKTtcblxuXG5mdW5jdGlvbiAqZm9ya0xpc3RlbmVycygpIHtcbiAgcmV0dXJuIHlpZWxkIGFsbChcbiAgICBbYXN0LCBjb250cm9sbGVyLCBkYXRhLCBldm0sIHNvbGlkaXR5LCB0cmFjZSwgd2ViM11cbiAgICAgIC5tYXAoIGFwcCA9PiBmb3JrKGFwcC5zYWdhKSApXG4gICk7XG59XG5cbmZ1bmN0aW9uKiBmZXRjaFR4KHR4SGFzaCwgcHJvdmlkZXIpIHtcbiAgbGV0IHJlc3VsdCA9IHlpZWxkICp3ZWIzLmluc3BlY3RUcmFuc2FjdGlvbih0eEhhc2gsIHByb3ZpZGVyKTtcblxuICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgcmV0dXJuIHJlc3VsdC5lcnJvcjtcbiAgfVxuXG4gIHlpZWxkICpldm0uYmVnaW4ocmVzdWx0KTtcblxuICBsZXQgYWRkcmVzc2VzID0geWllbGQgKnRyYWNlLnByb2Nlc3NUcmFjZShyZXN1bHQudHJhY2UpO1xuICBpZiAocmVzdWx0LmFkZHJlc3MgJiYgYWRkcmVzc2VzLmluZGV4T2YocmVzdWx0LmFkZHJlc3MpID09IC0xKSB7XG4gICAgYWRkcmVzc2VzLnB1c2gocmVzdWx0LmFkZHJlc3MpO1xuICB9XG5cbiAgbGV0IGJpbmFyaWVzID0geWllbGQgKndlYjMub2J0YWluQmluYXJpZXMoYWRkcmVzc2VzKTtcblxuICB5aWVsZCBhbGwoXG4gICAgYWRkcmVzc2VzLm1hcCggKGFkZHJlc3MsIGkpID0+IGNhbGwocmVjb3JkSW5zdGFuY2UsIGFkZHJlc3MsIGJpbmFyaWVzW2ldKSApXG4gICk7XG59XG5cbmZ1bmN0aW9uKiByZWNvcmRDb250ZXh0cyguLi5jb250ZXh0cykge1xuICBmb3IgKGxldCB7IGNvbnRyYWN0TmFtZSwgYmluYXJ5LCBzb3VyY2VNYXAgfSBvZiBjb250ZXh0cykge1xuICAgIHlpZWxkICpldm0uYWRkQ29udGV4dChjb250cmFjdE5hbWUsIGJpbmFyeSk7XG5cbiAgICBpZiAoc291cmNlTWFwKSB7XG4gICAgICB5aWVsZCAqc29saWRpdHkuYWRkU291cmNlTWFwKGJpbmFyeSwgc291cmNlTWFwKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24qIHJlY29yZFNvdXJjZXMoLi4uc291cmNlcykge1xuICBmb3IgKGxldCB7IHNvdXJjZVBhdGgsIHNvdXJjZSwgYXN0IH0gb2Ygc291cmNlcykge1xuICAgIHlpZWxkICpzb2xpZGl0eS5hZGRTb3VyY2Uoc291cmNlLCBzb3VyY2VQYXRoLCBhc3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uICpyZWNvcmRJbnN0YW5jZShhZGRyZXNzLCBiaW5hcnkpIHtcbiAgeWllbGQgKmV2bS5hZGRJbnN0YW5jZShhZGRyZXNzLCBiaW5hcnkpO1xufVxuXG5mdW5jdGlvbiAqcmVhZHkoKSB7XG4gIHlpZWxkIHB1dChhY3Rpb25zLnJlYWR5KCkpO1xufVxuXG5mdW5jdGlvbiAqZXJyb3IoZXJyKSB7XG4gIHlpZWxkIHB1dChhY3Rpb25zLmVycm9yKGVycikpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9zZXNzaW9uL3NhZ2FzL2luZGV4LmpzIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOmFzdDpzYWdhc1wiKTtcblxuaW1wb3J0IHsgYWxsLCBjYWxsLCByYWNlLCBmb3JrLCBqb2luLCB0YWtlLCB0YWtlRXZlcnksIHB1dCwgc2VsZWN0IH0gZnJvbSBcInJlZHV4LXNhZ2EvZWZmZWN0c1wiO1xuXG5pbXBvcnQgeyBwcmVmaXhOYW1lIH0gZnJvbSBcImxpYi9oZWxwZXJzXCI7XG5cbmltcG9ydCAqIGFzIGRhdGEgZnJvbSBcImxpYi9kYXRhL3NhZ2FzXCI7XG5cbmltcG9ydCAqIGFzIGFjdGlvbnMgZnJvbSBcIi4uL2FjdGlvbnNcIjtcblxuaW1wb3J0IGFzdCBmcm9tIFwiLi4vc2VsZWN0b3JzXCI7XG5cblxuZnVuY3Rpb24gKndhbGsoc291cmNlSWQsIG5vZGUsIHBvaW50ZXIgPSBcIlwiLCBwYXJlbnRJZCA9IG51bGwpIHtcbiAgZGVidWcoXCJ3YWxraW5nICVvICVvXCIsIHBvaW50ZXIsIG5vZGUpO1xuXG4gIHlpZWxkICpoYW5kbGVFbnRlcihzb3VyY2VJZCwgbm9kZSwgcG9pbnRlciwgcGFyZW50SWQpO1xuXG4gIGlmIChub2RlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICBmb3IgKGxldCBbaSwgY2hpbGRdIG9mIG5vZGUuZW50cmllcygpKSB7XG4gICAgICB5aWVsZCBjYWxsKHdhbGssIHNvdXJjZUlkLCBjaGlsZCwgYCR7cG9pbnRlcn0vJHtpfWAsIHBhcmVudElkKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgIGZvciAobGV0IFtrZXksIGNoaWxkXSBvZiBPYmplY3QuZW50cmllcyhub2RlKSkge1xuICAgICAgeWllbGQgY2FsbCh3YWxrLCBzb3VyY2VJZCwgY2hpbGQsIGAke3BvaW50ZXJ9LyR7a2V5fWAsIG5vZGUuaWQpO1xuICAgIH1cbiAgfVxuXG4gIHlpZWxkICpoYW5kbGVFeGl0KHNvdXJjZUlkLCBub2RlLCBwb2ludGVyKTtcbn1cblxuZnVuY3Rpb24gKmhhbmRsZUVudGVyKHNvdXJjZUlkLCBub2RlLCBwb2ludGVyLCBwYXJlbnRJZCkge1xuICBpZiAoIShub2RlIGluc3RhbmNlb2YgT2JqZWN0KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGRlYnVnKFwiZW50ZXJpbmcgJXNcIiwgcG9pbnRlcik7XG5cbiAgaWYgKG5vZGUuaWQgIT09IHVuZGVmaW5lZCkge1xuICAgIGRlYnVnKFwiJXMgcmVjb3JkaW5nIHNjb3BlICVzXCIsIHBvaW50ZXIsIG5vZGUuaWQpO1xuICAgIHlpZWxkICpkYXRhLnNjb3BlKG5vZGUuaWQsIHBvaW50ZXIsIHBhcmVudElkLCBzb3VyY2VJZCk7XG4gIH1cblxuICBzd2l0Y2ggKG5vZGUubm9kZVR5cGUpIHtcbiAgICBjYXNlIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiOlxuICAgICAgZGVidWcoXCIlcyByZWNvcmRpbmcgdmFyaWFibGUgJW9cIiwgcG9pbnRlciwgbm9kZSk7XG4gICAgICB5aWVsZCAqZGF0YS5kZWNsYXJlKG5vZGUpO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuZnVuY3Rpb24gKmhhbmRsZUV4aXQoc291cmNlSWQsIG5vZGUsIHBvaW50ZXIpIHtcbiAgZGVidWcoXCJleGl0aW5nICVzXCIsIHBvaW50ZXIpO1xuXG4gIC8vIG5vLW9wIHJpZ2h0IG5vd1xufVxuXG5mdW5jdGlvbiAqd2Fsa1NhZ2Eoe3NvdXJjZUlkLCBhc3R9KSB7XG4gIHlpZWxkIHdhbGsoc291cmNlSWQsIGFzdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiAqdmlzaXRBbGwoaWR4KSB7XG4gIGxldCBzb3VyY2VzID0geWllbGQgc2VsZWN0KGFzdC52aWV3cy5zb3VyY2VzKTtcblxuICBsZXQgdGFza3MgPSB5aWVsZCBhbGwoXG4gICAgT2JqZWN0LmVudHJpZXMoc291cmNlcylcbiAgICAgIC5maWx0ZXIoIChbaWQsIHthc3R9XSkgPT4gISFhc3QgKVxuICAgICAgLm1hcCggKFtpZCwge2FzdH1dKSA9PiBmb3JrKCAoKSA9PiBwdXQoYWN0aW9ucy52aXNpdChpZCwgYXN0KSkpIClcbiAgKVxuXG4gIGlmICh0YXNrcy5sZW5ndGggPiAwKSB7XG4gICAgeWllbGQgam9pbiguLi50YXNrcyk7XG4gIH1cblxuICB5aWVsZCBwdXQoYWN0aW9ucy5kb25lVmlzaXRpbmcoKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogc2FnYSgpIHtcbiAgeWllbGQgcmFjZSh7XG4gICAgdmlzaXRvcjogdGFrZUV2ZXJ5KGFjdGlvbnMuVklTSVQsIHdhbGtTYWdhKSxcbiAgICBkb25lOiB0YWtlKGFjdGlvbnMuRE9ORV9WSVNJVElORylcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHByZWZpeE5hbWUoXCJhc3RcIiwgc2FnYSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2FzdC9zYWdhcy9pbmRleC5qcyIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjpkYXRhOmRlY29kZVwiKTtcblxuaW1wb3J0IHtCaWdOdW1iZXJ9IGZyb20gXCJiaWdudW1iZXIuanNcIjtcblxuaW1wb3J0ICogYXMgbWVtb3J5IGZyb20gXCIuL21lbW9yeVwiO1xuaW1wb3J0ICogYXMgc3RvcmFnZSBmcm9tIFwiLi9zdG9yYWdlXCI7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tIFwiLi91dGlsc1wiO1xuaW1wb3J0IHsgV09SRF9TSVpFIH0gZnJvbSBcIi4vdXRpbHNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHJlYWQocG9pbnRlciwgc3RhdGUpIHtcbiAgaWYgKHBvaW50ZXIuc3RhY2sgIT0gdW5kZWZpbmVkICYmIHN0YXRlLnN0YWNrICYmIHBvaW50ZXIuc3RhY2sgPCBzdGF0ZS5zdGFjay5sZW5ndGgpIHtcbiAgICByZXR1cm4gc3RhdGUuc3RhY2tbcG9pbnRlci5zdGFja107XG4gIH0gZWxzZSBpZiAocG9pbnRlci5zdG9yYWdlICE9IHVuZGVmaW5lZCAmJiBzdGF0ZS5zdG9yYWdlKSB7XG4gICAgcmV0dXJuIHN0b3JhZ2UucmVhZFJhbmdlKHN0YXRlLnN0b3JhZ2UsIHBvaW50ZXIuc3RvcmFnZSk7XG4gIH0gZWxzZSBpZiAocG9pbnRlci5tZW1vcnkgIT0gdW5kZWZpbmVkICYmIHN0YXRlLm1lbW9yeSkge1xuICAgIHJldHVybiBtZW1vcnkucmVhZEJ5dGVzKHN0YXRlLm1lbW9yeSwgcG9pbnRlci5tZW1vcnkuc3RhcnQsIHBvaW50ZXIubWVtb3J5Lmxlbmd0aCk7XG4gIH0gZWxzZSBpZiAocG9pbnRlci5saXRlcmFsKSB7XG4gICAgcmV0dXJuIHBvaW50ZXIubGl0ZXJhbDtcbiAgfVxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVWYWx1ZShkZWZpbml0aW9uLCBwb2ludGVyLCBzdGF0ZSwgLi4uYXJncykge1xuICBsZXQgYnl0ZXMgPSByZWFkKHBvaW50ZXIsIHN0YXRlKTtcbiAgaWYgKCFieXRlcykge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBzd2l0Y2ggKHV0aWxzLnR5cGVDbGFzcyhkZWZpbml0aW9uKSkge1xuICAgIGNhc2UgXCJib29sXCI6XG4gICAgICByZXR1cm4gIXV0aWxzLnRvQmlnTnVtYmVyKGJ5dGVzKS5pc1plcm8oKTtcblxuICAgIGNhc2UgXCJ1aW50XCI6XG4gICAgICByZXR1cm4gdXRpbHMudG9CaWdOdW1iZXIoYnl0ZXMpO1xuXG4gICAgY2FzZSBcImludFwiOlxuICAgICAgcmV0dXJuIHV0aWxzLnRvU2lnbmVkQmlnTnVtYmVyKGJ5dGVzKTtcblxuICAgIGNhc2UgXCJhZGRyZXNzXCI6XG4gICAgICByZXR1cm4gdXRpbHMudG9IZXhTdHJpbmcoYnl0ZXMsIHRydWUpO1xuXG4gICAgY2FzZSBcImJ5dGVzXCI6XG4gICAgICBkZWJ1ZyhcInR5cGVJZGVudGlmaWVyICVzICVvXCIsIHV0aWxzLnR5cGVJZGVudGlmaWVyKGRlZmluaXRpb24pLCBieXRlcyk7XG4gICAgICBsZXQgbGVuZ3RoID0gdXRpbHMuc3BlY2lmaWVkU2l6ZShkZWZpbml0aW9uKTtcbiAgICAgIHJldHVybiB1dGlscy50b0hleFN0cmluZyhieXRlcywgbGVuZ3RoKTtcblxuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIGRlYnVnKFwidHlwZUlkZW50aWZpZXIgJXMgJW9cIiwgdXRpbHMudHlwZUlkZW50aWZpZXIoZGVmaW5pdGlvbiksIGJ5dGVzKTtcbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJ5dGVzKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICBkZWJ1ZyhcIlVua25vd24gdmFsdWUgdHlwZTogJXNcIiwgdXRpbHMudHlwZUlkZW50aWZpZXIoZGVmaW5pdGlvbikpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZU1lbW9yeVJlZmVyZW5jZShkZWZpbml0aW9uLCBwb2ludGVyLCBzdGF0ZSwgLi4uYXJncykge1xuICBsZXQgcmF3VmFsdWUgPSB1dGlscy50b0JpZ051bWJlcihyZWFkKHBvaW50ZXIsIHN0YXRlKSkudG9OdW1iZXIoKTtcblxuICB2YXIgYnl0ZXM7XG4gIHN3aXRjaCAodXRpbHMudHlwZUNsYXNzKGRlZmluaXRpb24pKSB7XG5cbiAgICBjYXNlIFwiYnl0ZXNcIjpcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICBieXRlcyA9IHJlYWQoe1xuICAgICAgICBtZW1vcnk6IHsgc3RhcnQ6IHJhd1ZhbHVlLCBsZW5ndGg6IFdPUkRfU0laRX1cbiAgICAgIH0sIHN0YXRlKTsgLy8gYnl0ZXMgY29udGFpbiBsZW5ndGhcblxuICAgICAgcmV0dXJuIGRlY29kZVZhbHVlKGRlZmluaXRpb24sIHtcbiAgICAgICAgbWVtb3J5OiB7IHN0YXJ0OiByYXdWYWx1ZSArIFdPUkRfU0laRSwgbGVuZ3RoOiBieXRlcyB9XG4gICAgICB9LCBzdGF0ZSwgLi4uYXJncyk7XG5cbiAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgIGJ5dGVzID0gdXRpbHMudG9CaWdOdW1iZXIocmVhZCh7XG4gICAgICAgIG1lbW9yeTogeyBzdGFydDogcmF3VmFsdWUsIGxlbmd0aDogV09SRF9TSVpFIH0sXG4gICAgICB9LCBzdGF0ZSkpLnRvTnVtYmVyKCk7ICAvLyBieXRlcyBjb250YWluIGFycmF5IGxlbmd0aFxuXG4gICAgICBieXRlcyA9IHJlYWQoeyBtZW1vcnk6IHtcbiAgICAgICAgc3RhcnQ6IHJhd1ZhbHVlICsgV09SRF9TSVpFLCBsZW5ndGg6IGJ5dGVzICogV09SRF9TSVpFXG4gICAgICB9fSwgc3RhdGUpOyAvLyBub3cgYnl0ZXMgY29udGFpbiBpdGVtc1xuXG4gICAgICByZXR1cm4gbWVtb3J5LmNodW5rKGJ5dGVzLCBXT1JEX1NJWkUpXG4gICAgICAgIC5tYXAoXG4gICAgICAgICAgKGNodW5rKSA9PiBkZWNvZGUodXRpbHMuYmFzZURlZmluaXRpb24oZGVmaW5pdGlvbiksIHtcbiAgICAgICAgICAgIGxpdGVyYWw6IGNodW5rXG4gICAgICAgICAgfSwgc3RhdGUsIC4uLmFyZ3MpXG4gICAgICAgIClcblxuICAgIGNhc2UgXCJzdHJ1Y3RcIjpcbiAgICAgIGxldCBbcmVmc10gPSBhcmdzO1xuICAgICAgbGV0IHN0cnVjdERlZmluaXRpb24gPSByZWZzW2RlZmluaXRpb24udHlwZU5hbWUucmVmZXJlbmNlZERlY2xhcmF0aW9uXTtcbiAgICAgIGxldCBzdHJ1Y3RWYXJpYWJsZXMgPSBzdHJ1Y3REZWZpbml0aW9uLnZhcmlhYmxlcyB8fCBbXTtcblxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgIHt9LCAuLi5zdHJ1Y3RWYXJpYWJsZXNcbiAgICAgICAgICAubWFwKFxuICAgICAgICAgICAgKHtuYW1lLCBpZH0sIGkpID0+IHtcbiAgICAgICAgICAgICAgbGV0IG1lbWJlckRlZmluaXRpb24gPSByZWZzW2lkXS5kZWZpbml0aW9uO1xuICAgICAgICAgICAgICBsZXQgbWVtYmVyUG9pbnRlciA9IHtcbiAgICAgICAgICAgICAgICBtZW1vcnk6IHsgc3RhcnQ6IHJhd1ZhbHVlICsgaSAqIFdPUkRfU0laRSwgbGVuZ3RoOiBXT1JEX1NJWkUgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAvLyBsZXQgbWVtYmVyUG9pbnRlciA9IG1lbW9yeS5yZWFkKHN0YXRlLm1lbW9yeSwgcG9pbnRlciArIGkgKiBXT1JEX1NJWkUpO1xuXG4gICAgICAgICAgICAgIC8vIEhBQ0tcbiAgICAgICAgICAgICAgbWVtYmVyRGVmaW5pdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAuLi5tZW1iZXJEZWZpbml0aW9uLFxuXG4gICAgICAgICAgICAgICAgdHlwZURlc2NyaXB0aW9uczoge1xuICAgICAgICAgICAgICAgICAgLi4ubWVtYmVyRGVmaW5pdGlvbi50eXBlRGVzY3JpcHRpb25zLFxuXG4gICAgICAgICAgICAgICAgICB0eXBlSWRlbnRpZmllcjpcbiAgICAgICAgICAgICAgICAgICAgbWVtYmVyRGVmaW5pdGlvbi50eXBlRGVzY3JpcHRpb25zLnR5cGVJZGVudGlmaWVyXG4gICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL19zdG9yYWdlXy9nLCBcIl9tZW1vcnlfXCIpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgW25hbWVdOiBkZWNvZGUoXG4gICAgICAgICAgICAgICAgICBtZW1iZXJEZWZpbml0aW9uLCBtZW1iZXJQb2ludGVyLCBzdGF0ZSwgLi4uYXJnc1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG4gICAgICApO1xuXG5cbiAgICBkZWZhdWx0OlxuICAgICAgZGVidWcoXCJVbmtub3duIG1lbW9yeSByZWZlcmVuY2UgdHlwZTogJXNcIiwgdXRpbHMudHlwZUlkZW50aWZpZXIoZGVmaW5pdGlvbikpO1xuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgfVxuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVTdG9yYWdlUmVmZXJlbmNlKGRlZmluaXRpb24sIHBvaW50ZXIsIHN0YXRlLCAuLi5hcmdzKSB7XG4gIHZhciBkYXRhO1xuICB2YXIgYnl0ZXM7XG4gIHZhciBsZW5ndGg7XG4gIHZhciBzbG90O1xuXG4gIHN3aXRjaCAodXRpbHMudHlwZUNsYXNzKGRlZmluaXRpb24pKSB7XG4gICAgY2FzZSBcImFycmF5XCI6XG4gICAgICBkZWJ1ZyhcInN0b3JhZ2UgYXJyYXkhICVvXCIsIHBvaW50ZXIpO1xuICAgICAgZGF0YSA9IHJlYWQocG9pbnRlciwgc3RhdGUpO1xuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBsZW5ndGggPSB1dGlscy50b0JpZ051bWJlcihkYXRhKS50b051bWJlcigpO1xuICAgICAgZGVidWcoXCJsZW5ndGggJW9cIiwgbGVuZ3RoKTtcblxuICAgICAgY29uc3QgYmFzZVNpemUgPSB1dGlscy5zdG9yYWdlU2l6ZSh1dGlscy5iYXNlRGVmaW5pdGlvbihkZWZpbml0aW9uKSk7XG4gICAgICBjb25zdCBwZXJXb3JkID0gTWF0aC5mbG9vcihXT1JEX1NJWkUgLyBiYXNlU2l6ZSk7XG4gICAgICBkZWJ1ZyhcImJhc2VTaXplICVvXCIsIGJhc2VTaXplKTtcbiAgICAgIGRlYnVnKFwicGVyV29yZCAlZFwiLCBwZXJXb3JkKTtcblxuICAgICAgY29uc3Qgb2Zmc2V0ID0gKGkpID0+IHtcbiAgICAgICAgaWYgKHBlcldvcmQgPT0gMSkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoaSAqIGJhc2VTaXplIC8gV09SRF9TSVpFKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaW5kZXggPSAoaSkgPT4ge1xuICAgICAgICBpZiAocGVyV29yZCA9PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIFdPUkRfU0laRSAtIGJhc2VTaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBwZXJXb3JkIC0gaSAlIHBlcldvcmQgLSAxO1xuICAgICAgICByZXR1cm4gcG9zaXRpb24gKiBiYXNlU2l6ZTtcbiAgICAgIH1cblxuICAgICAgZGVidWcoXCJwb2ludGVyOiAlb1wiLCBwb2ludGVyKTtcbiAgICAgIHJldHVybiBbLi4uQXJyYXkobGVuZ3RoKS5rZXlzKCldXG4gICAgICAgIC5tYXAoIChpKSA9PiB7XG4gICAgICAgICAgbGV0IGNoaWxkRnJvbSA9IHBvaW50ZXIuc3RvcmFnZS5mcm9tLm9mZnNldCAhPSB1bmRlZmluZWQgP1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzbG90OiBbXCIweFwiICsgdXRpbHMudG9CaWdOdW1iZXIoXG4gICAgICAgICAgICAgICAgdXRpbHMua2VjY2FrMjU2KC4uLnBvaW50ZXIuc3RvcmFnZS5mcm9tLnNsb3QpXG4gICAgICAgICAgICAgICkucGx1cyhwb2ludGVyLnN0b3JhZ2UuZnJvbS5vZmZzZXQpLnRvU3RyaW5nKDE2KV0sXG4gICAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0KGkpLFxuICAgICAgICAgICAgICBpbmRleDogaW5kZXgoaSlcbiAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgIHNsb3Q6IFtwb2ludGVyLnN0b3JhZ2UuZnJvbS5zbG90XSxcbiAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQoaSksXG4gICAgICAgICAgICAgIGluZGV4OiBpbmRleChpKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gY2hpbGRGcm9tO1xuICAgICAgICB9KVxuICAgICAgICAubWFwKCAoY2hpbGRGcm9tLCBpZHgpID0+IHtcbiAgICAgICAgICBkZWJ1ZyhcImNoaWxkRnJvbSAlZCwgJW9cIiwgaWR4LCBjaGlsZEZyb20pO1xuICAgICAgICAgIHJldHVybiBkZWNvZGUodXRpbHMuYmFzZURlZmluaXRpb24oZGVmaW5pdGlvbiksIHsgc3RvcmFnZToge1xuICAgICAgICAgICAgZnJvbTogY2hpbGRGcm9tLFxuICAgICAgICAgICAgbGVuZ3RoOiBiYXNlU2l6ZVxuICAgICAgICAgIH19LCBzdGF0ZSwgLi4uYXJncyk7XG4gICAgICAgIH0pO1xuXG4gICAgY2FzZSBcImJ5dGVzXCI6XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgZGF0YSA9IHJlYWQocG9pbnRlciwgc3RhdGUpO1xuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YVtXT1JEX1NJWkUgLSAxXSAlIDIgPT0gMCkge1xuICAgICAgICAvLyBzdHJpbmcgbGl2ZXMgaW4gd29yZCwgbGVuZ3RoIGlzIGxhc3QgYnl0ZSAvIDJcbiAgICAgICAgbGVuZ3RoID0gZGF0YVtXT1JEX1NJWkUgLSAxXSAvIDI7XG4gICAgICAgIGRlYnVnKFwiaW4td29yZDsgbGVuZ3RoICVvXCIsIGxlbmd0aCk7XG4gICAgICAgIGlmIChsZW5ndGggPT0gMCkge1xuICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlY29kZVZhbHVlKGRlZmluaXRpb24sIHsgc3RvcmFnZToge1xuICAgICAgICAgIGZyb206IHsgc2xvdDogcG9pbnRlci5zdG9yYWdlLmZyb20uc2xvdCwgaW5kZXg6IDAgfSxcbiAgICAgICAgICB0bzogeyBzbG90OiBwb2ludGVyLnN0b3JhZ2UuZnJvbS5zbG90LCBpbmRleDogbGVuZ3RoIC0gMX1cbiAgICAgICAgfX0sIHN0YXRlLCAuLi5hcmdzKTtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVuZ3RoID0gdXRpbHMudG9CaWdOdW1iZXIoZGF0YSkubWludXMoMSkuZGl2KDIpLnRvTnVtYmVyKCk7XG4gICAgICAgIGRlYnVnKFwibmV3LXdvcmQsIGxlbmd0aCAlb1wiLCBsZW5ndGgpO1xuXG4gICAgICAgIHJldHVybiBkZWNvZGVWYWx1ZShkZWZpbml0aW9uLCB7IHN0b3JhZ2U6IHtcbiAgICAgICAgICBmcm9tOiB7IHNsb3Q6IFtwb2ludGVyLnN0b3JhZ2UuZnJvbS5zbG90XSwgaW5kZXg6IDAgfSxcbiAgICAgICAgICBsZW5ndGhcbiAgICAgICAgfX0sIHN0YXRlLCAuLi5hcmdzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgXCJzdHJ1Y3RcIjpcbiAgICAgIGxldCBbcmVmc10gPSBhcmdzO1xuXG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgICAge30sIC4uLk9iamVjdC5lbnRyaWVzKHBvaW50ZXIuc3RvcmFnZS5jaGlsZHJlbilcbiAgICAgICAgICAubWFwKCAoW2lkLCBjaGlsZFBvaW50ZXJdKSA9PiAoe1xuICAgICAgICAgICAgW2NoaWxkUG9pbnRlci5uYW1lXTogZGVjb2RlKFxuICAgICAgICAgICAgICByZWZzW2lkXS5kZWZpbml0aW9uLCB7IHN0b3JhZ2U6IGNoaWxkUG9pbnRlciB9LCBzdGF0ZSwgLi4uYXJnc1xuICAgICAgICAgICAgKVxuICAgICAgICAgIH0pKVxuICAgICAgKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICBkZWJ1ZyhcIlVua25vd24gc3RvcmFnZSByZWZlcmVuY2UgdHlwZTogJXNcIiwgdXRpbHMudHlwZUlkZW50aWZpZXIoZGVmaW5pdGlvbikpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGVjb2RlKGRlZmluaXRpb24sIC4uLmFyZ3MpIHtcbiAgaWYgKCF1dGlscy5pc1JlZmVyZW5jZShkZWZpbml0aW9uKSkge1xuICAgIHJldHVybiBkZWNvZGVWYWx1ZShkZWZpbml0aW9uLCAuLi5hcmdzKTtcbiAgfVxuXG4gIHN3aXRjaCAodXRpbHMucmVmZXJlbmNlVHlwZShkZWZpbml0aW9uKSkge1xuICAgIGNhc2UgXCJtZW1vcnlcIjpcbiAgICAgIHJldHVybiBkZWNvZGVNZW1vcnlSZWZlcmVuY2UoZGVmaW5pdGlvbiwgLi4uYXJncyk7XG4gICAgY2FzZSBcInN0b3JhZ2VcIjpcbiAgICAgIHJldHVybiBkZWNvZGVTdG9yYWdlUmVmZXJlbmNlKGRlZmluaXRpb24sIC4uLmFyZ3MpO1xuICAgIGRlZmF1bHQ6XG4gICAgICBkZWJ1ZyhcIlVua25vd24gcmVmZXJlbmNlIGNhdGVnb3J5OiAlc1wiLCB1dGlscy50eXBlSWRlbnRpZmllcihkZWZpbml0aW9uKSk7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2RhdGEvZGVjb2RlL2luZGV4LmpzIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOmRhdGE6ZGVjb2RlOm1lbW9yeVwiKTtcblxuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSBcImJpZ251bWJlci5qc1wiO1xuXG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tIFwiLi91dGlsc1wiO1xuaW1wb3J0IHsgV09SRF9TSVpFIH0gZnJvbSBcIi4vdXRpbHNcIjtcblxuLyoqXG4gKiByZWFkIHdvcmQgZnJvbSBtZW1vcnlcbiAqXG4gKiByZXF1aXJlcyBgYnl0ZWAgdG8gYmUgYSBtdWx0aXBsZSBvZiBXT1JEX1NJWkUgKDMyKVxuICpcbiAqIEBwYXJhbSBtZW1vcnkgLSBVaW50OEFycmF5XG4gKiBAcmV0dXJuIHtCaWdOdW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkKG1lbW9yeSwgYnl0ZSkge1xuICByZXR1cm4gcmVhZEJ5dGVzKG1lbW9yeSwgYnl0ZSwgV09SRF9TSVpFKTtcbn1cblxuLyoqXG4gKiByZWFkIDxieXRlcz4gYW1vdW50IG9mIGJ5dGVzIGZyb20gbWVtb3J5LCBzdGFydGluZyBhdCBieXRlIDxzdGFydD5cbiAqXG4gKiBAcGFyYW0gbWVtb3J5IC0gVWludDhBcnJheVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVhZEJ5dGVzKG1lbW9yeSwgYnl0ZSwgbGVuZ3RoKSB7XG4gIGJ5dGUgPSB1dGlscy50b0JpZ051bWJlcihieXRlKTtcbiAgbGVuZ3RoID0gdXRpbHMudG9CaWdOdW1iZXIobGVuZ3RoKTtcblxuICBpZiAoYnl0ZS50b051bWJlcigpID49IG1lbW9yeS5sZW5ndGgpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoID8gbGVuZ3RoLnRvTnVtYmVyKCkgOiAwKTtcbiAgfVxuXG4gIGlmIChsZW5ndGggPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG1lbW9yeS5idWZmZXIsIGJ5dGUudG9OdW1iZXIoKSk7XG4gIH1cblxuICAvLyBncmFiIGBsZW5ndGhgIGJ5dGVzIG5vIG1hdHRlciB3aGF0LCBoZXJlIGZpbGwgdGhpcyBhcnJheVxuICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW5ndGgudG9OdW1iZXIoKSk7XG5cbiAgLy8gaWYgd2UncmUgcmVhZGluZyBwYXN0IHRoZSBlbmQgb2YgbWVtb3J5LCB0cnVuY2F0ZSB0aGUgbGVuZ3RoIHRvIHJlYWRcbiAgbGV0IGV4Y2VzcyA9IGJ5dGUucGx1cyhsZW5ndGgpLm1pbnVzKG1lbW9yeS5sZW5ndGgpLnRvTnVtYmVyKCk7XG4gIGlmIChleGNlc3MgPiAwKSB7XG4gICAgbGVuZ3RoID0gbmV3IEJpZ051bWJlcihtZW1vcnkubGVuZ3RoKS5taW51cyhieXRlKTtcbiAgfVxuXG4gIGxldCBleGlzdGluZyA9IG5ldyBVaW50OEFycmF5KG1lbW9yeS5idWZmZXIsIGJ5dGUudG9OdW1iZXIoKSwgbGVuZ3RoLnRvTnVtYmVyKCkpO1xuXG4gIGJ5dGVzLnNldChleGlzdGluZyk7XG5cbiAgcmV0dXJuIGJ5dGVzO1xufVxuXG4vKipcbiAqIFNwbGl0IG1lbW9yeSBpbnRvIGNodW5rc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY2h1bmsobWVtb3J5LCBzaXplID0gV09SRF9TSVpFKSB7XG4gIGxldCBjaHVua3MgPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG1lbW9yeS5sZW5ndGg7IGkgKz0gc2l6ZSkge1xuICAgIGxldCBjaHVuayA9IHJlYWRCeXRlcyhtZW1vcnksIGksIHNpemUpO1xuICAgIGNodW5rcy5wdXNoKGNodW5rKTtcbiAgfVxuXG4gIHJldHVybiBjaHVua3M7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2RhdGEvZGVjb2RlL21lbW9yeS5qcyIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjpkYXRhOmRlY29kZTpzdG9yYWdlXCIpO1xuXG5pbXBvcnQgeyBXT1JEX1NJWkUgfSBmcm9tIFwiLi91dGlsc1wiO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSBcIi4vdXRpbHNcIjtcblxuXG4vKipcbiAqIHJlYWQgc2xvdCBmcm9tIHN0b3JhZ2VcbiAqXG4gKiBAcGFyYW0gc2xvdCAtIGJpZyBudW1iZXIgb3IgYXJyYXkgb2YgcmVndWxhciBudW1iZXJzXG4gKiBAcGFyYW0gb2Zmc2V0IC0gZm9yIGFycmF5LCBvZmZzZXQgZnJvbSB0aGUga2VjY2FrIGRldGVybWluZWQgbG9jYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWQoc3RvcmFnZSwgc2xvdCwgb2Zmc2V0ID0gMCkge1xuICBpZiAoc2xvdCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgc2xvdCA9IHV0aWxzLmtlY2NhazI1NiguLi5zbG90Lm1hcCh1dGlscy50b0JpZ051bWJlcikpO1xuICB9XG5cbiAgc2xvdCA9IHV0aWxzLnRvQmlnTnVtYmVyKHNsb3QpLnBsdXMob2Zmc2V0KTtcblxuICBkZWJ1ZyhcInJlYWRpbmcgc2xvdDogJW9cIiwgdXRpbHMudG9IZXhTdHJpbmcoc2xvdCkpO1xuXG4gIGxldCB3b3JkID0gc3RvcmFnZVt1dGlscy50b0hleFN0cmluZyhzbG90LCBXT1JEX1NJWkUpXSB8fFxuICAgIG5ldyBVaW50OEFycmF5KFdPUkRfU0laRSk7XG5cbiAgZGVidWcoXCJ3b3JkICVvXCIsIHdvcmQpO1xuICByZXR1cm4gd29yZFxufVxuXG4vKipcbiAqIHJlYWQgYWxsIGJ5dGVzIGluIHNvbWUgcmFuZ2UuXG4gKlxuICogcGFyYW1ldGVycyBgZnJvbWAgYW5kIGB0b2AgYXJlIG9iamVjdHMgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICBzbG90IC0gKHJlcXVpcmVkKSBlaXRoZXIgYSBiaWdudW1iZXIgb3IgYSBcInBhdGhcIiBhcnJheSBvZiBpbnRlZ2VyIG9mZnNldHNcbiAqXG4gKiAgICAgcGF0aCBhcnJheSB2YWx1ZXMgZ2V0IGNvbnZlcnRlZCBpbnRvIGtlY2NhazI1NiBoYXNoIGFzIHBlciBzb2xpZGl0eVxuICogICAgIHN0b3JhZ2UgYWxsb2NhdGlvbiBtZXRob2RcbiAqXG4gKiAgICAgcmVmOiBodHRwczovL3NvbGlkaXR5LnJlYWR0aGVkb2NzLmlvL2VuL3YwLjQuMjMvbWlzY2VsbGFuZW91cy5odG1sI2xheW91dC1vZi1zdGF0ZS12YXJpYWJsZXMtaW4tc3RvcmFnZVxuICogICAgIChzZWFyY2ggXCJjb25jYXRlbmF0aW9uXCIpXG4gKlxuICogIG9mZnNldCAtIChkZWZhdWx0OiAwKSBzbG90IG9mZnNldFxuICpcbiAqICBpbmRleCAtIChkZWZhdWx0OiAwKSBieXRlIGluZGV4IGluIHdvcmRcbiAqXG4gKiBAcGFyYW0gZnJvbSAtIGxvY2F0aW9uIChzZWUgXilcbiAqIEBwYXJhbSB0byAtIGxvY2F0aW9uIChzZWUgXikuIGluY2x1c2l2ZS5cbiAqIEBwYXJhbSBsZW5ndGggLSBpbnN0ZWFkIG9mIGB0b2AsIG51bWJlciBvZiBieXRlcyBhZnRlciBgZnJvbWBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWRSYW5nZShzdG9yYWdlLCB7ZnJvbSwgdG8sIGxlbmd0aH0pIHtcbiAgaWYgKCFsZW5ndGggJiYgIXRvIHx8IGxlbmd0aCAmJiB0bykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm11c3Qgc3BlY2lmeSBleGFjdGx5IG9uZSBgdG9gfGBsZW5ndGhgXCIpO1xuICB9XG5cbiAgZnJvbSA9IHtcbiAgICAuLi5mcm9tLFxuICAgIG9mZnNldDogZnJvbS5vZmZzZXQgfHwgMFxuICB9O1xuXG4gIGlmIChsZW5ndGgpIHtcbiAgICB0byA9IHtcbiAgICAgIHNsb3Q6IGZyb20uc2xvdCxcbiAgICAgIG9mZnNldDogZnJvbS5vZmZzZXQgKyBNYXRoLmZsb29yKChmcm9tLmluZGV4ICsgbGVuZ3RoIC0gMSkgLyBXT1JEX1NJWkUpLFxuICAgICAgaW5kZXg6IChmcm9tLmluZGV4ICsgbGVuZ3RoIC0gMSkgJSBXT1JEX1NJWkVcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHRvID0ge1xuICAgICAgLi4udG8sXG4gICAgICBvZmZzZXQ6IHRvLm9mZnNldCB8fCAwXG4gICAgfVxuICB9XG5cbiAgZGVidWcoXCJyZWFkUmFuZ2UgJW9cIiwge2Zyb20sdG99KTtcblxuICBjb25zdCB0b3RhbFdvcmRzID0gdG8ub2Zmc2V0IC0gZnJvbS5vZmZzZXQgKyAxO1xuICBkZWJ1ZyhcInRvdGFsV29yZHMgJW9cIiwgdG90YWxXb3Jkcyk7XG5cbiAgbGV0IGRhdGEgPSBuZXcgVWludDhBcnJheSh0b3RhbFdvcmRzICogV09SRF9TSVpFKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsV29yZHM7IGkrKykge1xuICAgIGxldCBvZmZzZXQgPSBpICsgZnJvbS5vZmZzZXQ7XG4gICAgZGF0YS5zZXQocmVhZChzdG9yYWdlLCBmcm9tLnNsb3QsIG9mZnNldCksIGkgKiBXT1JEX1NJWkUpO1xuICB9XG4gIGRlYnVnKFwid29yZHMgJW9cIiwgZGF0YSk7XG5cbiAgZGF0YSA9IGRhdGEuc2xpY2UoZnJvbS5pbmRleCwgKHRvdGFsV29yZHMgLSAxKSAqIFdPUkRfU0laRSArIHRvLmluZGV4ICsgMSk7XG5cbiAgZGVidWcoXCJkYXRhOiAlb1wiLCBkYXRhKTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9kYXRhL2RlY29kZS9zdG9yYWdlLmpzIiwiZXhwb3J0IGNvbnN0IFZJU0lUID0gXCJWSVNJVFwiO1xuZXhwb3J0IGZ1bmN0aW9uIHZpc2l0KHNvdXJjZUlkLCBhc3QpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBWSVNJVCxcbiAgICBzb3VyY2VJZCwgYXN0XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IERPTkVfVklTSVRJTkcgPSBcIkRPTkVfVklTSVRJTkdcIjtcbmV4cG9ydCBmdW5jdGlvbiBkb25lVmlzaXRpbmcoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogRE9ORV9WSVNJVElOR1xuICB9O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9hc3QvYWN0aW9ucy9pbmRleC5qcyIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjpjb250cm9sbGVyOnNhZ2FzXCIpO1xuXG5pbXBvcnQgeyBwdXQsIGNhbGwsIHJhY2UsIHRha2UsIHNlbGVjdCB9IGZyb20gJ3JlZHV4LXNhZ2EvZWZmZWN0cyc7XG5cbmltcG9ydCB7IHByZWZpeE5hbWUgfSBmcm9tIFwibGliL2hlbHBlcnNcIjtcblxuaW1wb3J0ICogYXMgdHJhY2UgZnJvbSBcImxpYi90cmFjZS9zYWdhc1wiO1xuXG5pbXBvcnQgKiBhcyBhY3Rpb25zIGZyb20gXCIuLi9hY3Rpb25zXCI7XG5cbmltcG9ydCBjb250cm9sbGVyIGZyb20gXCIuLi9zZWxlY3RvcnNcIjtcblxuY29uc3QgQ09OVFJPTF9TQUdBUyA9IHtcbiAgW2FjdGlvbnMuQURWQU5DRV06IGFkdmFuY2UsXG4gIFthY3Rpb25zLlNURVBfTkVYVF06IHN0ZXBOZXh0LFxuICBbYWN0aW9ucy5TVEVQX09WRVJdOiBzdGVwT3ZlcixcbiAgW2FjdGlvbnMuU1RFUF9JTlRPXTogc3RlcEludG8sXG4gIFthY3Rpb25zLlNURVBfT1VUXTogc3RlcE91dCxcbiAgW2FjdGlvbnMuQ09OVElOVUVfVU5USUxdOiBjb250aW51ZVVudGlsXG59O1xuXG4vKiogQVNUIG5vZGUgdHlwZXMgdGhhdCBhcmUgc2tpcHBlZCB0byBmaWx0ZXIgb3V0IHNvbWUgbm9pc2UgKi9cbmNvbnN0IFNLSVBQRURfVFlQRVMgPSBuZXcgU2V0KFtcbiAgXCJDb250cmFjdERlZmluaXRpb25cIixcbiAgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsXG5dKTtcblxuZXhwb3J0IGZ1bmN0aW9uKiBzYWdhKCkge1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGRlYnVnKFwid2FpdGluZyBmb3IgY29udHJvbCBhY3Rpb25cIik7XG4gICAgbGV0IGFjdGlvbiA9IHlpZWxkIHRha2UoT2JqZWN0LmtleXMoQ09OVFJPTF9TQUdBUykpO1xuICAgIGRlYnVnKFwiZ290IGNvbnRyb2wgYWN0aW9uXCIpO1xuICAgIGxldCBzYWdhID0gQ09OVFJPTF9TQUdBU1thY3Rpb24udHlwZV07XG5cbiAgICB5aWVsZCBwdXQoYWN0aW9ucy5iZWdpblN0ZXAoYWN0aW9uLnR5cGUpKTtcblxuICAgIHlpZWxkIHJhY2Uoe1xuICAgICAgZXhlYzogY2FsbChzYWdhLCBhY3Rpb24pLFxuICAgICAgaW50ZXJydXB0OiB0YWtlKGFjdGlvbnMuSU5URVJSVVBUKVxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHByZWZpeE5hbWUoXCJjb250cm9sbGVyXCIsIHNhZ2EpO1xuXG4vKipcbiAqIEFkdmFuY2UgdGhlIHN0YXRlIGJ5IG9uZSBpbnN0cnVjdGlvblxuICovXG5mdW5jdGlvbiogYWR2YW5jZSgpIHtcbiAgLy8gc2VuZCBhY3Rpb24gdG8gYWR2YW5jZSB0cmFjZVxuICB5aWVsZCAqdHJhY2UuYWR2YW5jZSgpO1xufVxuXG4vKipcbiAqIHN0ZXBOZXh0IC0gc3RlcCB0byB0aGUgbmV4dCBsb2dpY2FsIGNvZGUgc2VnbWVudFxuICpcbiAqIE5vdGU6IEl0IG1pZ2h0IHRha2UgbXVsdGlwbGUgaW5zdHJ1Y3Rpb25zIHRvIGV4cHJlc3MgdGhlIHNhbWUgc2VjdGlvbiBvZiBjb2RlLlxuICogXCJTdGVwcGluZ1wiLCB0aGVuLCBpcyBzdGVwcGluZyB0byB0aGUgbmV4dCBsb2dpY2FsIGl0ZW0sIG5vdCBzdGVwcGluZyB0byB0aGUgbmV4dFxuICogaW5zdHJ1Y3Rpb24uIFNlZSBhZHZhbmNlKCkgaWYgeW91J2QgbGlrZSB0byBhZHZhbmNlIGJ5IG9uZSBpbnN0cnVjdGlvbi5cbiAqL1xuZnVuY3Rpb24qIHN0ZXBOZXh0ICgpIHtcbiAgY29uc3Qgc3RhcnRpbmdSYW5nZSA9IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb24uc291cmNlUmFuZ2UpO1xuXG4gIHZhciB1cGNvbWluZztcblxuICBkbyB7XG4gICAgLy8gYWR2YW5jZSBhdCBsZWFzdCBvbmNlIHN0ZXBcbiAgICB5aWVsZCogYWR2YW5jZSgpO1xuXG4gICAgLy8gYW5kIGNoZWNrIHRoZSBuZXh0IHNvdXJjZSByYW5nZVxuICAgIHRyeSB7XG4gICAgICB1cGNvbWluZyA9IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb24pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHVwY29taW5nID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBpZiB0aGUgbmV4dCBzdGVwJ3Mgc291cmNlIHJhbmdlIGlzIHN0aWxsIHRoZSBzYW1lLCBrZWVwIGdvaW5nXG4gIH0gd2hpbGUgKFxuICAgICF1cGNvbWluZyB8fFxuICAgICF1cGNvbWluZy5ub2RlIHx8XG4gICAgU0tJUFBFRF9UWVBFUy5oYXModXBjb21pbmcubm9kZS5ub2RlVHlwZSkgfHxcblxuICAgIHVwY29taW5nLnNvdXJjZVJhbmdlLnN0YXJ0ID09IHN0YXJ0aW5nUmFuZ2Uuc3RhcnQgJiZcbiAgICB1cGNvbWluZy5zb3VyY2VSYW5nZS5sZW5ndGggPT0gc3RhcnRpbmdSYW5nZS5sZW5ndGhcbiAgKTtcbn1cblxuLyoqXG4gKiBzdGVwSW50byAtIHN0ZXAgaW50byB0aGUgY3VycmVudCBmdW5jdGlvblxuICpcbiAqIENvbmNlcHR1YWxseSB0aGlzIGlzIGVhc3ksIGJ1dCBmcm9tIGEgcHJvZ3JhbW1pbmcgc3RhbmRwb2ludCBpdCdzIGhhcmQuXG4gKiBDb2RlIGxpa2UgYGdldEJhbGFuY2UobXNnLnNlbmRlcilgIG1pZ2h0IGJlIGhpZ2hsaWdodGVkLCBidXQgdGhlcmUgY291bGRcbiAqIGJlIGEgbnVtYmVyIG9mIGRpZmZlcmVudCBpbnRlcm1lZGlhdGUgc3RlcHMgKGxpa2UgZXZhbHVhdGluZyBgbXNnLnNlbmRlcmApXG4gKiBiZWZvcmUgYGdldEJhbGFuY2VgIGlzIHN0ZXBwZWQgaW50by4gVGhpcyBmdW5jdGlvbiB3aWxsIHN0ZXAgaW50byB0aGUgZmlyc3RcbiAqIGZ1bmN0aW9uIGF2YWlsYWJsZSAod2hlcmUgaW5zdHJ1Y3Rpb24uanVtcCA9PSBcImlcIiksIGlnbm9yaW5nIGFueSBpbnRlcm1lZGlhdGVcbiAqIHN0ZXBzIHRoYXQgZmFsbCB3aXRoaW4gdGhlIHNhbWUgY29kZSByYW5nZS4gSWYgdGhlcmUncyBhIHN0ZXAgZW5jb3VudGVyZWRcbiAqIHRoYXQgZXhpc3RzIG91dHNpZGUgb2YgdGhlIHJhbmdlLCB0aGVuIHN0ZXBJbnRvIHdpbGwgb25seSBleGVjdXRlIHVudGlsIHRoYXRcbiAqIHN0ZXAuXG4gKi9cbmZ1bmN0aW9uKiBzdGVwSW50byAoKSB7XG4gIGlmICh5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LndpbGxKdW1wKSkge1xuICAgIHlpZWxkKiBzdGVwTmV4dCgpO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb24uaXNNdWx0aWxpbmUpKSB7XG4gICAgeWllbGQqIHN0ZXBPdmVyKCk7XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBzdGFydGluZ0RlcHRoID0geWllbGQgc2VsZWN0KGNvbnRyb2xsZXIuY3VycmVudC5mdW5jdGlvbkRlcHRoKTtcbiAgY29uc3Qgc3RhcnRpbmdSYW5nZSA9IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb24uc291cmNlUmFuZ2UpO1xuICB2YXIgY3VycmVudERlcHRoO1xuICB2YXIgY3VycmVudFJhbmdlO1xuXG4gIGRvIHtcbiAgICB5aWVsZCogc3RlcE5leHQoKTtcblxuICAgIGN1cnJlbnREZXB0aCA9IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQuZnVuY3Rpb25EZXB0aCk7XG4gICAgY3VycmVudFJhbmdlID0geWllbGQgc2VsZWN0KGNvbnRyb2xsZXIuY3VycmVudC5sb2NhdGlvbi5zb3VyY2VSYW5nZSk7XG5cbiAgfSB3aGlsZSAoXG4gICAgLy8gdGhlIGZ1bmN0aW9uIHN0YWNrIGhhcyBub3QgaW5jcmVhc2VkLFxuICAgIGN1cnJlbnREZXB0aCA8PSBzdGFydGluZ0RlcHRoICYmXG5cbiAgICAvLyB0aGUgY3VycmVudCBzb3VyY2UgcmFuZ2UgYmVnaW5zIG9uIG9yIGFmdGVyIHRoZSBzdGFydGluZyByYW5nZVxuICAgIGN1cnJlbnRSYW5nZS5zdGFydCA+PSBzdGFydGluZ1JhbmdlLnN0YXJ0ICYmXG5cbiAgICAvLyBhbmQgdGhlIGN1cnJlbnQgcmFuZ2UgZW5kcyBvbiBvciBiZWZvcmUgdGhlIHN0YXJ0aW5nIHJhbmdlIGVuZHNcbiAgICAoY3VycmVudFJhbmdlLnN0YXJ0ICsgY3VycmVudFJhbmdlLmxlbmd0aCkgPD1cbiAgICAgIChzdGFydGluZ1JhbmdlLnN0YXJ0ICsgc3RhcnRpbmdSYW5nZS5sZW5ndGgpXG4gICk7XG59XG5cbi8qKlxuICogU3RlcCBvdXQgb2YgdGhlIGN1cnJlbnQgZnVuY3Rpb25cbiAqXG4gKiBUaGlzIHdpbGwgcnVuIHVudGlsIHRoZSBkZWJ1Z2dlciBlbmNvdW50ZXJzIGEgZGVjcmVhc2UgaW4gZnVuY3Rpb24gZGVwdGguXG4gKi9cbmZ1bmN0aW9uKiBzdGVwT3V0ICgpIHtcbiAgaWYgKHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb24uaXNNdWx0aWxpbmUpKSB7XG4gICAgeWllbGQgKnN0ZXBPdmVyKCk7XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBzdGFydGluZ0RlcHRoID0geWllbGQgc2VsZWN0KGNvbnRyb2xsZXIuY3VycmVudC5mdW5jdGlvbkRlcHRoKTtcbiAgdmFyIGN1cnJlbnREZXB0aDtcblxuICBkbyB7XG4gICAgeWllbGQqIHN0ZXBOZXh0KCk7XG5cbiAgICBjdXJyZW50RGVwdGggPSB5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LmZ1bmN0aW9uRGVwdGgpO1xuXG4gIH0gd2hpbGUoY3VycmVudERlcHRoID49IHN0YXJ0aW5nRGVwdGgpO1xufVxuXG4vKipcbiAqIHN0ZXBPdmVyIC0gc3RlcCBvdmVyIHRoZSBjdXJyZW50IGxpbmVcbiAqXG4gKiBTdGVwIG92ZXIgdGhlIGN1cnJlbnQgbGluZS4gVGhpcyB3aWxsIHN0ZXAgdG8gdGhlIG5leHQgaW5zdHJ1Y3Rpb24gdGhhdFxuICogZXhpc3RzIG9uIGEgZGlmZmVyZW50IGxpbmUgb2YgY29kZSB3aXRoaW4gdGhlIHNhbWUgZnVuY3Rpb24gZGVwdGguXG4gKi9cbmZ1bmN0aW9uKiBzdGVwT3ZlciAoKSB7XG4gIGNvbnN0IHN0YXJ0aW5nRGVwdGggPSB5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LmZ1bmN0aW9uRGVwdGgpO1xuICBjb25zdCBzdGFydGluZ1JhbmdlID0geWllbGQgc2VsZWN0KGNvbnRyb2xsZXIuY3VycmVudC5sb2NhdGlvbi5zb3VyY2VSYW5nZSk7XG4gIHZhciBjdXJyZW50RGVwdGg7XG4gIHZhciBjdXJyZW50UmFuZ2U7XG5cbiAgZG8ge1xuICAgIHlpZWxkKiBzdGVwTmV4dCgpO1xuXG4gICAgY3VycmVudERlcHRoID0geWllbGQgc2VsZWN0KGNvbnRyb2xsZXIuY3VycmVudC5mdW5jdGlvbkRlcHRoKTtcbiAgICBjdXJyZW50UmFuZ2UgPSB5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LmxvY2F0aW9uLnNvdXJjZVJhbmdlKTtcblxuICB9IHdoaWxlIChcbiAgICAvLyBrZWVwIHN0ZXBwaW5nIHByb3ZpZGVkOlxuICAgIC8vXG4gICAgLy8gd2UgaGF2ZW4ndCBqdW1wZWQgb3V0XG4gICAgIShjdXJyZW50RGVwdGggPCBzdGFydGluZ0RlcHRoKSAmJlxuXG4gICAgLy8gZWl0aGVyOiBmdW5jdGlvbiBkZXB0aCBpcyBncmVhdGVyIHRoYW4gc3RhcnRpbmcgKGlnbm9yZSBmdW5jdGlvbiBjYWxscylcbiAgICAvLyBvciwgaWYgd2UncmUgYXQgdGhlIHNhbWUgZGVwdGgsIGtlZXAgc3RlcHBpbmcgdW50aWwgd2UncmUgb24gYSBuZXdcbiAgICAvLyBsaW5lLlxuICAgIChjdXJyZW50RGVwdGggPiBzdGFydGluZ0RlcHRoIHx8XG4gICAgICBjdXJyZW50UmFuZ2UubGluZXMuc3RhcnQubGluZSA9PSBzdGFydGluZ1JhbmdlLmxpbmVzLnN0YXJ0LmxpbmUpXG4gIClcbn1cblxuLyoqXG4gKiBjb250aW51ZVVudGlsIC0gc3RlcCB0aHJvdWdoIGV4ZWN1dGlvbiB1bnRpbCBhIGJyZWFrcG9pbnRcbiAqXG4gKiBAcGFyYW0gYnJlYWtwb2ludHMgLSBhcnJheSBvZiBicmVha3BvaW50cyAoeyAuLi5jYWxsLCBsaW5lIH0pXG4gKi9cbmZ1bmN0aW9uICpjb250aW51ZVVudGlsICh7YnJlYWtwb2ludHN9KSB7XG4gIHZhciBjdXJyZW50Q2FsbDtcbiAgdmFyIGN1cnJlbnRMb2NhdGlvbjtcblxuICBsZXQgYnJlYWtwb2ludEhpdCA9IGZhbHNlO1xuXG4gIGRvIHtcbiAgICB5aWVsZCogc3RlcE5leHQoKTtcblxuICAgIGN1cnJlbnRDYWxsID0geWllbGQgc2VsZWN0KGNvbnRyb2xsZXIuY3VycmVudC5leGVjdXRpb25Db250ZXh0KTtcbiAgICBjdXJyZW50TG9jYXRpb24gPSB5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LmxvY2F0aW9uKTtcblxuICAgIGJyZWFrcG9pbnRIaXQgPSBicmVha3BvaW50c1xuICAgICAgLmZpbHRlciggKHthZGRyZXNzLCBiaW5hcnksIGxpbmUsIG5vZGV9KSA9PlxuICAgICAgICAoXG4gICAgICAgICAgYWRkcmVzcyA9PSBjdXJyZW50Q2FsbC5hZGRyZXNzIHx8XG4gICAgICAgICAgYmluYXJ5ID09IGN1cnJlbnRDYWxsLmJpbmFyeVxuICAgICAgICApICYmIChcbiAgICAgICAgICBsaW5lID09IGN1cnJlbnRMb2NhdGlvbi5zb3VyY2VSYW5nZS5saW5lcy5zdGFydC5saW5lIHx8XG4gICAgICAgICAgbm9kZSA9PSBjdXJyZW50TG9jYXRpb24ubm9kZS5pZFxuICAgICAgICApXG4gICAgICApXG4gICAgICAubGVuZ3RoID4gMDtcblxuICB9IHdoaWxlICghYnJlYWtwb2ludEhpdCk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2NvbnRyb2xsZXIvc2FnYXMvaW5kZXguanMiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6Y29udHJvbGxlcjpzYWdhc1wiKTtcblxuaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3JUcmVlLCBjcmVhdGVMZWFmIH0gZnJvbSBcInJlc2VsZWN0LXRyZWVcIjtcblxuaW1wb3J0IGV2bSBmcm9tIFwibGliL2V2bS9zZWxlY3RvcnNcIjtcbmltcG9ydCBzb2xpZGl0eSBmcm9tIFwibGliL3NvbGlkaXR5L3NlbGVjdG9yc1wiO1xuaW1wb3J0IGFzdCBmcm9tIFwibGliL2FzdC9zZWxlY3RvcnNcIjtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBpZGVudGl0eSA9ICh4KSA9PiB4XG5cbi8qKlxuICogY29udHJvbGxlclxuICovXG5jb25zdCBjb250cm9sbGVyID0gY3JlYXRlU2VsZWN0b3JUcmVlKHtcblxuICAvKipcbiAgICogY29udHJvbGxlci5jdXJyZW50XG4gICAqL1xuICBjdXJyZW50OiB7XG4gICAgLyoqXG4gICAgICogY29udHJvbGxlci5jdXJyZW50LmZ1bmN0aW9uRGVwdGhcbiAgICAgKi9cbiAgICBmdW5jdGlvbkRlcHRoOiBjcmVhdGVMZWFmKFtzb2xpZGl0eS5jdXJyZW50LmZ1bmN0aW9uRGVwdGhdLCBpZGVudGl0eSksXG5cbiAgICAvKipcbiAgICAgKiBjb250cm9sbGVyLmN1cnJlbnQuZXhlY3V0aW9uQ29udGV4dFxuICAgICAqL1xuICAgIGV4ZWN1dGlvbkNvbnRleHQ6IGNyZWF0ZUxlYWYoW2V2bS5jdXJyZW50LmNhbGxdLCBpZGVudGl0eSksXG5cbiAgICAvKipcbiAgICAgKiBjb250cm9sbGVyLmN1cnJlbnQud2lsbEp1bXBcbiAgICAgKi9cbiAgICB3aWxsSnVtcDogY3JlYXRlTGVhZihbZXZtLmN1cnJlbnQuc3RlcC5pc0p1bXBdLCBpZGVudGl0eSksXG5cbiAgICAvKipcbiAgICAgKiBjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb25cbiAgICAgKi9cbiAgICBsb2NhdGlvbjoge1xuICAgICAgLyoqXG4gICAgICAgKiBjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb24uc291cmNlUmFuZ2VcbiAgICAgICAqL1xuICAgICAgc291cmNlUmFuZ2U6IGNyZWF0ZUxlYWYoW3NvbGlkaXR5LmN1cnJlbnQuc291cmNlUmFuZ2VdLCBpZGVudGl0eSksXG5cbiAgICAgIC8qKlxuICAgICAgICogY29udHJvbGxlci5jdXJyZW50LmxvY2F0aW9uLm5vZGVcbiAgICAgICAqL1xuICAgICAgbm9kZTogY3JlYXRlTGVhZihbYXN0LmN1cnJlbnQubm9kZV0sIGlkZW50aXR5KSxcblxuICAgICAgLyoqXG4gICAgICAgKiBjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb24uaXNNdWx0aWxpbmVcbiAgICAgICAqL1xuICAgICAgaXNNdWx0aWxpbmU6IGNyZWF0ZUxlYWYoW3NvbGlkaXR5LmN1cnJlbnQuaXNNdWx0aWxpbmVdLCBpZGVudGl0eSksXG4gICAgfVxuICB9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgY29udHJvbGxlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvY29udHJvbGxlci9zZWxlY3RvcnMvaW5kZXguanMiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6c29saWRpdHk6c2FnYXNcIik7XG5cbmltcG9ydCB7IGNhbGwsIHB1dCwgdGFrZSwgc2VsZWN0IH0gZnJvbSBcInJlZHV4LXNhZ2EvZWZmZWN0c1wiO1xuaW1wb3J0IHsgcHJlZml4TmFtZSB9IGZyb20gXCJsaWIvaGVscGVyc1wiO1xuXG5pbXBvcnQgKiBhcyBhY3Rpb25zIGZyb20gXCIuLi9hY3Rpb25zXCI7XG5pbXBvcnQgeyBUSUNLIH0gZnJvbSBcImxpYi90cmFjZS9hY3Rpb25zXCI7XG5cbmltcG9ydCBzb2xpZGl0eSBmcm9tIFwiLi4vc2VsZWN0b3JzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiAqYWRkU291cmNlKHNvdXJjZSwgc291cmNlUGF0aCwgYXN0KSB7XG4gIHlpZWxkIHB1dChhY3Rpb25zLmFkZFNvdXJjZShzb3VyY2UsIHNvdXJjZVBhdGgsIGFzdCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gKmFkZFNvdXJjZU1hcChiaW5hcnksIHNvdXJjZU1hcCkge1xuICB5aWVsZCBwdXQoYWN0aW9ucy5hZGRTb3VyY2VNYXAoYmluYXJ5LCBzb3VyY2VNYXApKTtcbn1cblxuZnVuY3Rpb24gKnRpY2tTYWdhKCkge1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHlpZWxkIHRha2UoVElDSyk7XG4gICAgZGVidWcoXCJnb3QgVElDS1wiKTtcblxuICAgIHlpZWxkICpmdW5jdGlvbkRlcHRoU2FnYSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uKiBmdW5jdGlvbkRlcHRoU2FnYSAoKSB7XG4gIGlmICh5aWVsZCBzZWxlY3Qoc29saWRpdHkuY3VycmVudC53aWxsSnVtcCkpIHtcbiAgICBsZXQganVtcERpcmVjdGlvbiA9IHlpZWxkIHNlbGVjdChzb2xpZGl0eS5jdXJyZW50Lmp1bXBEaXJlY3Rpb24pO1xuXG5cbiAgICB5aWVsZCBwdXQoYWN0aW9ucy5qdW1wKGp1bXBEaXJlY3Rpb24pKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24qIHNhZ2EgKCkge1xuICB5aWVsZCBjYWxsKHRpY2tTYWdhKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcHJlZml4TmFtZShcInNvbGlkaXR5XCIsIHNhZ2EpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9zb2xpZGl0eS9zYWdhcy9pbmRleC5qcyIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjpldm06c2FnYXNcIik7XG5cbmltcG9ydCB7IGNhbGwsIHB1dCwgdGFrZSwgc2VsZWN0IH0gZnJvbSBcInJlZHV4LXNhZ2EvZWZmZWN0c1wiO1xuaW1wb3J0IHsgcHJlZml4TmFtZSwga2VjY2FrMjU2IH0gZnJvbSBcImxpYi9oZWxwZXJzXCI7XG5cbmltcG9ydCB7IFRJQ0sgfSBmcm9tIFwibGliL3RyYWNlL2FjdGlvbnNcIjtcbmltcG9ydCAqIGFzIGFjdGlvbnMgZnJvbSBcIi4uL2FjdGlvbnNcIjtcblxuaW1wb3J0IGV2bSBmcm9tIFwiLi4vc2VsZWN0b3JzXCI7XG5cbi8qKlxuICogQWRkcyBFVk0gYnl0ZWNvZGUgY29udGV4dFxuICpcbiAqIEByZXR1cm4ge3N0cmluZ30gSUQgKDB4LXByZWZpeGVkIGtlY2NhayBvZiBiaW5hcnkpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiAqYWRkQ29udGV4dChjb250cmFjdE5hbWUsIGJpbmFyeSkge1xuICB5aWVsZCBwdXQoYWN0aW9ucy5hZGRDb250ZXh0KGNvbnRyYWN0TmFtZSwgYmluYXJ5KSk7XG5cbiAgcmV0dXJuIGtlY2NhazI1NihiaW5hcnkpO1xufVxuXG4vKipcbiAqIEFkZHMga25vd24gZGVwbG95ZWQgaW5zdGFuY2Ugb2YgYmluYXJ5IGF0IGFkZHJlc3NcbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IElEICgweC1wcmVmaXhlZCBrZWNjYWsgb2YgYmluYXJ5KVxuICovXG5leHBvcnQgZnVuY3Rpb24gKmFkZEluc3RhbmNlKGFkZHJlc3MsIGJpbmFyeSkge1xuICBsZXQgc2VhcmNoID0geWllbGQgc2VsZWN0KGV2bS5pbmZvLmJpbmFyaWVzLnNlYXJjaCk7XG4gIGlmIChiaW5hcnkgIT0gXCIweDBcIikge1xuICAgIGxldCB7IGNvbnRleHQgfSA9IHNlYXJjaChiaW5hcnkpO1xuXG4gICAgeWllbGQgcHV0KGFjdGlvbnMuYWRkSW5zdGFuY2UoYWRkcmVzcywgY29udGV4dCwgYmluYXJ5KSk7XG5cbiAgICByZXR1cm4gY29udGV4dDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24qIGJlZ2luKHsgYWRkcmVzcywgYmluYXJ5IH0pIHtcbiAgaWYgKGFkZHJlc3MpIHtcbiAgICB5aWVsZCBwdXQoYWN0aW9ucy5jYWxsKGFkZHJlc3MpKTtcbiAgfSBlbHNlIHtcbiAgICB5aWVsZCBwdXQoYWN0aW9ucy5jcmVhdGUoYmluYXJ5KSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uKiBjYWxsc3RhY2tTYWdhICgpIHtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICB5aWVsZCB0YWtlKFRJQ0spO1xuICAgIGRlYnVnKFwiZ290IFRJQ0tcIik7XG5cbiAgICBpZiAoeWllbGQgc2VsZWN0KGV2bS5jdXJyZW50LnN0ZXAuaXNDYWxsKSkge1xuICAgICAgZGVidWcoXCJnb3QgY2FsbFwiKTtcbiAgICAgIGxldCBhZGRyZXNzID0geWllbGQgc2VsZWN0KGV2bS5jdXJyZW50LnN0ZXAuY2FsbEFkZHJlc3MpO1xuXG4gICAgICB5aWVsZCBwdXQoYWN0aW9ucy5jYWxsKGFkZHJlc3MpKTtcblxuICAgIH0gZWxzZSBpZiAoeWllbGQgc2VsZWN0KGV2bS5jdXJyZW50LnN0ZXAuaXNDcmVhdGUpKSB7XG4gICAgICBkZWJ1ZyhcImdvdCBjcmVhdGVcIik7XG4gICAgICBsZXQgYmluYXJ5ID0geWllbGQgc2VsZWN0KGV2bS5jdXJyZW50LnN0ZXAuY3JlYXRlQmluYXJ5KTtcblxuICAgICAgeWllbGQgcHV0KGFjdGlvbnMuY3JlYXRlKGJpbmFyeSkpO1xuXG4gICAgfSBlbHNlIGlmICh5aWVsZCBzZWxlY3QoZXZtLmN1cnJlbnQuc3RlcC5pc0hhbHRpbmcpKSB7XG4gICAgICBkZWJ1ZyhcImdvdCByZXR1cm5cIik7XG4gICAgICB5aWVsZCBwdXQoYWN0aW9ucy5yZXR1cm5DYWxsKCkpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24qIHNhZ2EgKCkge1xuICB5aWVsZCBjYWxsKGNhbGxzdGFja1NhZ2EpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBwcmVmaXhOYW1lKFwiZXZtXCIsIHNhZ2EpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9ldm0vc2FnYXMvaW5kZXguanMiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6d2ViMzpzYWdhc1wiKTtcblxuaW1wb3J0IHsgYWxsLCB0YWtlRXZlcnksIGFwcGx5LCBmb3JrLCBqb2luLCB0YWtlLCBwdXQsIHNlbGVjdCB9IGZyb20gJ3JlZHV4LXNhZ2EvZWZmZWN0cyc7XG5pbXBvcnQgeyBwcmVmaXhOYW1lIH0gZnJvbSBcImxpYi9oZWxwZXJzXCI7XG5cbmltcG9ydCAqIGFzIGFjdGlvbnMgZnJvbSBcIi4uL2FjdGlvbnNcIjtcblxuaW1wb3J0IFdlYjNBZGFwdGVyIGZyb20gXCIuLi9hZGFwdGVyXCI7XG5cbmZ1bmN0aW9uKiBmZXRjaFRyYW5zYWN0aW9uSW5mbyhhZGFwdGVyLCB7dHhIYXNofSkge1xuICBkZWJ1ZyhcImluc3BlY3RpbmcgdHJhbnNhY3Rpb25cIik7XG4gIHZhciB0cmFjZTtcbiAgdHJ5IHtcbiAgICB0cmFjZSA9IHlpZWxkIGFwcGx5KGFkYXB0ZXIsIGFkYXB0ZXIuZ2V0VHJhY2UsIFt0eEhhc2hdKTtcbiAgfSBjYXRjaChlKSB7XG4gICAgZGVidWcoXCJwdXR0aW5nIGVycm9yXCIpO1xuICAgIHlpZWxkIHB1dChhY3Rpb25zLmVycm9yKGUpKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBkZWJ1ZyhcImdvdCB0cmFjZVwiKTtcbiAgeWllbGQgcHV0KGFjdGlvbnMucmVjZWl2ZVRyYWNlKHRyYWNlKSk7XG5cbiAgbGV0IHR4ID0geWllbGQgYXBwbHkoYWRhcHRlciwgYWRhcHRlci5nZXRUcmFuc2FjdGlvbiwgW3R4SGFzaF0pO1xuICBpZiAodHgudG8gJiYgdHgudG8gIT0gXCIweDBcIikge1xuICAgIHlpZWxkIHB1dChhY3Rpb25zLnJlY2VpdmVDYWxsKHthZGRyZXNzOiB0eC50b30pKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQgcmVjZWlwdCA9IHlpZWxkIGFwcGx5KGFkYXB0ZXIsIGFkYXB0ZXIuZ2V0UmVjZWlwdCwgW3R4SGFzaF0pO1xuICBpZiAocmVjZWlwdC5jb250cmFjdEFkZHJlc3MpIHtcbiAgICB5aWVsZCBwdXQoYWN0aW9ucy5yZWNlaXZlQ2FsbCh7YmluYXJ5OiB0eC5pbnB1dH0pKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgXCJDb3VsZCBub3QgZmluZCBjb250cmFjdCBhc3NvY2lhdGVkIHdpdGggdHJhbnNhY3Rpb24uIFwiICtcbiAgICBcIlBsZWFzZSBtYWtlIHN1cmUgeW91J3JlIGRlYnVnZ2luZyBhIHRyYW5zYWN0aW9uIHRoYXQgZXhlY3V0ZXMgYSBcIiArXG4gICAgXCJjb250cmFjdCBmdW5jdGlvbiBvciBjcmVhdGVzIGEgbmV3IGNvbnRyYWN0LlwiXG4gICk7XG59XG5cbmZ1bmN0aW9uKiBmZXRjaEJpbmFyeShhZGFwdGVyLCB7YWRkcmVzc30pIHtcbiAgZGVidWcoXCJmZXRjaGluZyBiaW5hcnkgZm9yICVzXCIsIGFkZHJlc3MpO1xuICBsZXQgYmluYXJ5ID0geWllbGQgYXBwbHkoYWRhcHRlciwgYWRhcHRlci5nZXREZXBsb3llZENvZGUsIFthZGRyZXNzXSk7XG5cbiAgZGVidWcoXCJyZWNlaXZlZCBiaW5hcnkgZm9yICVzXCIsIGFkZHJlc3MpO1xuICB5aWVsZCBwdXQoYWN0aW9ucy5yZWNlaXZlQmluYXJ5KGFkZHJlc3MsIGJpbmFyeSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gKmluc3BlY3RUcmFuc2FjdGlvbih0eEhhc2gsIHByb3ZpZGVyKSB7XG4gIHlpZWxkIHB1dChhY3Rpb25zLmluaXQocHJvdmlkZXIpKTtcbiAgeWllbGQgcHV0KGFjdGlvbnMuaW5zcGVjdCh0eEhhc2gpKTtcblxuICBsZXQgYWN0aW9uID0geWllbGQgdGFrZSggKHt0eXBlfSkgPT5cbiAgICB0eXBlID09IGFjdGlvbnMuUkVDRUlWRV9UUkFDRSB8fCB0eXBlID09IGFjdGlvbnMuRVJST1JfV0VCM1xuICApO1xuICBkZWJ1ZyhcImFjdGlvbiAlb1wiLCBhY3Rpb24pO1xuXG4gIHZhciB0cmFjZTtcbiAgaWYgKGFjdGlvbi50eXBlID09IGFjdGlvbnMuUkVDRUlWRV9UUkFDRSkge1xuICAgIHRyYWNlID0gYWN0aW9uLnRyYWNlO1xuICAgIGRlYnVnKFwicmVjZWl2ZWQgdHJhY2VcIik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgZXJyb3I6IGFjdGlvbi5lcnJvciB9O1xuICB9XG5cbiAgbGV0IHthZGRyZXNzLCBiaW5hcnl9ID0geWllbGQgdGFrZShhY3Rpb25zLlJFQ0VJVkVfQ0FMTCk7XG4gIGRlYnVnKFwicmVjZWl2ZWQgY2FsbFwiKTtcblxuICByZXR1cm4geyB0cmFjZSwgYWRkcmVzcywgYmluYXJ5IH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiAqb2J0YWluQmluYXJpZXMoYWRkcmVzc2VzKSB7XG4gIGxldCB0YXNrcyA9IHlpZWxkIGFsbChcbiAgICBhZGRyZXNzZXMubWFwKCAoYWRkcmVzcykgPT4gZm9yayhyZWNlaXZlQmluYXJ5LCBhZGRyZXNzKSApXG4gICk7XG5cbiAgZGVidWcoXCJyZXF1ZXN0aW5nIGJpbmFyaWVzXCIpO1xuICB5aWVsZCBhbGwoXG4gICAgYWRkcmVzc2VzLm1hcCggKGFkZHJlc3MpID0+IHB1dChhY3Rpb25zLmZldGNoQmluYXJ5KGFkZHJlc3MpKSApXG4gICk7XG5cbiAgbGV0IGJpbmFyaWVzID0gW107XG4gIGJpbmFyaWVzID0geWllbGQgYWxsKFxuICAgIHRhc2tzLm1hcCh0YXNrID0+IGpvaW4odGFzaykpXG4gICk7XG5cbiAgZGVidWcoXCJiaW5hcmllcyAlb1wiLCBiaW5hcmllcyk7XG5cbiAgcmV0dXJuIGJpbmFyaWVzO1xufVxuXG5mdW5jdGlvbiAqcmVjZWl2ZUJpbmFyeShhZGRyZXNzKSB7XG4gIGxldCB7YmluYXJ5fSA9IHlpZWxkIHRha2UoKGFjdGlvbikgPT4gKFxuICAgIGFjdGlvbi50eXBlID09IGFjdGlvbnMuUkVDRUlWRV9CSU5BUlkgJiZcbiAgICBhY3Rpb24uYWRkcmVzcyA9PSBhZGRyZXNzXG4gICkpO1xuICBkZWJ1ZyhcImdvdCBiaW5hcnkgZm9yICVzXCIsIGFkZHJlc3MpO1xuXG4gIHJldHVybiBiaW5hcnk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogc2FnYSgpIHtcbiAgLy8gd2FpdCBmb3Igd2ViMyBpbml0IHNpZ25hbFxuICBsZXQge3Byb3ZpZGVyfSA9IHlpZWxkIHRha2UoYWN0aW9ucy5JTklUX1dFQjMpO1xuICBsZXQgYWRhcHRlciA9IG5ldyBXZWIzQWRhcHRlcihwcm92aWRlcik7XG5cbiAgeWllbGQgdGFrZUV2ZXJ5KGFjdGlvbnMuSU5TUEVDVCwgZmV0Y2hUcmFuc2FjdGlvbkluZm8sIGFkYXB0ZXIpO1xuICB5aWVsZCB0YWtlRXZlcnkoYWN0aW9ucy5GRVRDSF9CSU5BUlksIGZldGNoQmluYXJ5LCBhZGFwdGVyKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcHJlZml4TmFtZShcIndlYjNcIiwgc2FnYSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3dlYjMvc2FnYXMvaW5kZXguanMiLCJleHBvcnQgY29uc3QgSU5JVF9XRUIzID0gXCJJTklUX1dFQjNcIjtcbmV4cG9ydCBmdW5jdGlvbiBpbml0KHByb3ZpZGVyKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogSU5JVF9XRUIzLFxuICAgIHByb3ZpZGVyXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IElOU1BFQ1QgPSBcIklOU1BFQ1RfVFJBTlNBQ1RJT05cIjtcbmV4cG9ydCBmdW5jdGlvbiBpbnNwZWN0KHR4SGFzaCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IElOU1BFQ1QsXG4gICAgdHhIYXNoXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IEZFVENIX0JJTkFSWSA9IFwiRkVUQ0hfQklOQVJZXCI7XG5leHBvcnQgZnVuY3Rpb24gZmV0Y2hCaW5hcnkoYWRkcmVzcykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEZFVENIX0JJTkFSWSxcbiAgICBhZGRyZXNzXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBSRUNFSVZFX0JJTkFSWSA9IFwiUkVDRUlWRV9CSU5BUllcIjtcbmV4cG9ydCBmdW5jdGlvbiByZWNlaXZlQmluYXJ5KGFkZHJlc3MsIGJpbmFyeSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFJFQ0VJVkVfQklOQVJZLFxuICAgIGFkZHJlc3MsIGJpbmFyeVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBSRUNFSVZFX1RSQUNFID0gXCJSRUNFSVZFX1RSQUNFXCI7XG5leHBvcnQgZnVuY3Rpb24gcmVjZWl2ZVRyYWNlKHRyYWNlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogUkVDRUlWRV9UUkFDRSxcbiAgICB0cmFjZVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBSRUNFSVZFX0NBTEwgPSBcIlJFQ0VJVkVfQ0FMTFwiO1xuZXhwb3J0IGZ1bmN0aW9uIHJlY2VpdmVDYWxsKHthZGRyZXNzLCBiaW5hcnl9KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogUkVDRUlWRV9DQUxMLFxuICAgIGFkZHJlc3MsIGJpbmFyeVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBFUlJPUl9XRUIzID0gXCJFUlJPUl9XRUIzXCI7XG5leHBvcnQgZnVuY3Rpb24gZXJyb3IoZXJyb3IpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBFUlJPUl9XRUIzLFxuICAgIGVycm9yXG4gIH07XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3dlYjMvYWN0aW9ucy9pbmRleC5qcyIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcblxuaW1wb3J0IFdlYjMgZnJvbSBcIndlYjNcIjtcblxuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOndlYjM6YWRhcHRlclwiKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2ViM0FkYXB0ZXIge1xuICBjb25zdHJ1Y3Rvcihwcm92aWRlcikge1xuICAgIHRoaXMud2ViMyA9IG5ldyBXZWIzKHByb3ZpZGVyKTtcbiAgfVxuXG4gIGFzeW5jIGdldFRyYWNlKHR4SGFzaCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSggKGFjY2VwdCwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLndlYjMuY3VycmVudFByb3ZpZGVyLnNlbmRBc3luYyh7XG4gICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgIG1ldGhvZDogXCJkZWJ1Z190cmFjZVRyYW5zYWN0aW9uXCIsXG4gICAgICAgIHBhcmFtczogW3R4SGFzaCwge31dLFxuICAgICAgICBpZDogbmV3IERhdGUoKS5nZXRUaW1lKClcbiAgICAgIH0sIChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHJldHVybiByZWplY3QobmV3IEVycm9yKHJlc3VsdC5lcnJvci5tZXNzYWdlKSk7XG4gICAgICAgIGRlYnVnKFwicmVzdWx0OiAlb1wiLCByZXN1bHQpO1xuICAgICAgICBhY2NlcHQocmVzdWx0LnJlc3VsdC5zdHJ1Y3RMb2dzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIGFzeW5jIGdldFRyYW5zYWN0aW9uKHR4SGFzaCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSggKGFjY2VwdCwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLndlYjMuZXRoLmdldFRyYW5zYWN0aW9uKHR4SGFzaCwgKGVyciwgdHgpID0+IHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpO1xuXG4gICAgICAgIHJldHVybiBhY2NlcHQodHgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgYXN5bmMgZ2V0UmVjZWlwdCh0eEhhc2gpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoIChhY2NlcHQsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy53ZWIzLmV0aC5nZXRUcmFuc2FjdGlvblJlY2VpcHQodHhIYXNoLCAoZXJyLCByZWNlaXB0KSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKTtcblxuICAgICAgICByZXR1cm4gYWNjZXB0KHJlY2VpcHQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIGdldERlcGxveWVkQ29kZSAtIGdldCB0aGUgZGVwbG95ZWQgY29kZSBmb3IgYW4gYWRkcmVzcyBmcm9tIHRoZSBjbGllbnRcbiAgICogQHBhcmFtICB7U3RyaW5nfSBhZGRyZXNzXG4gICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICBkZXBsb3llZEJpbmFyeVxuICAgKi9cbiAgYXN5bmMgZ2V0RGVwbG95ZWRDb2RlKGFkZHJlc3MpIHtcbiAgICBkZWJ1ZyhcImdldHRpbmcgZGVwbG95ZWQgY29kZSBmb3IgJXNcIiwgYWRkcmVzcyk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChhY2NlcHQsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy53ZWIzLmV0aC5nZXRDb2RlKGFkZHJlc3MsIChlcnIsIGRlcGxveWVkQmluYXJ5KSA9PiB7XG4gICAgICAgIGlmIChlcnIpIGRlYnVnKFwiZXJyb3I6ICVvXCIsIGVycik7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgZGVidWcoXCJnb3QgZGVwbG95ZWQgY29kZSBmb3IgJXNcIiwgYWRkcmVzcyk7XG4gICAgICAgIGFjY2VwdChkZXBsb3llZEJpbmFyeSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvd2ViMy9hZGFwdGVyLmpzIiwiaW1wb3J0IHsgY29tYmluZVJlZHVjZXJzIH0gZnJvbSBcInJlZHV4XCI7XG5cbmltcG9ydCBkYXRhIGZyb20gXCJsaWIvZGF0YS9yZWR1Y2Vyc1wiO1xuaW1wb3J0IGV2bSBmcm9tIFwibGliL2V2bS9yZWR1Y2Vyc1wiO1xuaW1wb3J0IHNvbGlkaXR5IGZyb20gXCJsaWIvc29saWRpdHkvcmVkdWNlcnNcIjtcbmltcG9ydCB0cmFjZSBmcm9tIFwibGliL3RyYWNlL3JlZHVjZXJzXCI7XG5cbmltcG9ydCAqIGFzIGFjdGlvbnMgZnJvbSBcIi4vYWN0aW9uc1wiO1xuXG5leHBvcnQgY29uc3QgV0FJVElORyA9IFwiV0FJVElOR1wiO1xuZXhwb3J0IGNvbnN0IEFDVElWRSA9IFwiQUNUSVZFXCI7XG5leHBvcnQgY29uc3QgRVJST1IgPSBcIkVSUk9SXCI7XG5leHBvcnQgY29uc3QgRklOSVNIRUQgPSBcIkZJTklTSEVEXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXNzaW9uKHN0YXRlID0gV0FJVElORywgYWN0aW9uKSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIGFjdGlvbnMuUkVBRFk6XG4gICAgICByZXR1cm4gQUNUSVZFO1xuXG4gICAgY2FzZSBhY3Rpb25zLkVSUk9SOlxuICAgICAgcmV0dXJuIHsgZXJyb3I6IGFjdGlvbi5lcnJvciB9O1xuXG4gICAgY2FzZSBhY3Rpb25zLkZJTklTSDpcbiAgICAgIHJldHVybiBGSU5JU0hFRDtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuY29uc3QgcmVkdWNlU3RhdGUgPSBjb21iaW5lUmVkdWNlcnMoe1xuICBzZXNzaW9uLFxuICBkYXRhLFxuICBldm0sXG4gIHNvbGlkaXR5LFxuICB0cmFjZSxcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCByZWR1Y2VTdGF0ZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvc2Vzc2lvbi9yZWR1Y2Vycy5qcyIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjpkYXRhOnJlZHVjZXJzXCIpO1xuXG5pbXBvcnQgeyBjb21iaW5lUmVkdWNlcnMgfSBmcm9tIFwicmVkdXhcIjtcblxuaW1wb3J0ICogYXMgYWN0aW9ucyBmcm9tIFwiLi9hY3Rpb25zXCI7XG5cbmNvbnN0IERFRkFVTFRfU0NPUEVTID0ge1xuICBieUlkOiB7fVxufTtcblxuZnVuY3Rpb24gc2NvcGVzKHN0YXRlID0gREVGQVVMVF9TQ09QRVMsIGFjdGlvbikge1xuICB2YXIgY29udGV4dDtcbiAgdmFyIHNjb3BlO1xuICB2YXIgdmFyaWFibGVzO1xuXG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIGFjdGlvbnMuU0NPUEU6XG4gICAgICBzY29wZSA9IHN0YXRlLmJ5SWRbYWN0aW9uLmlkXSB8fCB7fTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYnlJZDoge1xuICAgICAgICAgIC4uLnN0YXRlLmJ5SWQsXG5cbiAgICAgICAgICBbYWN0aW9uLmlkXToge1xuICAgICAgICAgICAgLi4uc2NvcGUsXG5cbiAgICAgICAgICAgIGlkOiBhY3Rpb24uaWQsXG4gICAgICAgICAgICBzb3VyY2VJZDogYWN0aW9uLnNvdXJjZUlkLFxuICAgICAgICAgICAgcGFyZW50SWQ6IGFjdGlvbi5wYXJlbnRJZCxcbiAgICAgICAgICAgIHBvaW50ZXI6IGFjdGlvbi5wb2ludGVyXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICBjYXNlIGFjdGlvbnMuREVDTEFSRTpcbiAgICAgIHNjb3BlID0gc3RhdGUuYnlJZFthY3Rpb24ubm9kZS5zY29wZV0gfHwge307XG4gICAgICB2YXJpYWJsZXMgPSBzY29wZS52YXJpYWJsZXMgfHwgW107XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJ5SWQ6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5ieUlkLFxuXG4gICAgICAgICAgW2FjdGlvbi5ub2RlLnNjb3BlXToge1xuICAgICAgICAgICAgLi4uc2NvcGUsXG5cbiAgICAgICAgICAgIHZhcmlhYmxlczogW1xuICAgICAgICAgICAgICAuLi52YXJpYWJsZXMsXG5cbiAgICAgICAgICAgICAge25hbWU6IGFjdGlvbi5ub2RlLm5hbWUsIGlkOiBhY3Rpb24ubm9kZS5pZH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuY29uc3QgaW5mbyA9IGNvbWJpbmVSZWR1Y2Vycyh7XG4gIHNjb3Blc1xufSk7XG5cbmNvbnN0IERFRkFVTFRfQVNTSUdOTUVOVFMgPSB7XG4gIGJ5SWQ6IHt9XG59O1xuXG5mdW5jdGlvbiBhc3NpZ25tZW50cyhzdGF0ZSA9IERFRkFVTFRfQVNTSUdOTUVOVFMsIGFjdGlvbikge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBhY3Rpb25zLkFTU0lHTjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJ5SWQ6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5ieUlkLFxuXG4gICAgICAgICAgLi4uT2JqZWN0LmFzc2lnbih7fSxcbiAgICAgICAgICAgIC4uLk9iamVjdC5lbnRyaWVzKGFjdGlvbi5hc3NpZ25tZW50cykubWFwKFxuICAgICAgICAgICAgICAoW2lkLCByZWZdKSA9PiAoe1xuICAgICAgICAgICAgICAgIFtpZF06IHtcbiAgICAgICAgICAgICAgICAgIC4uLnN0YXRlLmJ5SWRbaWRdLFxuICAgICAgICAgICAgICAgICAgcmVmXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKVxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn07XG5cbmNvbnN0IHByb2MgPSBjb21iaW5lUmVkdWNlcnMoe1xuICBhc3NpZ25tZW50c1xufSk7XG5cbmNvbnN0IHJlZHVjZXIgPSBjb21iaW5lUmVkdWNlcnMoe1xuICBpbmZvLFxuICBwcm9jXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgcmVkdWNlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvZGF0YS9yZWR1Y2Vycy5qcyIsImltcG9ydCB7IGNvbWJpbmVSZWR1Y2VycyB9IGZyb20gXCJyZWR1eFwiO1xuXG5pbXBvcnQgKiBhcyBhY3Rpb25zIGZyb20gXCIuL2FjdGlvbnNcIjtcbmltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCJsaWIvaGVscGVyc1wiO1xuXG5jb25zdCBERUZBVUxUX0NPTlRFWFRTID0ge1xuICBieUNvbnRleHQ6IHt9LFxuICBieUJpbmFyeToge31cbn07XG5cbmZ1bmN0aW9uIGNvbnRleHRzKHN0YXRlID0gREVGQVVMVF9DT05URVhUUywgYWN0aW9uKSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAvKlxuICAgICAqIEFkZGluZyBhIG5ldyBjb250ZXh0XG4gICAgICovXG4gICAgY2FzZSBhY3Rpb25zLkFERF9DT05URVhUOlxuICAgICAgbGV0IHsgY29udHJhY3ROYW1lLCBiaW5hcnkgfSA9IGFjdGlvbjtcblxuICAgICAgaWYgKHN0YXRlLmJ5QmluYXJ5W2JpbmFyeV0pIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfVxuXG4gICAgICBsZXQgY29udGV4dCA9IGtlY2NhazI1NihiaW5hcnkpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBieUNvbnRleHQ6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5ieUNvbnRleHQsXG5cbiAgICAgICAgICBbY29udGV4dF06IHsgY29udGV4dCwgYmluYXJ5LCBjb250cmFjdE5hbWUgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGJ5QmluYXJ5OiB7XG4gICAgICAgICAgLi4uc3RhdGUuYnlCaW5hcnksXG5cbiAgICAgICAgICBbYmluYXJ5XTogeyBjb250ZXh0OiBjb250ZXh0IH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgIC8qXG4gICAgICogRGVmYXVsdCBjYXNlXG4gICAgICovXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5jb25zdCBERUZBVUxUX0lOU1RBTkNFUyA9IHtcbiAgYnlBZGRyZXNzOiB7fSxcbiAgYnlDb250ZXh0OiB7fVxufVxuXG5mdW5jdGlvbiBpbnN0YW5jZXMoc3RhdGUgPSBERUZBVUxUX0lOU1RBTkNFUywgYWN0aW9uKSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAvKlxuICAgICAqIEFkZGluZyBhIG5ldyBhZGRyZXNzIGZvciBjb250ZXh0XG4gICAgICovXG4gICAgY2FzZSBhY3Rpb25zLkFERF9JTlNUQU5DRTpcbiAgICAgIGxldCB7IGFkZHJlc3MsIGNvbnRleHQsIGJpbmFyeSB9ID0gYWN0aW9uO1xuXG4gICAgICAvLyBnZXQga25vd24gYWRkcmVzc2VzIGZvciB0aGlzIGNvbnRleHRcbiAgICAgIGxldCBvdGhlckluc3RhbmNlcyA9IHN0YXRlLmJ5Q29udGV4dFtjb250ZXh0XSB8fCBbXTtcbiAgICAgIGxldCBvdGhlckFkZHJlc3NlcyA9IG90aGVySW5zdGFuY2VzLm1hcCgoe2FkZHJlc3N9KSA9PiBhZGRyZXNzKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYnlBZGRyZXNzOiB7XG4gICAgICAgICAgLi4uc3RhdGUuYnlBZGRyZXNzLFxuXG4gICAgICAgICAgW2FkZHJlc3NdOiB7IGNvbnRleHQsIGJpbmFyeSB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYnlDb250ZXh0OiB7XG4gICAgICAgICAgLi4uc3RhdGUuYnlDb250ZXh0LFxuXG4gICAgICAgICAgLy8gcmVjb25zdHJ1Y3QgY29udGV4dCBpbnN0YW5jZXMgdG8gaW5jbHVkZSBuZXcgYWRkcmVzc1xuICAgICAgICAgIFtjb250ZXh0XTogQXJyYXkuZnJvbShuZXcgU2V0KG90aGVyQWRkcmVzc2VzKS5hZGQoYWRkcmVzcykpXG4gICAgICAgICAgICAubWFwKChhZGRyZXNzKSA9PiAoe2FkZHJlc3N9KSlcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgIC8qXG4gICAgICogRGVmYXVsdCBjYXNlXG4gICAgICovXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG59XG5cbmNvbnN0IGluZm8gPSBjb21iaW5lUmVkdWNlcnMoe1xuICBjb250ZXh0cyxcbiAgaW5zdGFuY2VzXG59KTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGxzdGFjayhzdGF0ZSA9IFtdLCBhY3Rpb24pIHtcbiAgc3dpdGNoKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBhY3Rpb25zLkNBTEw6XG4gICAgICBsZXQgYWRkcmVzcyA9IGFjdGlvbi5hZGRyZXNzO1xuICAgICAgcmV0dXJuIHN0YXRlLmNvbmNhdChbIHthZGRyZXNzfSBdKTtcblxuICAgIGNhc2UgYWN0aW9ucy5DUkVBVEU6XG4gICAgICBjb25zdCBiaW5hcnkgPSBhY3Rpb24uYmluYXJ5O1xuICAgICAgcmV0dXJuIHN0YXRlLmNvbmNhdChbIHtiaW5hcnl9IF0pO1xuXG4gICAgY2FzZSBhY3Rpb25zLlJFVFVSTjpcbiAgICAgIHJldHVybiBzdGF0ZS5zbGljZSgwLCAtMSk7IC8vIHBvcFxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfTtcbn1cblxuY29uc3QgcHJvYyA9IGNvbWJpbmVSZWR1Y2Vycyh7XG4gIGNhbGxzdGFja1xufSk7XG5cbmNvbnN0IHJlZHVjZXIgPSBjb21iaW5lUmVkdWNlcnMoe1xuICBpbmZvLFxuICBwcm9jXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgcmVkdWNlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvZXZtL3JlZHVjZXJzLmpzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL2FycmF5L2Zyb21cIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvYXJyYXkvZnJvbVwiXG4vLyBtb2R1bGUgaWQgPSA2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBjb21iaW5lUmVkdWNlcnMgfSBmcm9tIFwicmVkdXhcIjtcblxuaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcImxpYi9oZWxwZXJzXCI7XG5cbmltcG9ydCAqIGFzIGFjdGlvbnMgZnJvbSBcIi4vYWN0aW9uc1wiO1xuXG5jb25zdCBERUZBVUxUX1NPVVJDRVMgPSB7XG4gIGJ5SWQ6IHt9XG59O1xuXG5mdW5jdGlvbiBzb3VyY2VzKHN0YXRlID0gREVGQVVMVF9TT1VSQ0VTLCBhY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIC8qXG4gICAgICogQWRkaW5nIGEgbmV3IHNvdXJjZVxuICAgICAqL1xuICAgIGNhc2UgYWN0aW9ucy5BRERfU09VUkNFOlxuICAgICAgbGV0IHsgYXN0LCBzb3VyY2UsIHNvdXJjZVBhdGggfSA9IGFjdGlvbjtcblxuICAgICAgbGV0IGlkID0gT2JqZWN0LmtleXMoc3RhdGUuYnlJZCkubGVuZ3RoO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBieUlkOiB7XG4gICAgICAgICAgLi4uc3RhdGUuYnlJZCxcblxuICAgICAgICAgIFtpZF06IHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgYXN0LFxuICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgc291cmNlUGF0aFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgLypcbiAgICAgKiBEZWZhdWx0IGNhc2VcbiAgICAgKi9cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cblxuY29uc3QgREVGQVVMVF9TT1VSQ0VNQVBTID0ge1xuICBieUNvbnRleHQ6IHt9XG59O1xuXG5mdW5jdGlvbiBzb3VyY2VNYXBzKHN0YXRlID0gREVGQVVMVF9TT1VSQ0VNQVBTLCBhY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIC8qXG4gICAgICogQWRkaW5nIGEgbmV3IHNvdXJjZU1hcFxuICAgICAqL1xuICAgIGNhc2UgYWN0aW9ucy5BRERfU09VUkNFTUFQOlxuICAgICAgbGV0IHsgYmluYXJ5LCBzb3VyY2VNYXAgfSA9IGFjdGlvbjtcbiAgICAgIGxldCBjb250ZXh0ID0ga2VjY2FrMjU2KGJpbmFyeSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJ5Q29udGV4dDoge1xuICAgICAgICAgIC4uLnN0YXRlLmJ5Q29udGV4dCxcblxuICAgICAgICAgIFtjb250ZXh0XToge1xuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIHNvdXJjZU1hcFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgIC8qXG4gICAgICogRGVmYXVsdCBDYXNlXG4gICAgICovXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5jb25zdCBpbmZvID0gY29tYmluZVJlZHVjZXJzKHtcbiAgc291cmNlcyxcbiAgc291cmNlTWFwc1xufSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBmdW5jdGlvbkRlcHRoKHN0YXRlID0gMSwgYWN0aW9uKSB7XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5KVU1QKSB7XG4gICAgY29uc3QgZGVsdGEgPSBzcGVsdW5rKGFjdGlvbi5qdW1wRGlyZWN0aW9uKVxuICAgIHJldHVybiBzdGF0ZSArIGRlbHRhO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzcGVsdW5rKGp1bXApIHtcbiAgaWYgKGp1bXAgPT0gXCJpXCIpIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIGlmIChqdW1wID09IFwib1wiKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59XG5cbmNvbnN0IHByb2MgPSBjb21iaW5lUmVkdWNlcnMoe1xuICBmdW5jdGlvbkRlcHRoXG59KTtcblxuY29uc3QgcmVkdWNlciA9IGNvbWJpbmVSZWR1Y2Vycyh7XG4gIGluZm8sXG4gIHByb2Ncbn0pO1xuXG5leHBvcnQgZGVmYXVsdCByZWR1Y2VyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9zb2xpZGl0eS9yZWR1Y2Vycy5qcyIsImltcG9ydCB7IGNvbWJpbmVSZWR1Y2VycyB9IGZyb20gXCJyZWR1eFwiO1xuXG5pbXBvcnQgKiBhcyBhY3Rpb25zIGZyb20gXCIuL2FjdGlvbnNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGluZGV4KHN0YXRlID0gMCwgYWN0aW9uKSB7XG4gIGlmIChhY3Rpb24udHlwZSA9PSBhY3Rpb25zLlRPQ0sgfHwgYWN0aW9uLnR5cGUgPT0gYWN0aW9ucy5FTkRfT0ZfVFJBQ0UpIHtcbiAgICByZXR1cm4gc3RhdGUgKyAxO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RlcHMoc3RhdGUgPSBudWxsLCBhY3Rpb24pIHtcbiAgaWYgKGFjdGlvbi50eXBlID09IGFjdGlvbnMuU0FWRV9TVEVQUykge1xuICAgIHJldHVybiBhY3Rpb24uc3RlcHM7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cbmNvbnN0IGluZm8gPSBjb21iaW5lUmVkdWNlcnMoe1xuICBzdGVwc1xufSlcblxuY29uc3QgcHJvYyA9IGNvbWJpbmVSZWR1Y2Vycyh7XG4gIGluZGV4XG59KVxuXG5jb25zdCByZWR1Y2VyID0gY29tYmluZVJlZHVjZXJzKHtcbiAgaW5mbyxcbiAgcHJvY1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHJlZHVjZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3RyYWNlL3JlZHVjZXJzLmpzIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOnNlc3Npb246c2VsZWN0b3JzXCIpO1xuXG5pbXBvcnQgeyBjcmVhdGVTZWxlY3RvclRyZWUsIGNyZWF0ZUxlYWYgfSBmcm9tIFwicmVzZWxlY3QtdHJlZVwiO1xuXG5pbXBvcnQgZXZtIGZyb20gXCJsaWIvZXZtL3NlbGVjdG9yc1wiO1xuaW1wb3J0IHNvbGlkaXR5IGZyb20gXCJsaWIvc29saWRpdHkvc2VsZWN0b3JzXCI7XG5cbmNvbnN0IHNlc3Npb24gPSBjcmVhdGVTZWxlY3RvclRyZWUoe1xuICAvKipcbiAgICogc2Vzc2lvbi5pbmZvXG4gICAqL1xuICBpbmZvOiB7XG5cbiAgICAvKipcbiAgICAgKiBzZXNzaW9uLmluZm8uYWZmZWN0ZWRJbnN0YW5jZXNcbiAgICAgKi9cbiAgICBhZmZlY3RlZEluc3RhbmNlczogY3JlYXRlTGVhZihcbiAgICAgIFtldm0uaW5mby5pbnN0YW5jZXMsIGV2bS5pbmZvLmNvbnRleHRzLCBzb2xpZGl0eS5pbmZvLnNvdXJjZXMsIHNvbGlkaXR5LmluZm8uc291cmNlTWFwc10sXG5cbiAgICAgIChpbnN0YW5jZXMsIGNvbnRleHRzLCBzb3VyY2VzLCBzb3VyY2VNYXBzKSA9PiBPYmplY3QuYXNzaWduKHt9LFxuICAgICAgICAuLi5PYmplY3QuZW50cmllcyhpbnN0YW5jZXMpLm1hcChcbiAgICAgICAgICAoW2FkZHJlc3MsIHtjb250ZXh0fV0pID0+IHtcbiAgICAgICAgICAgIGxldCB7IGNvbnRyYWN0TmFtZSwgYmluYXJ5IH0gPSBjb250ZXh0c1tjb250ZXh0XTtcbiAgICAgICAgICAgIGxldCB7IHNvdXJjZU1hcCB9ID0gc291cmNlTWFwc1tjb250ZXh0XTtcblxuICAgICAgICAgICAgbGV0IHsgc291cmNlIH0gPSBzb3VyY2VNYXAgP1xuICAgICAgICAgICAgICAvLyBsb29rIGZvciBzb3VyY2UgSUQgYmV0d2VlbiBzZWNvbmQgYW5kIHRoaXJkIGNvbG9ucyAoSEFDSylcbiAgICAgICAgICAgICAgc291cmNlc1tzb3VyY2VNYXAubWF0Y2goL15bXjpdKzpbXjpdKzooW146XSspOi8pWzFdXSA6XG4gICAgICAgICAgICAgIHt9O1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBbYWRkcmVzc106IHtcbiAgICAgICAgICAgICAgICBjb250cmFjdE5hbWUsIHNvdXJjZSwgYmluYXJ5XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICApXG4gICAgKVxuICB9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgc2Vzc2lvbjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvc2Vzc2lvbi9zZWxlY3RvcnMvaW5kZXguanMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDN0RBOzs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7O0FDRUE7QUFZQTtBQUNBO0FBZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7Ozs7OztBQ2hCQTs7Ozs7O0FDQUE7Ozs7OztBQ0FBOzs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0FBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUxBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUdBOzs7QUFHQTtBQUNBO0FBR0E7OztBQUdBO0FBQ0E7QUFLQTs7Ozs7QUFLQTtBQUNBO0FBR0E7OztBQUdBO0FBQ0E7QUFHQTs7Ozs7QUFLQTtBQS9DQTtBQUNBO0FBbURBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBS0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFuQ0E7QUFzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFJQTtBQTNCQTtBQWRBO0FBQ0E7QUE0Q0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBS0E7OztBQUdBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRkE7QUFJQTtBQUNBO0FBRUE7Ozs7O0FBS0E7QUFTQTtBQURBO0FBQ0E7QUFJQTs7O0FBR0E7QUFoRUE7QUFDQTtBQWtFQTs7O0FBR0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBU0E7QUFEQTtBQUNBO0FBSUE7QUFwQkE7QUEvSEE7QUFDQTtBQXNKQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQy9RQTtBQUNBOzs7QUFFQTtBQUNBO0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQ0E7QUFDQTs7Ozs7QUFQQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUpBO0FBSEE7QUFZQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBVEE7QUFDQTtBQVdBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFLQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBREE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUhBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUdBO0FBQ0E7QUFLQTs7O0FBR0E7QUFDQTtBQUtBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUtBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBN0xBO0FBeEJBO0FBQ0E7QUEwTkE7Ozs7OztBQ25QQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1lBO0FBa0JBO0FBVUE7QUFTQTtBQThFQTtBQXNCQTtBQW9CQTtBQUlBO0FBSUE7QUFxQkE7QUFlQTtBQWFBO0FBMENBO0FBd0JBO0FBQ0E7QUFyU0E7QUFDQTs7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7Ozs7O0FBSkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBT0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFmQTtBQWlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwVEE7QUFDQTs7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7OztBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7OztBQVJBO0FBQ0E7QUFTQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFKQTtBQUNBO0FBTUE7OztBQUdBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBR0E7Ozs7O0FBS0E7QUFDQTtBQUdBOzs7OztBQUtBO0FBQ0E7QUFLQTs7Ozs7QUFLQTtBQUNBO0FBckNBO0FBZEE7QUFDQTtBQTJEQTs7Ozs7Ozs7Ozs7O0FDekVBO0FBUUE7QUFRQTtBQUtBO0FBS0E7QUFLQTtBQWhDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUdBOzs7OztBQUtBO0FBQ0E7QUFHQTs7Ozs7QUFLQTtBQXRDQTtBQUNBO0FBMkNBOzs7Ozs7QUM5Q0E7Ozs7OztBQ0FBOzs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7O0FDQ0E7QUFRQTtBQU9BO0FBUUE7QUFPQTtBQS9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7Ozs7O0FDcENBOzs7Ozs7QUNBQTs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7OztBQ0NBO0FBUUE7QUFLQTtBQUtBO0FBS0E7QUFLQTtBQUtBO0FBTUE7QUF4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOzs7Ozs7QUM3Q0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2dCQTtBQUlBO0FBaUZBO0FBQ0E7QUF0R0E7QUFDQTs7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7QUFkQTtBQUNBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQWxEQTtBQW9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDOUdBO0FBUUE7QUFRQTtBQWpCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdEJBO0FBQ0E7OztBQUVBO0FBQ0E7QUFBQTtBQUNBOzs7QUFDQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFDQTtBQUNBOzs7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBYkE7QUFDQTtBQWFBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQU9BOzs7QUFHQTtBQUNBO0FBUUE7OztBQUdBO0FBTUE7QUFEQTtBQWhDQTtBQTBDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQU1BO0FBQ0E7QUFFQTtBQUhBO0FBREE7QUFWQTtBQUNBO0FBdUJBOzs7OztBQUtBO0FBSUE7QUFDQTtBQTlDQTtBQUNBO0FBaURBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBTEE7QUFDQTtBQU9BOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBTEE7QUFDQTtBQU9BOzs7QUFHQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOzs7QUFHQTtBQUxBO0FBQ0E7QUFTQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFLQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7Ozs7QUFLQTtBQVNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBR0E7QUFVQTtBQURBO0FBQ0E7QUFLQTtBQTVGQTtBQXZCQTtBQUNBO0FBc0hBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBTEE7QUEzTUE7QUFDQTtBQW1OQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4UEE7QUFpQ0E7QUFJQTtBQVNBO0FBQ0E7QUF2RUE7QUFDQTs7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFSQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzVFQTtBQVFBO0FBU0E7QUFsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7Ozs7Ozs7Ozs7O0FDdEJBO0FBUUE7QUFRQTtBQVFBO0FBUUE7QUFqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTs7Ozs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNIQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7Ozs7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWpCQTtBQWtCQTtBQUNBO0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQXhFQTtBQUNBO0FBREE7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6QkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0FBO0FBQ0E7OztBQUVBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBOzs7QUFBQTtBQUNBOzs7Ozs7O0FBZEE7QUFDQTtBQWNBOzs7QUFHQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFqSkE7QUFBQTs7Ozs7O0FDbkJBOzs7Ozs7QUNBQTs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDU0E7QUFjQTtBQXlCQTtBQUNBO0FBakRBO0FBQ0E7OztBQUVBO0FBQ0E7Ozs7O0FBSEE7QUFDQTtBQUlBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTs7Ozs7OztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ25zQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNOQTtBQUNBOzs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNPQTtBQXlDQTtBQUNBO0FBbERBO0FBQ0E7OztBQUdBO0FBQ0E7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7OztBQU5BO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFOQTtBQUNBO0FBUUE7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUMvRUE7Ozs7OztBQ0FBOzs7Ozs7Ozs7Ozs7QUNpQkE7QUFDQTtBQWxCQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7Ozs7O0FBZkE7QUFDQTtBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDOURBO0FBZ0JBO0FBQ0E7QUEvRUE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQVhBO0FBQ0E7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM0VBO0FBYUE7QUFrQ0E7QUE4RUE7QUFrSEE7QUFDQTtBQTFQQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBOzs7OztBQVBBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXhCQTtBQTBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUdBO0FBREE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUhBO0FBSEE7QUFDQTtBQVdBO0FBQ0E7QUFEQTtBQUtBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQXJFQTtBQXdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFHQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBREE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQXRHQTtBQXdHQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBOzs7Ozs7Ozs7Ozs7QUN2UEE7QUFTQTtBQStCQTtBQUNBO0FBekRBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTs7Ozs7QUFMQTtBQUNBO0FBTUE7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwREE7QUFxQ0E7QUFDQTtBQW5EQTtBQUNBOzs7QUFFQTtBQUNBO0FBQUE7QUFDQTs7Ozs7QUFKQTtBQUNBO0FBS0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUVBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzFGQTtBQVFBO0FBVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDZUE7QUFDQTtBQTdCQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBWEE7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWUE7QUFDQTs7Ozs7Ozs7Ozs7OztBQzlOQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7Ozs7QUFQQTtBQUNBO0FBT0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFkQTtBQW5CQTtBQUxBO0FBQ0E7QUEwQ0E7Ozs7Ozs7Ozs7OztBQ2pEQTtBQUlBO0FBc0JBO0FBQ0E7QUF0Q0E7QUFDQTs7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBVEE7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDekJBO0FBV0E7QUFXQTtBQVFBO0FBd0JBO0FBQ0E7QUF2RUE7QUFDQTs7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBVEE7QUFDQTtBQVNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN2QkE7QUF1QkE7QUE4QkE7QUFDQTtBQXpHQTtBQUNBOzs7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQVJBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNoSEE7QUFRQTtBQVFBO0FBUUE7QUFRQTtBQVFBO0FBUUE7QUFqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3REQTtBQUNBOzs7QUFDQTtBQUNBOzs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWJBO0FBY0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFRQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVVBO0FBeERBO0FBQUE7Ozs7Ozs7Ozs7Ozs7QUNRQTtBQUNBO0FBZkE7QUFDQTtBQUNBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUNBO0FBQ0E7QUFEQTtBQUNBOzs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVhBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQ0E7QUFPQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7Ozs7O0FBTEE7QUFDQTtBQUtBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFIQTtBQURBO0FBQ0E7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUhBO0FBSEE7QUFEQTtBQUNBO0FBZUE7QUFDQTtBQXhDQTtBQTBDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUVBO0FBRkE7QUFEQTtBQU5BO0FBQ0E7QUFnQkE7QUFDQTtBQXBCQTtBQXNCQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNUQTtBQUNBO0FBOUZBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUVBO0FBSEE7QUFQQTtBQUNBO0FBYUE7OztBQUdBO0FBQ0E7QUEvQkE7QUFpQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFKQTtBQVBBO0FBQ0E7QUFlQTs7O0FBR0E7QUFDQTtBQS9CQTtBQWtDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWJBO0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBOzs7Ozs7QUN4SEE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQytFQTtBQUNBO0FBaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7Ozs7O0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFIQTtBQUNBO0FBV0E7OztBQWJBO0FBaUJBO0FBMUJBO0FBNEJBO0FBQ0E7QUFFQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUhBO0FBREE7QUFDQTtBQVVBOzs7QUFHQTtBQUNBO0FBdkJBO0FBeUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTs7Ozs7Ozs7Ozs7O0FDdkdBO0FBUUE7QUFDQTtBQWJBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUFBO0FBQ0E7Ozs7O0FBTkE7QUFDQTtBQU1BO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFLQTtBQXhCQTtBQUpBO0FBQ0E7QUFrQ0E7Ozs7QSIsInNvdXJjZVJvb3QiOiIifQ==